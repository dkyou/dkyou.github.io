[{"title":"禁止把 Windows PATH 注入到 WSL","path":"/2026/01/02/禁止把 Windows PATH 注入到 WSL/","content":"禁止把 Windows PATH 注入到 WSL现象在编译buildroot时候提示： dky@LAPTOP-Q5IILQ3E:~/workspaces_buildroot/buildroot-2020.02.12$ make V=1/usr/bin/make -j1 O=/home/dky/workspaces_buildroot/buildroot-2020.02.12/output HOSTCC=/usr/bin/gcc HOSTCXX=/usr/bin/g++ syncconfigmake[1]: Entering directory /home/dky/workspaces_buildroot/buildroot-2020.02.12make[1]: Leaving directory /home/dky/workspaces_buildroot/buildroot-2020.02.12Your PATH contains spaces, TABs, and/or newline ( ) characters.This doesnt work. Fix you PATH.make: *** [support/dependencies/dependencies.mk:27: dependencies] Error 1 大意是说：path路径中包含空格回车等，导致编译失败。 查看printf %s $PATH | cat -A后发现有windows的path变量，如下： 原因这是因为WSL 默认会把 Windows 的 PATH拼进来 解决方法因此解决方法就是：要么将这些多余的PATH环境变量暂时屏蔽掉，要么彻底关掉windows的path注入wsl。我选择后者，具体做法如下：**** 编辑（或创建）这个文件： sudo nano /etc/wsl.conf 写入： [interop]appendWindowsPath=false 然后在 Windows PowerShell（不是 WSL 里）执行重启 WSL： wsl --shutdown 重新打开 WSL 终端，再检查： printf %s $PATH | cat -A 输出 dky@LAPTOP-Q5IILQ3E:~/workspaces_buildroot/buildroot-2020.02.12$ printf %s $PATH | cat -A/home/dky/.vscode-server/data/User/globalStorage/github.copilot-chat/debugCommand:/home/dky/.vscode-server/data/User/globalStorage/github.copilot-chat/copilotCli:/home/dky/.vscode-server/bin/994fd12f8d3a5aa16f17d42c041e5809167e845a/bin/remote-cli:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/lib/wsl/lib:/snap/bin$","tags":["WSL"],"categories":["Linux"]},{"title":"链表的一些技巧","path":"/2026/01/02/链表的一些技巧/","content":"一、先明确：两种循环条件的核心差异 循环条件 遍历范围 核心目标 适用场景 while(cur != NULL) 遍历每一个节点（cur 依次指向所有节点，直到 curNULL） 对每个节点执行操作（查找、取值、统计等） 查找节点、遍历所有节点、统计节点数 while(cur-next) 遍历到倒数第二个节点（cur 指向最后一个节点时，循环终止） 找到「最后一个节点的前驱」或「待操作节点的前驱」 尾插找尾部、删除节点找前驱、插入节点找前驱 简单说： 想「逐个检查所有节点」→ 用 cur != NULL； 想「找某个节点的前一个节点」（比如尾插找最后一个节点、删除找待删节点的前驱）→ 用 cur-next。 四、总结 循环条件的选择依据 ： 想「遍历所有节点，操作当前节点」（查找、统计、打印）→ 用 cur != NULL； 想「找节点的前驱」（尾插、删除、按索引插入）→ 用 cur-next。","tags":["数据结构"],"categories":["数据结构"]},{"title":"配置WSL内存和swap","path":"/2026/01/02/配置WSL内存/","content":"配置WSL内存和swap现象在RK3506B SDK 编译时内存不够（触发 OOM），内核把 cc1plus 杀了。在 WSL2 上尤其常见：默认内存Swap 不够、或者同时开了很多程序。 先确认内存Swapfree -hgrep -iE MemTotal|SwapTotal /proc/meminfo 配置 WSL2 的 memory + swap Windows 侧编辑（没有就新建）： C:\\Users\\dky\\.wslconfig [wsl2]memory=12GBprocessors=6swap=24GBswapFile=C:\\\\Users\\\\dky\\\\AppData\\\\Local\\\\wsl\\\\swap.vhdx Windows CMD： wsl --shutdown 重新进入 WSL，再 free -h 看看是否生效。","tags":["WSL"],"categories":["Linux"]},{"title":"buildroot扫盲","path":"/2026/01/02/系统构建/buildroot扫盲/","content":"Buildroot 用来自动化生成：交叉工具链 + rootfs + 内核镜像 + bootloader（可以只用其中一部分） 引导程序（U-Boot）负责启动时加载内核，内核启动时会挂载根文件系统 Buildroot 是 “整合者”，U-Boot 是 “启动器”，Linux 内核是 “操作系统核心”，BusyBox 是 “用户层基础工具”， 是嵌入式系统的 “精简工具集”（含 ls、cd 等基础命令 + 简化 init 系统），具体关系和各自角色如下： 一、四个组件的核心角色 组件 核心定位 通俗类比（电脑场景） 关键作用 Buildroot 嵌入式系统 “构建工具”（自动化整合器） 电脑组装说明书 + 自动组装工具 自动下载、编译、整合 U-Boot、Linux 内核、BusyBox 及其他软件，生成最终可部署的系统镜像 U-Boot 嵌入式系统 “引导程序”（开机启动器） 电脑 BIOSUEFI 设备通电后先运行，初始化硬件（如内存、SD 卡），再加载并启动 Linux 内核 Linux 内核 嵌入式系统 “操作系统核心”（硬件管理者） 电脑 WindowsmacOS 的内核（如 Windows 内核） 管理硬件资源（CPU、内存、外设）、调度进程、提供系统调用接口（让软件访问硬件） BusyBox 嵌入式系统 “精简工具集”（用户层基础软件） 电脑的 “命令行工具 + 开机启动脚本”（如 cmd.exe + 启动项） 1. 提供数百个基础命令（ls、cd、mkdir、sh 等）；2. 提供简化的 init 系统（启动用户层服务）；3. 体积极小（仅几百 KB），适配嵌入式设备的存储 内存限制 二、四者的协同工作流程（设备启动到运行） 设备通电：首先运行 U-Boot（引导程序），初始化硬件并找到 Linux 内核镜像； 启动内核：U-Boot 加载 Linux 内核到内存并启动，内核接管硬件管理； 挂载根文件系统：内核启动后，挂载 Buildroot 生成的根文件系统（含 BusyBox）； 启动用户层：内核运行根文件系统中的 BusyBox init 程序（PID1），init 启动必要服务并提供命令行终端； 用户操作：用户通过 BusyBox 提供的命令（如 ls、cd）操作设备，或运行其他应用程序。 三、关键关系 BusyBox 与 Linux 内核： 内核是 “底层硬件管理者”，BusyBox 是 “上层工具使用者”——BusyBox 的命令需要通过内核提供的系统调用接口才能访问硬件（如 ls 命令通过内核读取存储设备）； 两者独立开发：内核负责 “底层管理”，BusyBox 负责 “上层工具”，无包含关系。 BusyBox 与 Buildroot： Buildroot 是 “构建工具”，BusyBox 是 Buildroot 的 “默认核心组件”——Buildroot 会自动下载、编译 BusyBox，并将其安装到根文件系统中； 可替换：Buildroot 支持用其他工具集（如 util-linux）替代 BusyBox，但 BusyBox 因体积小、功能全，是嵌入式场景的首选。 BusyBox 与 U-Boot： 无直接依赖：U-Boot 负责 “启动内核”，BusyBox 负责 “内核启动后的用户层”； 均为独立组件：U-Boot 是启动阶段的软件，BusyBox 是运行阶段的软件，互不包含。 四、核心总结 缺少 U-Boot：设备无法启动 Linux 内核； 缺少 Linux 内核：无硬件管理核心，无法运行任何用户层软件； 缺少 BusyBox：根文件系统无基础命令和 init 系统，内核启动后无法提供可操作的终端（设备卡死在 “内核启动完成” 阶段）； 缺少 Buildroot：需要手动下载、编译、整合 U-Boot、内核、BusyBox，过程复杂且易出错。 问题：BusyBox提供ls、cd、mkdir、sh等数百个基础命令，而非linux内核提供的 核心结论：ls、cd、mkdir 等不是 Linux 内核直接提供的，而是 BusyBox（或其他用户层工具集）提供的程序 —— 内核仅提供底层 “能力接口”（系统调用），BusyBox 把这些接口封装成用户能直接使用的命令，两者是 “底层能力” 和 “上层工具” 的关系，具体拆解如下： 一、关键区分：内核的 “系统调用” vs 命令的 “用户层程序” 维度 Linux 内核（底层） BusyBox（上层） 提供的东西 系统调用（如 open() read() mkdir()） 可执行命令（如 ls cd mkdir sh） 本质 硬件 资源管理的 “底层接口”，只能被程序调用 封装了系统调用的 “用户层工具”，可直接被用户执行 访问方式 无法直接通过终端输入，需通过编程调用（如 C 语言） 终端直接输入命令即可执行 举例 要读取目录内容，内核提供 getdents() 系统调用 ls 命令调用 getdents() 系统调用，把返回的目录信息格式化后显示给用户 二、具体命令执行流程（以 ls 为例，帮你直观理解） 你在终端输入 ls 并回车； 终端 shell（BusyBox 提供的 sh 命令）解析命令，找到 /bin/ls 可执行文件（BusyBox 编译后生成的程序）； ls 程序启动，调用内核提供的 getdents() 系统调用，请求读取当前目录的文件列表； 内核执行 getdents() 逻辑，访问存储设备，获取目录数据后返回给 ls 程序； ls 程序把内核返回的原始数据（如文件名、权限、大小）格式化（排版、上色），输出到终端； 你看到的 “目录列表”，就是 ls 命令处理后的结果 —— 内核只提供了 “读取目录” 的能力，没有提供 “显示目录列表” 的命令。 三、反例验证：没有 BusyBox，内核再强也没有 ls 命令如果你的根文件系统中没有 BusyBox（或其他工具集），即使内核启动正常，也会出现： 终端输入 ls，提示 “command not found”（没有这个命令）； 内核启动后因找不到 init 程序（BusyBox 提供），直接报 Kernel panic（内核恐慌）； 本质：内核有 “管理目录、文件” 的能力，但没有 “让用户操作这些能力” 的工具 ——BusyBox 就是补全这个缺口的 “工具集”。 问题：编译Linux 源代码目录生成image镜像文件和buildroot生成images有什么区别 Linux 源码生成的是 “纯内核镜像”，Buildroot 生成的是 “包含内核 + 根文件系统 + 引导程序的完整嵌入式系统镜像套件”，后者是前者的 “整合与补充”，具体区别如下： 一、关键区别：Linux 源码的 image vs Buildroot 的 images/ 维度 Linux 源代码生成的 image（如 vmlinux zImage） Buildroot 的 images/ 目录产物 本质 仅 Linux 内核本身（操作系统核心，负责硬件管理、进程调度） 完整嵌入式系统的 “部署套件”，包含 3 类核心文件：1. 内核镜像（可复用 Linux 源码生成的，或 Buildroot 重新编译的）；2. 根文件系统镜像（含 busybox、应用程序、配置文件等用户层内容）；3. 引导程序镜像（如 U-Boot，负责启动内核） 用途 仅作为操作系统内核，无法单独运行（缺用户层程序、硬件驱动适配） 直接部署到嵌入式设备，可独立启动并运行完整系统（内核 + 用户层 + 引导） 生成逻辑 基于内核配置（defconfig）编译，仅处理内核源码 1. 可选 “复用外部内核镜像” 或 “内部编译内核”；2. 编译 整合用户层软件（如 busybox、库、应用）；3. 生成引导程序；4. 打包为设备可识别的镜像格式 独立性 ❌ 无法单独启动：启动后会因缺根文件系统（binsh、驱动配置等）挂起 ✅ 可独立启动：包含嵌入式系统运行所需的 Buildroot和Linux源代码关系： Buildroot 本身不包含 Linux 源代码—— 它是一个 “构建工具”，而非 “包含所有组件源码的集成包”，Linux 源码需要单独下载（由 Buildroot 自动处理，或你手动提供），具体逻辑如下： 一、Buildroot 处理 Linux 源码的两种方式（均不自带）1. 自动下载并编译（默认推荐，新手首选）当你在 Buildroot 的 make menuconfig 中开启 “Linux 内核” 选项（BR2_LINUX_KERNEL=y），并选择内核版本（如 BR2_LINUX_KERNEL_VERSION=5.10.100）后： 执行 make 时，Buildroot 会自动从内核官网（或指定镜像源）下载对应版本的 Linux 源码压缩包； 解压到 output/build/linux-版本/ 目录，按你配置的内核配置文件（defconfig 或自定义 config）编译； 最终生成 zImage（或 vmlinux），存入 output/images/ 目录。 2. 复用你手动编译的内核镜像（适合已有内核源码的场景）若你已在单独的 Linux 源码目录编译好 zImage，可让 Buildroot 直接复用，无需重复下载编译： 在 make menuconfig 中开启 BR2_LINUX_KERNEL=y； 选择 BR2_LINUX_KERNEL_USE_CUSTOM_CONFIG（使用自定义内核配置），或 BR2_LINUX_KERNEL_USE_EXTERNAL（直接指定外部内核镜像路径）； 配置 BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE（指向你的内核 .config 文件），或 BR2_LINUX_KERNEL_EXTERNAL_PATH（指向你编译好的 zImage 路径）； 执行 make 时，Buildroot 会跳过下载和编译步骤，直接将你的 zImage 复制到 output/images/ 目录，与根文件系统、引导程序整合。","tags":["uboot","Buildroot"],"categories":["UBOOT"]},{"title":"嵌入式系统架构","path":"/2026/01/02/系统构建/嵌入式系统架构/","content":"嵌入式系统架构什么是Linux系统","tags":["uboot","Buildroot"],"categories":["UBOOT"]},{"path":"/2025/12/28/关于二级指针可以看作指针数组的理解/","content":"关于二级指针可以看作指针数组的理解定义一个变量：struct Node** b，在使用的时候尝尝会把b当成一个指针数组，即b是一个数组，数组中的每一项都是一个struct Node*的指针变量。大概是这样： b----[ Node* ] [ Node* ] [ Node* ]... 然而这种操作只在某些特殊情况下才是正确的： 只有当它指向一段连续存放的 struct Node* 类型一级指针时，其内存布局与指针数组（struct Node* arr[]）完全兼容，且语法操作高度一致，才可以用 “指针数组的使用方式” 来操作 b，因此struct Node** b本质上不是指针数组。 从内存布局、语法操作两个核心维度拆解，再补充关键区别，彻底讲清楚这个问题： 一、核心原因 1：内存布局完全兼容指针数组（struct Node* arr[N]）的内存布局是「连续排列的多个 struct Node* 一级指针」，每个元素的地址相邻（间隔为 sizeof(struct Node*)，即一个指针的大小）。 当我们让二级指针 struct Node** b 指向这片连续内存的首元素地址时，b 的指向逻辑和指针数组名（退化后）完全一致： b 本身存储的是「第一个 struct Node* 一级指针」的地址（对应指针数组 arr[0] 的地址）； b+1 会通过指针偏移（偏移量为 sizeof(struct Node*)），指向「第二个 struct Node* 一级指针」的地址（对应指针数组 arr[1] 的地址）； b+i 会指向「第 i+1 个 struct Node* 一级指针」的地址（对应指针数组 arr[i] 的地址）。 这种连续的内存布局，是我们能把 b 当作指针数组使用的根本前提。 二、核心原因 2：语法操作高度一致对于指针数组 struct Node* arr[N]，我们常用 arr[i] 访问第 i 个一级指针；对于二级指针 struct Node** b，b[i] 等价于 *(b+i)（指针偏移 + 解引用），其语法效果和 arr[i] 完全一致。 我们用代码示例直观验证（结合结构体）： #include stdio.h#include stdlib.h// 定义结构体struct Node int val;;int main() // 1. 创建3个Node节点（普通结构体变量） struct Node n1 = 10, n2 = 20, n3 = 30; // 2. 定义指针数组（静态，内存连续） struct Node* arr[3] = n1, n2, n3; // 3. 二级指针b指向指针数组arr的首元素（等价于b = arr[0]） struct Node** b = arr; // ********* 语法操作一致性验证 ********* // 方式1：用指针数组语法访问arr printf(指针数组arr[0]指向的值：%d , arr[0]-val); printf(指针数组arr[1]指向的值：%d , arr[1]-val); printf(指针数组arr[2]指向的值：%d , arr[2]-val); // 方式2：用“指针数组语法”访问二级指针b printf(二级指针b[0]指向的值：%d , b[0]-val); // 等价于 *(b+0)-val printf(二级指针b[1]指向的值：%d , b[1]-val); // 等价于 *(b+1)-val printf(二级指针b[2]指向的值：%d , b[2]-val); // 等价于 *(b+2)-val return 0; 从代码运行结果可以看到： 访问指针数组用 arr[i]-val； 访问二级指针b用b[i]-val； 二者语法完全一致，功能完全相同，这就让我们在使用时，感觉b就是一个指针数组。 三、补充场景：动态分配的 “指针数组”（更易混淆）在实际开发中，我们常通过动态分配内存，让 struct Node** b 指向一片连续的 struct Node* 内存，此时 b 更像一个 “动态指针数组”，示例如下： #include stdio.h#include stdlib.hstruct Node int val;;int main() int n = 3; // 数组长度 // 动态分配：n个struct Node*类型的连续内存，b指向这片内存的首地址 struct Node** b = (struct Node**)malloc(n * sizeof(struct Node*)); if (b == NULL) perror(malloc failed); return 1; // 给每个“数组元素”（b[i]）分配Node节点并初始化 for (int i = 0; i n; i++) b[i] = (struct Node*)malloc(sizeof(struct Node)); b[i]-val = (i+1) * 10; // 初始化值：10、20、30 // 用指针数组语法遍历b for (int i = 0; i n; i++) printf(b[%d]指向的值：%d , i, b[i]-val); // 释放内存（先释放节点，再释放指针数组） for (int i = 0; i n; i++) free(b[i]); b[i] = NULL; free(b); b = NULL; return 0; 这个场景中： b 本质还是 struct Node** 二级指针； 但它指向的是动态分配的、连续的 struct Node* 内存，和静态指针数组 arr 的内存布局完全一致； 我们用 b[i] 初始化 访问的方式，和操作普通指针数组毫无区别，因此更会觉得 b 就是指针数组。 四、关键澄清：b 与真正的指针数组的核心区别尽管使用方式一致，但 struct Node** b（二级指针）和 struct Node* arr[N]（指针数组）有一个不可忽视的核心区别： b 是单个指针变量：大小固定为 sizeof(struct Node**)（通常 48 字节），它只存储 “连续一级指针内存” 的首地址，不包含数组长度信息，需要我们手动记录（比如上面代码中的 n）； arr 是数组：大小为 n * sizeof(struct Node*)（n 是数组长度），sizeof(arr) 可以直接获取整个数组的内存大小，从而计算出数组长度（sizeof(arr)/sizeof(arr[0])）。 示例验证区别： #include stdio.hstruct Node int val;;int main() struct Node n1, n2, n3; struct Node* arr[3] = n1, n2, n3; struct Node** b = arr; printf(sizeof(arr) = %zd , sizeof(arr)); // 3*8=24（64位系统，指针大小8字节） printf(sizeof(b) = %zd , sizeof(b)); // 8（单个二级指针的大小） // 指针数组可以通过sizeof计算长度，二级指针不行 int arr_len = sizeof(arr) / sizeof(arr[0]); printf(指针数组arr的长度：%d , arr_len); // 3 return 0; 总结 struct Node** b 本质是二级指针，不是指针数组； 当 b 指向连续存放的 struct Node\\* 一级指针时，其内存布局与指针数组兼容，且 b[i] 的语法操作与指针数组完全一致，因此可以把 b 当作指针数组来使用； 核心区别：b 无数组长度信息（大小固定为单个指针大小），真正的指针数组可通过 sizeof 获取长度（大小由元素个数决定）。"},{"path":"/2025/12/20/win11 + wsl + vscode + cpptools调试/","content":"win11 + wsl + vscode + cpptools调试安装cc++插件为了使用调试功能，重新安装了cc++拓展插件，cpptools 只当“调试器前端”用，代码提示跳转诊断仍然全部交给 clangd，同时又为了不影响clang等拓展的功能，因此需要禁用一些功能 windows 在 窗口里按 Ctrl+Shift+P 输入并选择：Preferences: Open User Settings (JSON) 确认打开的路径是：/C:/Users/dky/AppData/Roaming/Code/User/settings.json 把这三行加进去并保存： C_Cpp.intelliSenseEngine: disabled,C_Cpp.autocomplete: disabled,C_Cpp.errorSquiggles: disabled 这是“windows端全局设置”。 wsl 在 WSL 窗口里按 Ctrl+Shift+P 输入并选择：Preferences: Open Remote Settings (JSON) 或者直接打开：code ~/.vscode-server/data/Machine/settings.json 确认打开的路径是：/home/dky/.vscode-server/data/Machine/settings.json 把这三行加进去并保存： C_Cpp.intelliSenseEngine: disabled,C_Cpp.autocomplete: disabled,C_Cpp.errorSquiggles: disabled 这就是 Remote Settings ,“WSL 端全局设置”。 项目工作区配置.vscode配置 .vscodetasks.json任务配置 version: 2.0.0, tasks: [ label: build-gtk-debug, type: shell, command: make, args: [TARGET=gtk, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc], group: kind: build, isDefault: true , label: build-cli-debug, type: shell, command: make, args: [TARGET=cli, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc] , label: build-sdl-debug, type: shell, command: make, args: [TARGET=sdl, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc] , label: build-gl-debug, type: shell, command: make, args: [TARGET=gl, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc] ] 按ctrl shift b运行该task.vscodelaunch.json调试配置 version: 2.0.0, tasks: [ label: build-gtk-debug, type: shell, command: make, args: [TARGET=gtk, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc], group: kind: build, isDefault: true , label: build-cli-debug, type: shell, command: make, args: [TARGET=cli, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc] , label: build-sdl-debug, type: shell, command: make, args: [TARGET=sdl, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc] , label: build-gl-debug, type: shell, command: make, args: [TARGET=gl, DBG=1, -j], options: cwd: $workspaceFolder , problemMatcher: [$gcc] ] fn f5执行该launch 如果想每次调试都重新编译，把command改成bash一条命令： command: bash,args: [-lc, make clean make TARGET=gtk DBG=1 -j] 保险起见，在工作区也彻底禁用cpptools的非调试功能，避免和clangd冲突 .vscodesettings.json配置 // cpptools：关闭 IntelliSense/补全/红波浪/自动分析 C_Cpp.intelliSenseEngine: disabled, C_Cpp.autocomplete: disabled, C_Cpp.errorSquiggles: disabled, C_Cpp.codeAnalysis.runAutomatically: false, C_Cpp.workspaceParsingPriority: low, // 仍然用 clangd 做 C 语言格式化/提示（你已经在用的话可保留） [c]: editor.defaultFormatter: llvm-vs-code-extensions.vscode-clangd , [cpp]: editor.defaultFormatter: llvm-vs-code-extensions.vscode-clangd makefile配置# gdb 调试选项DBG ?= 0ifeq ($(DBG),1) CFLAGS += -Og -g3endif 调试大致步骤就是： 按ctrl shift b编译项目 vscode打断点 fn f5调试"},{"title":"win11+WSL+vscode+clangd简单配置","path":"/2025/12/12/win11+WSL+vscode+clangd简单配置/","content":"win11+WSL+vscode+clangd简单配置安装wsl 安装ubuntu上一步的默认情况下就会安装ubuntu vscode配置安装clangd sudo apt install -y clangd clang-format ninja-build build-essential 安装bear sudo apt install -y bear 安装vscode 插件，注意安装到wsl中 配置clangd路径，一定要配置，不然找不到。路径可以通过which clangd命令来查找 which clangd/usr/bin/clangd 其实我发现，甚至可以不用安装clangd也行，默认情况下vscode似乎会在服务器的某一个位置下载一个clangd 注意： 设置完之后需要重启 关闭”C_Cpp.intelliSenseEngine”: “Disabled”，或者就不要安装微软的c语言服务插件 验证针对如果是使用make来构造项目，执行： bear -- make 如果是cmake构建的项目，可以参考：clangd 观察是否生成compile_commands.json文件，clangd根据此文件来解析，从而实现代码提示和跳转。 随便打开一个.c.h文件， 选择 查看-输出 并选择clangd，查看是否有输出，如果有输出就表明clangd正在解析代码文件了。 如果项目比较大的话，还可以看到左下角有一个clangd:idle正在解析","tags":["wsl","clangd","vscode"],"categories":["UBUNTU"]},{"title":"解决win11+WSL+鼠标光标消失","path":"/2025/12/12/win11+WSL+鼠标光标消失解决/","content":"前沿在wsl中使用sdl等图形库的时候发现只要鼠标一旦移动到SDL界面便会消失，然而鼠标操作依旧可以正常点击，推测光标渲染的问题，导致光标没有显示出来 原因SDL 驱动选择导致（Wayland vs X11Xwayland） WSLg 下 SDL 默认走 X11(Xwayland) 时的“鼠标光标渲染抓取 bug” 解决方法强制走 Wayland export SDL_VIDEODRIVER=wayland","tags":["wsl","wayland"],"categories":["UBUNTU"]},{"title":"dts probe过程","path":"/2025/12/11/dts probe过程/","content":"dts probe过程见图片： 参考来源：","tags":["linux","platform","dts"],"categories":["驱动"]},{"title":"SDL源码编译安装","path":"/2025/11/19/SDL编译安装/","content":"SDL源码编译安装最清晰、最稳妥、一步不差 的“从源码编译安装 SDL（SDL2）”教程，包括： SDL 官方源码下载 ./configure cmake 两种编译方式 编译常见报错 系统库安装位置 CMake + Makefile 如何引用你编译好的 SDL2 SDL_image SDL_ttf SDL_mixer 的源码安装方式 如何卸载更新你自己编译的 SDL2 可完美用于 Linux 桌面嵌入式树莓派等。 🔵 一、下载 SDL2 源码（官方）官网： https://github.com/libsdl-org/SDL/releases 选择最新版本（例如 SDL2-2.30.x）： wget https://github.com/libsdl-org/SDL/releases/download/release-2.30.6/SDL2-2.30.6.tar.gztar xf SDL2-2.30.6.tar.gzcd SDL2-2.30.6 🔵 二、方式 1：传统 Autotools 编译（最通用）进入源码后： ./configure --prefix=/usr/localmake -j$(nproc)sudo make install 完成后库会安装到： /usr/local/lib/libSDL2.so/usr/local/include/SDL2/ 更新库缓存： sudo ldconfig 检测是否成功： pkg-config --modversion sdl2 看到版本号就是成功。 🔵 三、方式 2：使用 CMake 编译（新版本推荐，已实测）SDL2 新版默认支持 CMake： mkdir build cd buildcmake .. -DCMAKE_INSTALL_PREFIX=/usr/localmake -j$(nproc)sudo make installsudo ldconfig CMake 的版本更干净，也方便 IDE 使用。 🔵 四、如何使用你从源码安装的 SDL2？方式 1：sdl2-config目前系统已经有了： /usr/local/bin/sdl2-config 编译程序： gcc main.c `sdl2-config --cflags --libs` 方式 2：pkg-config（CMake autotools 常用）pkg-config --cflags --libs sdl2 方式 3：CMakeLists.txtfind_package(SDL2 REQUIRED)include_directories($SDL2_INCLUDE_DIRS)target_link_libraries(your_target $SDL2_LIBRARIES) 方式 4：MakefileCFLAGS += `sdl2-config --cflags`LDFLAGS += `sdl2-config --libs`all:\tgcc main.c -o app $(CFLAGS) $(LDFLAGS) 🔵 五、SDL_image SDL_ttf SDL_mixer 源码安装（和 SDL 方法一样）1）SDL_imagewget https://github.com/libsdl-org/SDL_image/releases/download/release-2.8.2/SDL2_image-2.8.2.tar.gztar xf SDL2_image-2.8.2.tar.gzcd SDL2_image-2.8.2./configure --prefix=/usr/localmake -j$(nproc)sudo make installsudo ldconfig 2）SDL_ttf（如果需要文字渲染）./configure --prefix=/usr/localmake -j$(nproc)sudo make installsudo ldconfig 3）SDL_mixer（音频支持）同理。 🔵 六、常见编译失败原因 解决 错误 原因 解决 找不到 X11 缺少依赖 sudo apt install libx11-dev libxext-dev libxrandr-dev libxrender-dev libxfixes-dev 找不到 ALSA 未安装音频库 sudo apt install libasound2-dev 找不到 wayland 你选择了支持 wayland sudo apt install libwayland-dev wayland-protocols configure 报错找不到 pkg-config 系统缺少 pkg-config sudo apt install pkg-config 链接时报 undefined reference to SDL_* 未使用 sdl2-config 加上 sdl2-config --libs 最完整依赖： sudo apt install build-essential pkg-config \\ libasound2-dev libpulse-dev \\ libx11-dev libxext-dev libxrandr-dev libxrender-dev libxfixes-dev \\ libxcursor-dev libxi-dev libxinerama-dev \\ libwayland-dev wayland-protocols \\ libdbus-1-dev libudev-dev 装完后 SDL 基本不会报错了。 🔵 七、如何卸载从源码安装的 SDL2因为是 make install 安装的，可以执行： sudo make uninstall 如果目录已经删掉，可以直接清理 /usr/local： /usr/local/lib/libSDL2*/usr/local/include/SDL2/usr/local/bin/sdl2-config","tags":["linux","sdl"],"categories":["嵌入式"]},{"title":"解决vmware虚拟机占用磁盘空间过大的问题","path":"/2025/11/06/解决vmware虚拟机占用磁盘空间过大的问题/","content":"解决vmware虚拟机占用磁盘空间过大的问题起因早都想解决vmware磁盘占用过大的问题，尝试了网上的几种方法没有任何优化。最近脑磁盘又开始飘红，忍无可忍，无需再忍，这次下定决心优化一下这个问题。 先查看一下优化前Ubuntu 18.04.2 (64bit).vmdk占用内存大小，竟然占用220g，实在是夸张，感觉像是装了一个3a大作一样。 不止于此，此前为了防止一个虚拟机占用过大的空间，我在做每个项目的时候都会单独复制一份虚拟机，用完就删除，后面发现随便复制一个虚拟机，都能从10g轻松扩充到60多g。 原因虚拟机的磁盘是 “稀疏（growablesparse）” 类型，VMware 一开始只创建一个小文件，但随着系统运行、文件写入，它会按需自动膨胀，直到达到创建时的最大值。 为什么我已经在虚拟机中把下载的文件删除了，而vmdk占用空间并没有减少？ 即便你在 Ubuntu 里删除了很多文件，这些空闲块没有被“归零”，对宿主机来说仍然占用空间。 因此解决方法就是将这些空闲块清零，然后通过VMware shrink 工具将这些清零块回收，从而达到释放磁盘空间的目的 解决方法1) 在ubuntu虚拟机中将空闲块清零碎片整理 #打开Ubuntu虚拟机sudo apt-get autoremovesudo apt-get cleansudo dd if=/dev/zero of=/zero.fill bs=1M status=progress || truesudo rm /zero.fill#清除回收站文件与缓存文件sudo rm -rf .local/share/Trash/*sudo rm -rf .cache/*sudo sudo dd if=/dev/zero of=/tmpfile#将碎片空间填充上0，结束的时候会提示磁盘空间不足，忽略即可sudo rm -rf /tmpfile #删除第二步的填充，如果用df -h 会发现可用的虚拟空间增加许多，但是实际的磁盘空间没有缩减 2) 在windows下使用shrink回收清零块碎片回收 ./vmware-vdiskmanager.exe -k H:\\dky-ubuntu18.04\\ubuntu18.04_vscode_imx6ull_pro\\Ubuntu 18.04.2 (64bit).vmdk 结果 经过漫长的等待之后，发现从原本的220g减少到201g。 还是不够理想。 终极大法重新生成磁盘文件结构，而不仅是 shrinkD:\\LinuxLearningInstall\\VMware\\vmware-vdiskmanager.exe ` -r H:\\dky-ubuntu18.04\\ubuntu18.04_vscode_imx6ull_pro\\Ubuntu 18.04.2 (64bit).vmdk ` -t 1 H:\\dky-ubuntu18.04\\ubuntu18.04_vscode_imx6ull_pro\\Ubuntu-compact.vmdk -r：从旧盘读取。 -t 1：创建 split growable（2 GB 分片）稀疏磁盘，体积会根据实际数据动态增长。 新生成的 Ubuntu-compact.vmdk 会自动剔除所有无效块 预期效果最终为几十g，取决于实际ubuntu使用了多少空间。 如果上述操作没有明显效果，建议在此之前再清零一次 sudo apt-get cleansudo rm -rf /tmp/*sudo journalctl --vacuum-time=1dsudo dd if=/dev/zero of=/zero.fill bs=1M status=progress || truesyncsudo rm /zero.fillsudo poweroff 上述操作原理VMware 的 .vmdk 就相当于一块“虚拟硬盘”。 vmware-vdiskmanager -k：只在文件层面做压缩，不会动里面的数据。 vmware-vdiskmanager -r ... -t ...：相当于“克隆硬盘”，把原磁盘里所有有效的数据块（操作系统、配置文件、用户文件等）完整复制到一个新磁盘文件中。 它不改动 Ubuntu 内部文件系统，只是重建磁盘结构、去掉空白区。 所以： Ubuntu 内的 /home/你的用户名/ 目录下的文件、桌面、配置、下载、VS Code 工作区、ROS、IMX6ULL 工程文件等都会完好无损； Ubuntu 的用户账号、密码、包管理配置也都保留； 克隆完成后虚拟机启动起来，看起来和原来一模一样 注意 需要把快照删除 需要预留两倍磁盘空间 以上操作耗时很久","tags":["vmvare"],"categories":["Linux"]},{"title":"测试一些特性","path":"/2025/11/03/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 1文言文出师表先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。后出师表先帝深虑汉、贼不两立，王业不偏安，故托臣以讨贼也。以先帝之明，量臣之才，固知臣伐贼，才弱敌强也。然不伐贼，王业亦亡。惟坐而待亡，孰与伐之？是故托臣而弗疑也。诸葛亮三国节选 2 横向铺满的图片图片由 xaoxuu 拍摄于一个普通的阳光明媚的下午 竖图 支持 Fancybox 插件点击放大图片由 xaoxuu 拍摄于一个普通的阳光明媚的下午 link卡片不带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 带摘要的样式： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ button按钮探索 目标管理 O1 2077年的小目标：完成 Volantis 6.0 并发布上线 来自2077年末的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0% copy复制行 $ 音频 Your browser does not support the audio tag. 视频 Your browser does not support the video tag. Your browser does not support the video tag. 导航栏文章项目留言GitHub frame 这是 高斯模糊 标签 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 静态时间线2021 年 2 月 16 日主要部分功能已经开发的差不多了。2021 年 2 月 11 日今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。 动态时间线 静态 + 动态这条内容为静态数据这条内容为静态数据，静态数据在 deploy 时就已经确定了。 数据筛选 friends 友链 md 渲染外部 markdown 文件 ghcard 卡片 toc 文档目录树% toc wiki:xxx [open:true] [display:mobile] title % box 盒子容器[title] [color:color] [child:codeblocktabs] … 彩色代码块 推荐的写法func test() // ... 不推荐的写法func test() - () // ...折叠代码 默认打开的代码折叠框 代码块 tabs 分栏容器图片代码块表格let x = 123print(hello world) a b c a1 b1 c1 a2 b2 c2 banner 横幅容器用于独立页面顶部 随记收藏随记 用于用户个人资料页 某某这是个人简介 用作文章摘要卡片博客进阶：自动化部署本文讲了如何利用脚本和 GitHub Actions 简化博客搭建和部署流程，提高效率。 gallery 图库 @tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen swiper 轮播容器"},{"title":"恋爱小目标进度","path":"/2025/11/03/恋爱小目标/","content":"🩷 当前恋爱进度：87% ｜ 阶段：异地 → 登门中 ｜ 情感指数：🌕🌕🌕🌕🌗 O1 恋爱小目标：实现从“异地长跑”到“登门造访”的进阶成就 ❤️ 复盘：五年长跑，情比时间更久；登门造访，爱有了温度与方向 恋爱小目标：实现从“异地长跑”到“登门造访”的进阶成就 ❤️复盘：五年长跑，情比时间更久；登门造访，爱有了温度与方向 正常 65% KR1 庆祝五周年纪念日 🎂 共同完成五周年仪式感活动（完成 ✅） 回顾异地时光的点滴，写入恋爱纪念册（完成 ✅） 拍摄情侣纪念照 📸（完成 ✅）已完成 已完成 100% KR2 完成“登门造访”阶段任务 🏡 小提示建议已完成登门造访的准备工作 下一步计划：完成双方家庭初步见面；节日共同拜访、参与家庭聚餐、讨论未来生活规划 正常 75% KR3 维持高质量沟通与浪漫频率 💬 每周一次“手机约会”每月一次深度谈心发生分歧时冷静沟通，不带情绪坚持互相夸奖至少一次/天偶有波动，但心意稳定 风险 70% KR4 升级“长期伴侣计划” 💍 小提示建议讨论未来规划，包括生活与工作平衡 下一步可共同制定三年内的成长目标（旅行、储蓄、居住等） 明确三年目标清单（旅行×2、储蓄目标、居住城市）约定每季度复盘与调整机制设立“共同账户/共同预算”并跟踪支出进展顺利：75%（按计划推进） 正常 75% KR5 共同成长计划 🌱 一起学习新技能（烹饪、摄影或运动） 策划一次“意义型旅行”（探索彼此新的一面） 共建共享的“未来清单”已初步成型爱是最小单位的共产主义，我们拥有革命般的友谊 正常 50% KR6 长期愿景 💞 一起打造理想生活空间实现双方家庭的深度融合在第十年依然保留第一次相见的悸动坚持“彼此是归处”的信念 未完成 20% 🙌一起努力，一起加油🍭一张背影镇楼 图片由 dky 在北京拍摄于端午节的一个晴朗的夜晚 一些照片合集 看完了吗？来一个感觉咋样？ 请问dky是最好的 npy 吗？ 0 0","tags":["旅行"],"categories":["杂记"]},{"title":"一年一度银杏大道","path":"/2025/11/03/杂记/一年一度银杏大道/","content":"🍁银杏果臭了俩月，终于等来金黄的银杏大道。秋天的浪漫：一半是银杏叶的金黄，去年的一半是我赶开题，今年的一半是投简历的慌张，美景仅供路过瞻仰😒 😄早上阳光洒在12斋楼下的这几棵银杏树上，也很好看，也有一点治愈🎶 预计接下来的两周银杏大道将会是人山人海😎 好困😪~","tags":["银杏大道"],"categories":["杂记"]},{"title":"编译Buildroot_2020.02时遇到IndexError:list index out of range问题解决","path":"/2025/11/01/编译Buildroot_2020.02时遇到IndexErrorlist index out of range问题解决/","content":"编译Buildroot_2020.02时遇到IndexError:list index out of range问题解决具体报错File /home/book/Desktop/workspace_reload_linux_os/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/lib/python3.8/site-packages/mesonbuild/dependencies/base.py, line 1204, in _get_cmake_info cmake_root: temp_parser.get_cmake_var(MESON_CMAKE_ROOT)[0], IndexError: list index out of range package/pkg-generic.mk:254: recipe for target /home/book/Desktop/workspace_reload_linux_os/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/build/host-libglib2-2.62.5/.stamp_configured failed make[1]: [/home/book/Desktop/workspace_reload_linux_os/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/build/host-libglib2-2.62.5/.stamp_configured] Error 2 Makefile:84: recipe for target _all failed make: [_all] Error 2 原因Meson 与 CMake版本来源不匹配，导致Meson 在配置host-libglib2时读取 CMake 信息失败。 查看本地cmake版本为3.25而构建这个build root所需版本为3.15。 解决方法1) 强制使用 Buildroot 自带的 host 工具（避免系统 cmakemeson）在 Buildroot 顶层目录执行： export PATH=$(pwd)/output/host/bin:$PATHexport LC_ALL=C 设置PATH优先使用 Buildroot 自己编译的工具（如 cmake、meson、ninja、pkgconf 等），而不是系统里 /usr/bin/ 的版本，避免版本不兼容的系统工具干扰 Buildroot 的编译 LC_ALL是为了避免中文编码问题 先确保这些工具存在可用： output/host/bin/cmake --version || trueoutput/host/bin/meson --version || trueoutput/host/bin/ninja --version || true 如果缺少，就让 Buildroot 构建它们： make host-cmake host-ninja host-meson host-pkgconf 可能会疑惑，明明在我的makefile中并没有host-cmake host-ninja host-meson host-pkgconf这些目标啊，为什么可以make生成呢？ 之所以可以这样做是因为在当前makefile中已经包含package下的子makefile文件，代码如下： include $(sort $(wildcard package/*/*.mk)) 而对应的子makefile，如Buildroot_2020.02.x/package/cmake/cmake.mk中会通过$(eval $(cmake-package))等命令去构造host-cmake等编译目标。 2) 清理失败的包后重建make host-libglib2-dircleanmake all -j4 3) 构建过程中保持 PATH 干净构建全程都保持： export PATH=$(pwd)/output/host/bin:$PATHexport LC_ALL=C 避免系统的 /usr/bin/cmake 抢在前面被调用。","tags":["linux","Cmake","uboot"],"categories":["UBOOT"]},{"title":"树莓派4B交叉编译更新Linux内核","path":"/2025/09/02/树莓派4B交叉编译更新Linux内核/","content":"树莓派4B交叉编译更新Linux内核参考：https://www.raspberrypi.com/documentation/computers/linux_kernel.html#kernel 以下基本全文复制官方教程。 原本树莓派4b运行的就是ubuntu 24.04,通过uname -m得到aarch64架构。因此选择64位选项 下载内核源码下载最新树莓派内核的源代码： git clone --depth=1 https://github.com/raspberrypi/linux 说明：--depth=1 表示 只下载最新的一层提交记录（commit） 本地构建内核安装依赖项安装构建依赖项： sudo apt install bc bison flex libssl-dev make libc6-dev libncurses5-dev 工具说明 bc bison flex libssl-dev make 是要安装的具体软件包，各自功能如下： bc：一款支持高精度计算的命令行计算器，常用于脚本中进行数学运算。 bison：语法分析器生成器，配合 flex 可用于开发编译器、解释器等需要语法解析的工具。 flex：词法分析器生成器，用于将输入的字符流转换为结构化的 “令牌（token）”。 libssl-dev：OpenSSL 库的开发文件。 make：make构建自动化工具。 安装交叉编译工具链 要安装用于构建 64 位内核的 64 位工具链，请运行以下命令： sudo apt install crossbuild-essential-arm64 要安装用于构建 32 位内核的 32 位工具链，请运行以下命令： sudo apt install crossbuild-essential-armhf 配置内核对于64位的树莓派4b来说，需要进行如下配置： cd linuxKERNEL=kernel8make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcm2711_defconfig 编译内核 运行以下命令构建 64 位内核： make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image modules dtbs 运行以下命令构建 32 位内核： make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs 安装内核确认启动介质将SD卡插入PC，执行lsblk命令，查看是否有sdb等信息。在我的电脑上是sdd sdd 8:48 1 29.7G 0 disk ├─sdd1 8:49 1 512M 0 part /media/book/system-boot └─sdd2 8:50 1 29.2G 0 part /media/book/writable /media/book/system-boot 对应 Raspberry Pi 启动分区； /media/book/writable 对应根文件系统 可以设置环境变量，方便后续操作 export ARCH=arm64export CROSS_COMPILE=aarch64-linux-gnu-export BOOT=/media/book/system-bootexport ROOT=/media/book/writable 安装内核模块到根分区sudo env PATH=$PATH make -j$(nproc) \\ ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE \\ INSTALL_MOD_PATH=$ROOT modules_install 这一步会在 /media/book/writable/lib/modules/ 下面生成你新编译的模块目录，例如： /media/book/writable/lib/modules/6.6.32-v8+/ 备份旧内核并复制新内核和设备树到 /system-boot 💡 Ubuntu 的启动分区通常包含 vmlinuz, initrd.img, config.txt, cmdline.txt 等。 我们建议把自己的内核命名为 kernel8.img（Pi 4 的标准命名），并在 config.txt 里指明。 1️⃣ 备份现有启动文件：sudo cp -a $BOOT/kernel8.img $BOOT/kernel8-backup.img 2/dev/null || truesudo cp -a $BOOT/vmlinuz $BOOT/vmlinuz-backup 2/dev/null || true 2️⃣ 复制新编译的内核镜像：sudo cp -a arch/arm64/boot/Image $BOOT/kernel8.img 3️⃣ 复制设备树文件（DTB 和 overlays）：sudo cp -a arch/arm64/boot/dts/broadcom/*.dtb $BOOT/sudo mkdir -p $BOOT/overlayssudo cp -a arch/arm64/boot/dts/overlays/*.dtb* $BOOT/overlays/sudo cp -a arch/arm64/boot/dts/overlays/README $BOOT/overlays/ 2/dev/null || true 确保 config.txt 正确打开 /media/book/system-boot/config.txt，检查或添加： kernel=kernel8.imgarm_64bit=1 如果你用了压缩内核或自定义文件名，必须在这里改成一致的名字。 同步并卸载分区复制完成后一定要卸载，否则数据可能没写入卡： syncsudo umount $BOOTsudo umount $ROOT ⚡ 六、启动验证把这张卡插回树莓派 4B，启动后用串口或 SSH 登录执行： uname -a 如果显示你的新内核版本（例如你设置的 -v8 后缀），说明更新成功 🎉 验证模块是否加载： ls /lib/modules 应该能看到与你新内核版本号对应的目录。","tags":["树莓派","Linux"],"categories":["树莓派"]},{"title":"记录使用ZeroTier实现内网穿透实现远程访问实验室主机","path":"/2025/09/01/记录使用ZeroTier实现内网穿透实现远程访问实验室主机/","content":"记录使用ZeroTier实现内网穿透实现远程访问实验室主机准备官网注册zerotier账号ZeroTier 创建Create A Network，并记下Network ID，后续在ubuntu和windows下都要填入这个ID. 1.windows 下载安装ZeroTier ZeroTier | Download 加入新网络，将Network ID复制进去。 回到网页上，会提示有一个设备加入，网页上点击同意加入。 ipconfig查看是否有以下ip 以太网适配器 ZeroTier One [af415e486f063401]: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::c383:dc68:a959:4636%59 IPv4 地址 . . . . . . . . . . . . : 172.29.51.120 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . : 25.255.255.254 2.Ubuntu 如果没有安装curl，先安装curl sudo apt install curl 如果已经有curl直接执行下面的安装命令 curl -s https://install.zerotier.com | sudo bash 终端命令行输入： sudo zerotier-cli join [虚拟网络地址ID] 命令返回200就是成功了 回到网页上同意Authorize设备的加入。 通过ifconfig查看是否有对应的ip。 此时就已经完成了组网，可以尝试互相ping一下能否ping通。接下来就是ssh远程了，略","tags":["ZeroTier","内网穿透"],"categories":["工具"]},{"title":"SPI时序理解","path":"/2025/08/18/SPI时序理解/","content":"SPI时序理解传输模式时钟极性CPOL和时钟相位CPHA CPOL:表示当SCLK空闲idle的时候，其电平值是高电平1还是低电平0 CPHA：表示的是数据采样是在第几个边沿(edge)，0对应第一个边沿，1对应第二个边沿 CPOL和CPHA两两组合一共有4中模式 CPHA0 表示第一个边沿采样 模式0：对于CPOL0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿； 模式2：对于CPOL1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿； CPHA1表示第二个边沿采样 模式1：对于CPOL0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿； 模式3：对于CPOL1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿； 常用模式0和模式3 传输时序时序图 模式0时序图 需要重点理解两个概念： 上升沿采样：指的是从设备在CLK的上升沿（低电平-高电平跳变）读取MOSI线上的数据，这是从设备的接受动作。此时要求MOSI线上的数据必须已经稳定，不能处于跳变状态，否则从设备会采样到错误值。 上升沿前输出数据：指的是主设备在CLK上升沿来之前，就要把传输的当前数据（如bit1）输出到MOSI线上，目的是给数据留出稳定时间，确保上升沿采样时数据已经处于固定电平 以传输bit1为例分析MOSI采样和输出的过程 步骤 1：主设备 “提前输出” 当前位数据（CLK 上升沿前）当主设备选中从设备（SS 信号有效）后，会在 CLK 上升沿到来前的 “空闲阶段”（CPOL0 时 CLK 为低电平），就把 bit1 的电平（如高电平 1）输出到 MOSI 线上，并保持不变（）。文档图 3 验证了这一点：bit1 的输出时刻比 CLK 上升沿早半个时钟周期，此时 CLK 仍处于低电平，尚未进入上升沿阶段。 步骤 2：从设备 “上升沿采样” 当前位数据当 CLK 从低电平跳变为高电平（上升沿）时，从设备检测到这个跳变，立即读取此时 MOSI 线上的稳定数据（即主设备提前输出的 bit1），完成采样动作（、）。此时采样的 “原材料”，正是主设备在上升沿前就准备好的。 步骤 3：主设备 “下降沿更新” 下一位数据采样完成后，CLK 从高电平跳变为低电平（下降沿），主设备会立即将 MOSI 线上的电平更新为下一位数据（如 bit2 的电平），为下一个时钟周期的采样做准备（）。注意：这一步更新的是 “下一位”，而非当前已采样的 bit1—— 当前位数据的采样已在上升沿完成，下降沿的操作不影响已传输的位。 主设备需要提前在CLK上升沿之前将数据（即bit1电平）输出到MOSI线上（即准备好数据，为采样提供稳定数据），不然在上升沿从设备就要采样了。至于采样是否必须在上升沿期间完成还是说在CLK高电平期间仍可以继续采样这个暂时不做深入研究(即采样时间是否为：CLK上升沿+CLK高电平保持期间)。 在CLK高电平结束之后，就来到了CLK的下降沿，这个时候主设备又要将数据（即BIT2）输出到MOSI线上，至于主设备在CLK下降沿开始的时候将数据输出到MOSI线上的时间是否包括CLK低电平的时间（即输出数据的时间是否为：CLK下降沿+CLK低电平保持期间）这个暂时不做研究。 以传输bit1为例分析MISO采样和输出的过程 步骤 1：从设备 “SS 有效后立即输出” 当前位数据（SCLK 上升沿前） 与主设备在 MOSI 线上 “提前半个时钟周期输出” 不同，从设备在 MISO 线上的输出触发条件是 **SS 信号有效 **（主设备拉低 SS 选中从设备）：一旦 SS 有效，从设备会立即将当前要传输的 bit1 电平（如高电平 1）输出到 MISO 线上，并保持稳定，无需等待 SCLK 的上升沿（、）。文档图 4 对此有明确验证：图中 SS 信号变为低电平（有效）后，MISO 线立即输出 bit1（值为 1），此时 SCLK 仍处于空闲低电平状态，为后续主设备采样留出了充足的稳定时间（、）。 步骤 2：主设备 “SCLK 上升沿采样” MISO 线上的数据 当主设备生成的 SCLK 从低电平跳变为高电平（上升沿）时，主设备会检测这个跳变，并立即读取此时 MISO 线上的稳定数据 —— 即从设备在 SS 有效后输出的 bit1，完成 “主设备采样 MISO 数据” 的动作（、）。这一步与 MOSI 线的 “从设备上升沿采样” 逻辑完全同步，均依赖 SCLK 的第一个跳变沿，确保主从设备的收发动作在同一时钟基准下进行（）。 步骤 3：从设备 “SCLK 下降沿更新” MISO 线上的下一位数据 SCLK 上升沿的采样动作完成后，当 SCLK 从高电平跳变为低电平（下降沿）时，从设备会立即将 MISO 线上的电平更新为下一位要传输的数据（如 bit2 的电平），为下一个时钟周期的主设备采样做准备（、）。与 MOSI 线类似，MISO 线的 “更新” 动作仅针对 “下一位数据”，不会影响已在上升沿被主设备采样的当前位（bit1），保证数据传输的连续性和正确性。 区别： MOSI 线（主→从）：主设备输出数据的触发与 SS 无关，仅在 SCLK 上升沿前的空闲阶段输出（）； MISO 线（从→主）：从设备输出数据的触发是 SS 有效，有效后立即输出第一位数据（）。 参考：SPI总线协议介绍.pdf","tags":["linux","SPI","platform"],"categories":["驱动"]},{"title":"wsl bashrc解释","path":"/2025/08/18/bashrc解释/","content":"bashrc文件解释一、.bashrc 文件作用说明.bashrc 是 Bash 非登录 shell 的启动配置文件（比如终端模拟器打开的 shell），每次打开交互式非登录 shell 时会自动执行，用于配置 shell 的环境变量、别名、提示符样式、补全功能等。 二、文件内容逐段解析1. 非交互式 shell 直接退出case $- in *i*) ;; *) return;;esac $- 是 shell 的标志变量，i 表示交互式 shell（用户可以输入命令）。 如果是非交互式 shell（比如脚本执行），直接return，不加载后续配置，提升效率。 2. 历史记录配置HISTCONTROL=ignoreboth # 忽略重复行、以空格开头的行（避免敏感命令入历史）shopt -s histappend # 历史记录追加到文件（而非覆盖）HISTSIZE=1000 # 内存中保存的历史命令数HISTFILESIZE=2000 # 历史文件（~/.bash_history）中保存的命令数 3. 终端与路径匹配配置shopt -s checkwinsize # 每次命令后检查窗口大小，更新LINES/COLUMNS# shopt -s globstar # 注释：** 匹配所有文件/子目录（比如ls **/*.txt递归匹配）[ -x /usr/bin/lesspipe ] eval $(SHELL=/bin/sh lesspipe) # less支持非文本文件预览 4. Debian chroot 环境识别if [ -z $debian_chroot:- ] [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot)fi 若处于 chroot 环境，提示符会显示 chroot 名称，便于区分环境。 5. 彩色提示符配置case $TERM in xterm-color|*-256color) color_prompt=yes;;esac# force_color_prompt=yes # 注释：强制开启彩色提示符（取消注释可强制生效）if [ -n $force_color_prompt ]; then # 检测终端是否支持颜色 if [ -x /usr/bin/tput ] tput setaf 1 /dev/null; then color_prompt=yes else color_prompt= fifi# 彩色提示符格式：用户@主机:工作目录$ if [ $color_prompt = yes ]; then PS1=$debian_chroot:+($debian_chroot)\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ else PS1=$debian_chroot:+($debian_chroot)\\u@\\h:\\w\\$ fiunset color_prompt force_color_prompt 颜色码：01;32m（绿色，加粗）、01;34m（蓝色，加粗）、00m（重置颜色）。 \\u：当前用户，\\h：主机名，\\w：当前工作目录（绝对路径）。 6. Xterm 终端标题设置case $TERM inxterm*|rxvt*) PS1=\\[\\e]0;$debian_chroot:+($debian_chroot)\\u@\\h: \\w\\a\\]$PS1 ;;*) ;;esac 把 Xterm 终端的标题设为用户@主机: 工作目录，便于识别多个终端窗口。 7. lsgrep 颜色支持if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors eval $(dircolors -b ~/.dircolors) || eval $(dircolors -b) alias ls=ls --color=auto # ls带颜色 alias grep=grep --color=auto # grep匹配结果带颜色 alias fgrep=fgrep --color=auto alias egrep=egrep --color=autofi dircolors：设置 ls 的颜色规则（可通过~/.dircolors自定义）。 8. 常用别名与 alert 提示# ls别名alias ll=ls -alF # 详细列表（隐藏文件+格式后缀）alias la=ls -A # 显示所有文件（排除.和..）alias l=ls -CF # 分栏显示+格式后缀# 长命令结束后通知（比如：sleep 10; alert）alias alert=notify-send --urgency=low -i $([ $? = 0 ] echo terminal || echo error) $(history|tail -n1|sed -e \\s/^\\s*[0-9]\\+\\s*//;s/[;|]\\s*alert$//\\) 9. 加载独立的别名文件if [ -f ~/.bash_aliases ]; then . ~/.bash_aliasesfi 推荐将自定义别名放在~/.bash_aliases（而非直接写在.bashrc），便于维护。 10. 启用 Bash 补全功能if ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fifi 启用命令补全（比如输入git 后按 Tab 键补全子命令），提升操作效率。 11. 自定义环境变量（嵌入式开发相关）# ARM交叉编译环境配置export ARCH=arm # 指定架构为ARMexport CROSS_COMPILE=arm-buildroot-linux-gnueabihf- # 交叉编译器前缀# 添加交叉编译器路径到系统PATHexport PATH=$PATH:/home/dky/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin# GTK3的pkg-config搜索路径export PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH 交叉编译：针对 IMX6ULL 开发板的 ARM 架构交叉编译环境，配置后可直接使用arm-buildroot-linux-gnueabihf-gcc等工具。 pkg-config：用于编译依赖 GTK3 的程序时，让 pkg-config 找到 GTK3 的.pc 配置文件。","tags":["linux","bashrc"],"categories":["嵌入式"]},{"title":"fastfetch编译安装","path":"/2025/08/18/fastfetch/","content":"fastfetch编译安装fastfetch介绍NeoFetch是一个命令行系统信息工具，以其简洁美观的输出格式和高度可定制性而闻名。它能够在终端中显示系统logo（通常是ASCII艺术形式）以及系统信息（如操作系统、硬件配置、安装的软件包等）。 然而neofetch似乎已经停止维护了，打开GitHub仓库页面也显示read-only标识。 下载neofetch源码阅读后发现，其实neofetch本质就是一个bash脚本，即\\#!/usr/bin/env bash，因此不需要编译，直接使用自带的make install即可安装到指定目录进行使用。不过也可以通过包管理工具命令来安装sudo apt install neofetch fastfetch是基于C语言实现的，因此如果下载源码源码需要编译来使用，具体编译可以参考：Building · fastfetch-clifastfetch Wiki。或者通过预编译版本：Releases · fastfetch-clifastfetch。实际上如果不是学习者的话，直接通过包管理安装是最方便的。 neofetch和fastfetch源码地址： neofetch fastfetch 由于neofetch比较简单，所以只介绍fastfetch的编译安装。 fastfetch安装通过官方 PPA 安装添加 fastfetch 的 PPA 源 sudo add-apt-repository ppa:zhangsongcui3371/fastfetchsudo apt update 安装 fastfetch sudo apt install fastfetch 通过源码编译安装参考：Building · fastfetch-clifastfetch Wiki 克隆 fastfetch 源码 git clone https://github.com/fastfetch-cli/fastfetch.gitcd fastfetch 编译 mkdir build cd buildcmake ..cmake --build . --target fastfetch 注意：执行cmake ..生成配置文件的时候，可能会提示缺少一些库，但是仍旧会成功生成配置文件，只是缺少的库对应的功能不可以使用，无伤大雅。 编译完成之后在build目录生成fastfetch可执行文件，执行.fastfetch即可运行。如果想全局使用则可以继续执行安装命令 安装 sudo make install 运行 fastfetch 运行结果 ┌──(xxx㉿xxx)-[~]└─$ fastfetch.............. xxx㉿xxx ..,;:ccc,. ------------------- ......;lxO. OS: Kali GNU/Linux Rolling x86_64...............,:ld; Host: Windows Subsystem for Linux - kali-linux (2.6.2.0) .;;;:::;,,.x, Kernel: Linux 6.6.87.2-microsoft-standard-WSL2 ... 0Xxoc:,. ... Uptime: 1 day, 7 hours, 51 mins .... ,ONkc;,;cokOdc,. Packages: 332 (dpkg) . OMo :ddo. Shell: bash 5.2.37 dMc :OO; WM: WSLg 1.0.71 (Wayland) 0M. .:o. Terminal: node ;Wd CPU: AMD Ryzen 9 7945HX (32) @ 2.50 GHz ;XO, GPU: Microsoft Device 008E (3D) ,d0Odlc;,.. Memory: 3.32 GiB / 7.60 GiB (44%) ..,;:cdOOd::,. Swap: 0 B / 2.00 GiB (0%) .:d;.:;. Disk (/): 1.69 GiB / 1006.85 GiB (0%) - ext4 d, . Disk (/mnt/c): 179.78 GiB / 300.00 GiB (60%) - 9p ;l .. Disk (/mnt/d): 570.68 GiB / 651.64 GiB (88%) - 9p .o Local IP (eth0): 172.23.5.96/20 c Battery (Microsoft Hyper-V Virtual Battery): 75% [AC Connected] . Locale: en_US.UTF-8 . 参考NeoFetch正在“凋零”，作者回家种地？FastFetch能否成为系统信息显示的新宠? - 雨月空间站","tags":["linux","工具"],"categories":["linux"]},{"title":"git ssh失败","path":"/2025/08/18/git ssh失败/","content":"git ssh失败git 报错： fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. PS D:\\822lib git remote -vorigin git@github.com:dkyou/822lib.git (fetch)origin git@github.com:dkyou/822lib.git (push)PS D:\\822lib ssh -T git@github.comgit@github.com: Permission denied (publickey). 原因：没有正确配置ssh密钥 解决步骤1. 生成 SSH 密钥对ssh-keygen -t ed25519 -C 你的邮箱@example.com 按提示操作，可以直接按回车使用默认路径和空密码。 PS C:\\Users\\dky\\.ssh ls 目录: C:\\Users\\dky\\.sshMode LastWriteTime Length Name---- ------------- ------ -----a---- 2025/8/22 11:30 278 config-a---- 2025/8/22 11:11 411 id_ed25519 # 新生成-a---- 2025/8/22 11:11 100 id_ed25519.pub # 新生成-a---- 2024/6/25 17:47 2602 id_rsa-a---- 2024/6/25 17:47 571 id_rsa.pub-a---- 2025/4/23 22:13 1205 known_hosts-a---- 2025/3/27 23:01 926 known_hosts.old 2. 启动 ssh-agent 并添加密钥basheval $(ssh-agent -s)ssh-add ~/.ssh/id_ed25519 需要用git bash终端执行 2.1 配置SSH config文件，在~.sshconfig文件中添加： Host github.com AddKeysToAgent yes UseKeychain yes # macOS 专用 IdentityFile ~/.ssh/id_ed25519 3. 获取并添加公钥到 GitHub 查看公钥内容： cat ~/.ssh/id_ed25519.pub 复制输出的内容 登录 GitHub → 点击右上角头像 → Settings → SSH and GPG keys → New SSH key Title 填写标识名称（如 “My PC”），Key type 选择 “Authentication”，Key 中粘贴刚才复制的内容 点击 “Add SSH key” 4. 验证连接ssh -T git@github.com 如果显示 “Hi xxx! You’ve successfully authenticated…” 表示配置成功。 5. 重新推送git push -u origin master","tags":["git","ssh"],"categories":["GIT"]},{"title":"imx6ull启动日志分析","path":"/2025/08/18/imx6ull启动日志/","content":"U-Boot 2017.03 (Oct 03 2024 - 08:18:41 -0400) CPU: Freescale i.MX6ULL rev1.1 696 MHz (running at 396 MHz)CPU: Industrial temperature grade (-40C to 105C) at 40CReset cause: PORModel: Freescale i.MX6 ULL 14x14 EVK BoardBoard: MX6ULL 14x14 EVKDRAM: 512 MiBMMC: FSL_SDHC: 0, FSL_SDHC: 1Display: TFT7016 (1024x600)Video: 1024x600x24In: serialOut: serialErr: serialNet: No ethernet found.Normal BootHit any key to stop autoboot: 0 Error: “findtee” not definedswitch to partitions #0, OKmmc1(part 0) is current deviceswitch to partitions #0, OKmmc1(part 0) is current device** Unrecognized filesystem type **8846320 bytes read in 440 ms (19.2 MiBs)Booting from mmc …39690 bytes read in 49 ms (791 KiBs)Kernel image @ 0x80800000 [ 0x000000 - 0x86fbf0 ] Flattened Device Tree blob at 83000000 Booting using the fdt blob at 0x83000000 Using Device Tree in place at 83000000, end 8300cb09Modify socaips-bus@02200000epdc@0228c000:status disabledft_system_setup for mx6 Starting kernel … [ 0.000000] Booting Linux on physical CPU 0x0[ 0.000000] Linux version 4.9.88 (book@100ask) (gcc version 7.5.0 (Buildroot 2020.02-gee85cab) ) #4 SMP PREEMPT Thu Mar 13 04:25:09 EDT 2025[ 0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr10c53c7d[ 0.000000] CPU: div instructions available: patching division code[ 0.000000] CPU: PIPT VIPT nonaliasing data cache, VIPT aliasing instruction cache[ 0.000000] OF: fdt:Machine model: Freescale i.MX6 ULL 14x14 EVK Board[ 0.000000] Reserved memory: created CMA memory pool at 0x8c000000, size 320 MiB[ 0.000000] OF: reserved mem: initialized node linux,cma, compatible id shared-dma-pool[ 0.000000] Memory policy: Data cache writealloc[ 0.000000] percpu: Embedded 15 pagescpu @8bb2e000 s30156 r8192 d23092 u61440[ 0.000000] Built 1 zonelists in Zone order, mobility grouping on. Total pages: 130048[ 0.000000] Kernel command line: consolettymxc0,115200 rootdevmmcblk1p2 rootwait rw[ 0.000000] PID hash table entries: 2048 (order: 1, 8192 bytes)[ 0.000000] Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)[ 0.000000] Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)[ 0.000000] Memory: 172236K524288K available (11264K kernel code, 1103K rwdata, 4040K rodata, 1024K init, 477K bss, 24372K reserved, 327680K cma-reserved, 0K highmem)[ 0.000000] Virtual kernel memory layout:[ 0.000000] vector : 0xffff0000 - 0xffff1000 ( 4 kB)[ 0.000000] fixmap : 0xffc00000 - 0xfff00000 (3072 kB)[ 0.000000] vmalloc : 0xa0800000 - 0xff800000 (1520 MB)[ 0.000000] lowmem : 0x80000000 - 0xa0000000 ( 512 MB)[ 0.000000] pkmap : 0x7fe00000 - 0x80000000 ( 2 MB)[ 0.000000] modules : 0x7f000000 - 0x7fe00000 ( 14 MB)[ 0.000000] .text : 0x80008000 - 0x80c00000 (12256 kB)[ 0.000000] .init : 0x81100000 - 0x81200000 (1024 kB)[ 0.000000] .data : 0x81200000 - 0x81313c70 (1104 kB)[ 0.000000] .bss : 0x81315000 - 0x8138c6d8 ( 478 kB)[ 0.000000] SLUB: HWalign64, Order0-3, MinObjects0, CPUs1, Nodes1[ 0.000000] Preemptible hierarchical RCU implementation.[ 0.000000] Build-time adjustment of leaf fanout to 32.[ 0.000000] RCU restricting CPUs from NR_CPUS4 to nr_cpu_ids1.[ 0.000000] RCU: Adjusting geometry for rcu_fanout_leaf32, nr_cpu_ids1[ 0.000000] NR_IRQS:16 nr_irqs:16 16[ 0.000000] Switching to timer-based delay loop, resolution 333ns[ 0.000018] sched_clock: 32 bits at 3000kHz, resolution 333ns, wraps every 715827882841ns[ 0.000068] clocksource: mxc_timer1: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 637086815595 ns[ 0.004510] Console: colour dummy device 80x30[ 0.004564] Calibrating delay loop (skipped), value calculated using timer frequency.. 6.00 BogoMIPS (lpj30000)[ 0.004607] pid_max: default: 32768 minimum: 301[ 0.004861] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)[ 0.004894] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)[ 0.006578] CPU: Testing write buffer coherency: ok[ 0.006680] ftrace: allocating 35227 entries in 104 pages[ 0.140629] cpuscpu@0 missing clock-frequency property[ 0.140684] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000[ 0.140757] Setting up static identity map for 0x80100000 - 0x80100058[ 0.229449] Brought up 1 CPUs[ 0.229490] SMP: Total of 1 processors activated (6.00 BogoMIPS).[ 0.229511] CPU: All CPU(s) started in SVC mode.[ 0.231097] devtmpfs: initialized[ 0.249164] OF: Duplicate name in lcdif@021c8000, renamed to “display#1”[ 0.256508] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 5[ 0.257365] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns[ 0.257424] futex hash table entries: 256 (order: 2, 16384 bytes)[ 0.283866] pinctrl core: initialized pinctrl subsystem[ 0.286526] NET: Registered protocol family 16[ 0.306281] DMA: preallocated 256 KiB pool for atomic coherent allocations[ 0.331551] cpuidle: using governor menu[ 0.393319] hw-breakpoint: found 5 (+1 reserved) breakpoint and 4 watchpoint registers.[ 0.393356] hw-breakpoint: maximum watchpoint size is 8 bytes.[ 0.397863] imx6ul-pinctrl 20e0000.iomuxc: Invalid fsl,pins property in node socaips-bus@02000000iomuxc@020e0000imx6ul-evkenet1grp[ 0.398711] imx6ul-pinctrl 20e0000.iomuxc: initialized IMX pinctrl driver[ 0.399599] imx6ul-pinctrl 2290000.iomuxc-snvs: initialized IMX pinctrl driver[ 0.546074] mxs-dma 1804000.dma-apbh: initialized[ 0.554548] SCSI subsystem initialized[ 0.564527] usbcore: registered new interface driver usbfs[ 0.564748] usbcore: registered new interface driver hub[ 0.565014] usbcore: registered new device driver usb[ 0.567951] i2c i2c-0: IMX I2C adapter registered[ 0.568006] i2c i2c-0: can’t use DMA, using PIO instead.[ 0.570280] i2c i2c-1: IMX I2C adapter registered[ 0.570332] i2c i2c-1: can’t use DMA, using PIO instead.[ 0.571663] Linux video capture interface: v2.00[ 0.571874] pps_core: LinuxPPS API ver. 1 registered[ 0.571899] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti giometti@linux.it[ 0.571964] PTP clock support registered[ 0.575207] MIPI CSI2 driver module loaded[ 0.576501] imx rpmsg driver is registered.[ 0.577036] Advanced Linux Sound Architecture Driver Initialized.[ 0.579348] Bluetooth: Core ver 2.22[ 0.579487] NET: Registered protocol family 31[ 0.579512] Bluetooth: HCI device and connection manager initialized[ 0.579557] Bluetooth: HCI socket layer initialized[ 0.579594] Bluetooth: L2CAP socket layer initialized[ 0.579693] Bluetooth: SCO socket layer initialized[ 0.594415] clocksource: Switched to clocksource mxc_timer1[ 0.783452] VFS: Disk quotas dquot_6.6.0[ 0.783643] VFS: Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)[ 0.813312] NET: Registered protocol family 2[ 0.815091] TCP established hash table entries: 4096 (order: 2, 16384 bytes)[ 0.815227] TCP bind hash table entries: 4096 (order: 3, 32768 bytes)[ 0.815389] TCP: Hash tables configured (established 4096 bind 4096)[ 0.815535] UDP hash table entries: 256 (order: 1, 8192 bytes)[ 0.815597] UDP-Lite hash table entries: 256 (order: 1, 8192 bytes)[ 0.816001] NET: Registered protocol family 1[ 0.837352] RPC: Registered named UNIX socket transport module.[ 0.837388] RPC: Registered udp transport module.[ 0.837410] RPC: Registered tcp transport module.[ 0.837431] RPC: Registered tcp NFSv4.1 backchannel transport module.[ 0.844073] Bus freq driver module loaded[ 0.859324] workingset: timestamp_bits30 max_order17 bucket_order0[ 0.890506] NFS: Registering the id_resolver key type[ 0.890580] Key type id_resolver registered[ 0.890604] Key type id_legacy registered[ 0.890746] jffs2: version 2.2. (NAND) © 2001-2006 Red Hat, Inc.[ 0.892706] fuse init (API version 7.26)[ 0.912006] io scheduler noop registered[ 0.912044] io scheduler deadline registered[ 0.912546] io scheduler cfq registered (default)[ 0.913889] imx-weim 21b8000.weim: Driver registered.[ 0.923122] backlight supply power not found, using dummy regulator[ 0.932749] sii902x 1-0039: No reset pin found[ 0.936749] 21c8000.lcdif supply lcd not found, using dummy regulator[ 1.073728] Console: switching to colour frame buffer device 128x37[ 1.204549] mxsfb 21c8000.lcdif: Success seset LCDIF[ 1.204591] mxsfb 21c8000.lcdif: initialized[ 1.208320] imx-sdma 20ec000.sdma: loaded firmware 3.3[ 1.220207] 2020000.serial: ttymxc0 at MMIO 0x2020000 (irq 20, base_baud 5000000) is a IMX[ 1.922972] console [ttymxc0] enabled[ 1.929129] 21ec000.serial: ttymxc2 at MMIO 0x21ec000 (irq 73, base_baud 5000000) is a IMX[ 1.939733] 21fc000.serial: ttymxc5 at MMIO 0x21fc000 (irq 74, base_baud 5000000) is a IMX[ 1.987307] imx-rng 2284000.rngb: iMX RNG Registered.[ 1.993285] imx sema4 driver is registered.[ 1.997811] [drm] Initialized[ 2.002231] [drm] Initialized vivante 1.0.0 20120216 on minor 0[ 2.205473] brd: module loaded[ 2.277921] loop: module loaded[ 2.292077] spi_gpio spi4: gpio-miso property not found, switching to no-rx mode[ 2.305678] spi_imx 2008000.ecspi: probed[ 2.312397] spi_imx 2010000.ecspi: probed[ 2.319892] libphy: Fixed MDIO Bus: probed[ 2.325383] CAN device driver interface[ 2.332235] flexcan 2090000.can: device registered (reg_basea0a00000, irq29)[ 2.343587] 20b4000.ethernet supply phy not found, using dummy regulator[ 2.395768] pps pps0: new PPS source ptp0[ 2.402541] libphy: fec_enet_mii_bus: probed[ 2.421512] fec 20b4000.ethernet eth0: registered PHC device 0[ 2.429035] 2188000.ethernet supply phy not found, using dummy regulator[ 2.485616] pps pps1: new PPS source ptp1[ 2.493693] fec 2188000.ethernet eth1: registered PHC device 1[ 2.502086] PPP generic driver version 2.4.2[ 2.507201] PPP BSD Compression module registered[ 2.511977] PPP Deflate Compression module registered[ 2.517309] PPP MPPE Compression module registered[ 2.522155] NET: Registered protocol family 24[ 2.526787] SLIP: version 0.8.4-NET3.019-NEWTTY (dynamic channels, max256) (6 bit encapsulation enabled).[ 2.536647] CSLIP: code copyright 1989 Regents of the University of California.[ 2.543996] SLIP linefillkeepalive option.[ 2.548537] usbcore: registered new interface driver asix[ 2.554148] usbcore: registered new interface driver ax88179_178a[ 2.560529] usbcore: registered new interface driver cdc_ether[ 2.566632] usbcore: registered new interface driver cdc_eem[ 2.572472] usbcore: registered new interface driver net1080[ 2.578387] usbcore: registered new interface driver cdc_subset[ 2.584582] usbcore: registered new interface driver zaurus[ 2.590410] usbcore: registered new interface driver cdc_ncm[ 2.596188] ehci_hcd: USB 2.0 ‘Enhanced’ Host Controller (EHCI) Driver[ 2.602798] ehci-platform: EHCI generic platform driver[ 2.609198] ehci-mxc: Freescale On-Chip EHCI Host driver[ 2.614656] random: fast init done[ 2.618462] ohci_hcd: USB 1.1 ‘Open’ Host Controller (OHCI) Driver[ 2.624851] ohci-platform: OHCI generic platform driver[ 2.631009] usbcore: registered new interface driver cdc_acm[ 2.636834] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters[ 2.645159] usbcore: registered new interface driver usblp[ 2.650839] usbcore: registered new interface driver cdc_wdm[ 2.656847] usbcore: registered new interface driver usb-storage[ 2.663186] usbcore: registered new interface driver usbserial[ 2.669286] usbcore: registered new interface driver usbserial_generic[ 2.676057] usbserial: USB Serial support registered for generic[ 2.682230] usbcore: registered new interface driver option[ 2.688044] usbserial: USB Serial support registered for GSM modem (1-port)[ 2.695270] usbcore: registered new interface driver usb_ehset_test[ 2.705076] 2184800.usbmisc supply vbus-wakeup not found, using dummy regulator[ 2.715116] 2184000.usb supply vbus not found, using dummy regulator[ 3.335574] 2184200.usb supply vbus not found, using dummy regulator[ 3.346129] ci_hdrc ci_hdrc.1: EHCI Host Controller[ 3.351139] ci_hdrc ci_hdrc.1: new USB bus registered, assigned bus number 1[ 3.384530] ci_hdrc ci_hdrc.1: USB 2.0 started, EHCI 1.00[ 3.392705] hub 1-0:1.0: USB hub found[ 3.396864] hub 1-0:1.0: 1 port detected[ 3.404246] mousedev: PS2 mouse device common for all mice[ 3.412597] input: 20cc000.snvs:snvs-powerkey as devicessoc0soc2000000.aips-bus20cc000.snvs20cc000.snvs:snvs-powerkeyinputinput0[ 3.427703] imx6ul-pinctrl 20e0000.iomuxc: pin MX6UL_PAD_GPIO1_IO01 already requested by 2010000.ecspi; cannot claim for 2040000.tsc[ 3.439944] imx6ul-pinctrl 20e0000.iomuxc: pin-24 (2040000.tsc) status -22[ 3.446954] imx6ul-pinctrl 20e0000.iomuxc: could not request pin 24 (MX6UL_PAD_GPIO1_IO01) from group tscgrp on device 20e0000.iomuxc[ 3.459133] imx6ul-tsc 2040000.tsc: Error applying setting, reverse things back[ 3.466574] imx6ul-tsc: probe of 2040000.tsc failed with error -22[ 3.474085] usbcore: registered new interface driver usbtouchscreen[ 3.481110] Gt9xx driver installing..[ 3.485402] goodix-ts 1-005d: GTP Driver Version: V2.8.0.220171214[ 3.491987] goodix-ts 1-005d: GTP I2C Address: 0x5d[ 3.497189] goodix-ts 1-005d: touch input parameters is [id x y w p]5 800 480 1024 1024[ 3.505928] 1-005d supply vdd_ana not found, using dummy regulator[ 3.512329] 1-005d supply vcc_i2c not found, using dummy regulator[ 3.518793] goodix-ts 1-005d: Failed get pinctrl state:output_high[ 3.525123] goodix-ts 1-005d: Success request irq-gpio[ 3.530316] goodix-ts 1-005d: Success request rst-gpio[ 3.535549] goodix-ts 1-005d: try to reset and read Guitar 0[ 3.541246] goodix-ts 1-005d: Guitar reset[ 3.576738] goodix-ts 1-005d: I2C Addr is 5d[ 3.582693] goodix-ts 1-005d: IC Version: 911_1060[ 3.589475] goodix-ts 1-005d: Driver set not send config[ 3.626001] goodix-ts 1-005d: Use slot report protocol[ 3.631797] input: goodix-ts as devicesvirtualinputinput1[ 3.638223] goodix-ts 1-005d: INT num 84, trigger type:2[ 3.644192] goodix-ts 1-005d: create proc entry gt9xx_config success[ 3.650796] goodix-ts 1-005d: Alloc memory size:1534.[ 3.655958] goodix-ts 1-005d: I2C function: without pre and end cmd![ 3.662375] goodix-ts 1-005d: Create proc entry success![ 3.672119] snvs_rtc 20cc000.snvs:snvs-rtc-lp: rtc core: registered 20cc000.snvs:snvs-r as rtc0[ 3.682311] i2c dev entries driver[ 3.687748] IR NEC protocol handler initialized[ 3.692334] IR RC5(xsz) protocol handler initialized[ 3.697552] IR RC6 protocol handler initialized[ 3.702120] IR JVC protocol handler initialized[ 3.706737] IR Sony protocol handler initialized[ 3.711386] IR SANYO protocol handler initialized[ 3.716165] IR Sharp protocol handler initialized[ 3.720899] IR MCE Keyboardmouse protocol handler initialized[ 3.726809] IR XMP protocol handler initialized[ 3.735093] pxp-v4l2 pxp_v4l2: initialized[ 3.745145] imx2-wdt 20bc000.wdog: timeout 60 sec (nowayout0)[ 3.752109] Bluetooth: HCI UART driver ver 2.3[ 3.756968] usb 1-1: new high-speed USB device number 2 using ci_hdrc[ 3.764002] Bluetooth: HCI UART protocol H4 registered[ 3.769395] Bluetooth: HCI UART protocol BCSP registered[ 3.774985] Bluetooth: HCI UART protocol ATH3K registered[ 3.781019] usbcore: registered new interface driver bcm203x[ 3.787384] usbcore: registered new interface driver btusb[ 3.797004] sdhci: Secure Digital Host Controller Interface driver[ 3.803239] sdhci: Copyright(c) Pierre Ossman[ 3.807960] sdhci-pltfm: SDHCI platform and OF driver helper[ 3.817762] sdhci-esdhc-imx 2190000.usdhc: could not get ultra high speed state, work on normal mode[ 3.827886] sdhci-esdhc-imx 2190000.usdhc: Got CD GPIO[ 3.896389] mmc0: SDHCI controller on 2190000.usdhc [2190000.usdhc] using ADMA[ 3.905211] sdhci-esdhc-imx 2194000.usdhc: could not get ultra high speed state, work on normal mode[ 3.947203] hub 1-1:1.0: USB hub found[ 3.951294] hub 1-1:1.0: 4 ports detected[ 3.974522] mmc1: SDHCI controller on 2194000.usdhc [2194000.usdhc] using ADMA[ 3.994283] ledtrig-cpu: registered to indicate activity on CPUs[ 4.018682] usbcore: registered new interface driver usbhid[ 4.024315] usbhid: USB HID core driver[ 4.064275] wm8960 1-001a: No platform data supplied[ 4.110264] mmc1: new DDR MMC card at address 0001[ 4.126957] mmcblk1: mmc1:0001 S40004 3.64 GiB[ 4.142458] mmcblk1boot0: mmc1:0001 S40004 partition 1 4.00 MiB[ 4.159586] mmcblk1boot1: mmc1:0001 S40004 partition 2 4.00 MiB[ 4.176714] mmcblk1rpmb: mmc1:0001 S40004 partition 3 4.00 MiB[ 4.195215] mmcblk1: p1 p2 p3[ 4.209289] imx-wm8960 sound: wm8960-hifi - 202c000.sai mapping ok[ 4.221843] imx-wm8960 sound: snd-soc-dummy-dai - 2034000.asrc mapping ok[ 4.229628] imx-wm8960 sound: wm8960-hifi - 202c000.sai mapping ok[ 4.274518] usb 1-1.1: new high-speed USB device number 3 using ci_hdrc[ 4.369229] NET: Registered protocol family 26[ 4.376114] NET: Registered protocol family 10[ 4.393809] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver[ 4.401977] NET: Registered protocol family 17[ 4.406784] can: controller area network core (rev 20120528 abi 9)[ 4.413229] NET: Registered protocol family 29[ 4.417857] can: raw protocol (rev 20120528)[ 4.422170] can: broadcast manager protocol (rev 20161123 t)[ 4.428109] can: netlink gateway (rev 20130117) max_hops1[ 4.435702] Bluetooth: RFCOMM TTY layer initialized[ 4.442912] Bluetooth: RFCOMM socket layer initialized[ 4.449620] Bluetooth: RFCOMM ver 1.11[ 4.453440] Bluetooth: BNEP (Ethernet Emulation) ver 1.3[ 4.459014] Bluetooth: BNEP filters: protocol multicast[ 4.464705] Bluetooth: BNEP socket layer initialized[ 4.469719] Bluetooth: HIDP (Human Interface Emulation) ver 1.2[ 4.475897] Bluetooth: HIDP socket layer initialized[ 4.481080] 8021q: 802.1Q VLAN Support v1.8[ 4.485444] lib80211: common routines for IEEE802.11 drivers[ 4.491607] Key type dns_resolver registered[ 4.500306] cpu cpu0: Registered imx6q-cpufreq[ 4.529808] Bluetooth: hci0: rtl: examining hci_ver06 hci_rev000b lmp_ver06 lmp_subver8723[ 4.538599] Bluetooth: hci0: rtl: loading rtl_btrtl8723b_config.bin[ 4.545167] bluetooth hci0: Falling back to user helper[ 4.611108] imx_thermal 2000000.aips-bus:tempmon: Industrial CPU temperature grade - max:105C critical:100C passive:95C[ 4.624000] input: gpio-keys as devicessoc0gpio-keysinputinput2[ 4.631298] snvs_rtc 20cc000.snvs:snvs-rtc-lp: setting system clock to 1970-01-01 00:00:00 UTC (0)[ 4.641003] ltemodule-pwr: disabling[ 4.644705] wifi-pwr: disabling[ 4.647866] ALSA device list:[ 4.650846] #0: wm8960-audio[ 4.666249] EXT4-fs (mmcblk1p2): couldn’t mount as ext3 due to feature incompatibilities[ 4.937373] EXT4-fs (mmcblk1p2): recovery complete[ 4.944210] EXT4-fs (mmcblk1p2): mounted filesystem with ordered data mode. Opts: (null)[ 4.952552] VFS: Mounted root (ext4 filesystem) on device 179:2.[ 4.959806] devtmpfs: mounted[ 4.966107] Freeing unused kernel memory: 1024K[ 5.218400] EXT4-fs (mmcblk1p2): re-mounted. Opts: dataorderedStarting syslogd: OKStarting klogd: OKRunning sysctl: OK[ 5.709022] ds18b20_drv_init OK.[ 5.726532] dht11_drv_init OK.[ 5.756803] irda_drv_init OK.Populating dev using udev: [ 5.843441] udevd[176]: starting version 3.2.9[ 5.961356] udevd[177]: starting eudev-3.2.9[ 7.014107] inv-mpu6000-spi spi2.0: mounting matrix not found: using identity…[ 7.415114] 8723bu: loading out-of-tree module taints kernel.[ 7.951951] usbcore: registered new interface driver rtl8723budoneInitializing random number generator: OKSaving random seed: OKStarting system message bus: doneStarting network: [ 9.049861] Generic PHY 20b4000.ethernet-1:01: attached PHY driver [Generic PHY] (mii_bus:phy_addr20b4000.ethernet-1:01, irq-1)[ 9.062312] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not readyOKStarting ModemManager: OKStarting NetworkManager … done.Starting ntpd: OKStarting mosquitto: OKStarting pulseaudio: W: [pulseaudio] main.c: This program is not intended to be run as root (unless –system is specified).[ 10.677544] IPv6: ADDRCONF(NETDEV_UP): eth1: link is not ready[ 10.686604] Generic PHY 20b4000.ethernet-1:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr20b4000.ethernet-1:00, irq-1)[ 10.699008] IPv6: ADDRCONF(NETDEV_UP): eth1: link is not ready[ 10.808344] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready[ 12.475638] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready[ 12.632380] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready[ 12.759970] IPv6: ADDRCONF(NETDEV_UP): wlan1: link is not ready[ 12.767253] IPv6: ADDRCONF(NETDEV_UP): wlan1: link is not ready[ 12.880121] IPv6: ADDRCONF(NETDEV_UP): wlan1: link is not ready[ 13.710783] IPv6: ADDRCONF(NETDEV_UP): wlan1: link is not ready[ 13.766578] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not readyOKStarting sshd: OKStarting telnetd: OKStarting swupdate: Trying to connect to SWUpdate…OKConnected to SWUpdate via tmpswupdateprog Welcome to imx6ull buildroot system ! SourceCode: https://gitee.com/weidongshan Support: https://support@100ask.net Shop： https://100ask.taobao.com/ Login: name: root Passwd:100ask login: rootCOLUMNS88;LINES18;export COLUMNS LINES;[root@100ask:~]# [ 69.655147] Bluetooth: hci0: Failed to load rtl_btrtl8723b_config.bin[ 69.661764] Bluetooth: hci0: rtl: loading rtl_btrtl8723b_fw.bin[ 69.692145] Bluetooth: hci0: rom_version status0 version1[ 69.698229] Bluetooth: cfg_sz 0, total size 22768","tags":["linux","启动"],"categories":["嵌入式"]},{"title":"Unix+POSIX+GNU+Linux关系","path":"/2025/08/18/gun_linux_unix_posix/","content":"Unix+POSIX+GNU+Linux关系（1）Unix 是源头1969 年诞生的 Unix 是所有类 Unix 系统的 “原型”，它的多用户多任务、一切皆文件、管道机制等设计思想，奠定了后续 GNU、Linux 的发展基础。但早期 Unix 是商业闭源系统，分支众多且兼容性差，这也催生了 POSIX 标准和 GNU 计划。 （2）POSIX 是统一规范由于 Unix 各分支（如 BSD、AIX、HP-UX）的接口不统一，程序员开发的软件无法跨平台运行。1980 年代推出的 POSIX 标准，定义了操作系统必须提供的系统调用、命令行工具接口等，只要符合 POSIX 标准，软件就能在不同类 Unix 系统上运行。Unix 商业版本：大多通过 POSIX 认证（需符合完整规范）。Linux、GNU 组件：虽未通过 Unix 官方认证，但完全兼容 POSIX 标准。 （3）GNU 计划填补 “自由软件空白”1983 年理查德・斯托曼发起 GNU 计划，目标是开发一套完全自由的类 Unix 系统。经过十余年发展，GNU 完成了编译器（GCC）、shell（Bash）、文本工具（grep、sed）、系统库（glibc） 等几乎所有用户空间组件，但内核部分（原计划是 Hurd 内核）一直未能成熟可用。 （4）Linux 内核 “补全” GNU 系统1991 年，林纳斯・托瓦兹开发了 Linux 内核，并以 GPL 开源协议发布。由于 GNU 缺少可用的内核，开发者将 Linux 内核与 GNU 工具链组合，形成了一套完整的自由操作系统—— 严格来说应称为 GNULinux，但日常简称其为 Linux 系统。 总结Linux ≠ 完整操作系统：Linux 只是内核，我们日常使用的 Ubuntu、CentOS 等，都是 “Linux 内核 + GNU 组件 + 桌面环境 应用” 的集合。GNU ≠ Linux：GNU 是软件生态和项目理念，Linux 是内核；没有 GNU 组件，Linux 内核无法直接为用户提供服务。符合 POSIX ≠ 是 Unix：POSIX 是接口标准，Linux、macOS（基于 BSD）都符合 POSIX，但它们是类 Unix 系统，而非正宗 Unix（正宗 Unix 需通过 Single UNIX Specification 认证）。 日常我们说的 “Linux 系统” 其实是简称，严格意义上应该叫 GNULinux，因为 GNU 组件在用户空间的占比和重要性，并不亚于 Linux 内核。","tags":["linux"],"categories":["嵌入式"]},{"title":"Linux启动分析","path":"/2025/08/18/linuxmain/","content":"这几天一直在纠结： main函数是程序的入口，一个程序启动后，经过bootloader的初始化就该经main函数进入C语言的世界，但是linux中每个应用程序的开始都是从main函数开始的。linux下有多个应用程序，岂不是有很多个main。那bootloader会知道跳到哪个main？多个main编译怎么不冲突？ 在网上搜索了很久，渐渐的有些明白了： 1、main函数是C语言的入口，这句话没错；但是这句话仅仅是一个约定，而非一个亘古不变的铁律！从程序的更为本质的汇编代码来看，只是大家约定汇编初始化完了后，跳到一个名字叫”main”的标号处；言外之意就是这个标号也是可以改名的，比如linux的C语言入口就是start_kernel（）；从这个标号地址后就是C语言的天下了。用main这个名字仅仅是因为大家的约定而已，不遵守约定能玩的转也行啊，就像苹果充电线啥的都和别人不一样。 2、在编译时是不存多个main函数的！每个应用程序虽说都有一个main函数（从应用程序来看应用程序的入口是main函数哦）；但是应用程序都是独立编译的，不会一起编译，操作系统内核就更不可能和应用程序一起编译了！所以根本不存在多个main冲突的！！可能是统一操作系统与应用程序之间的接口，抑或是侧面影响下main是程序入口的说法，main是应用程序和操作系统之间约定好的一个接口名！所以linux中每个应用程序的第一个函数必须是main。除非你改掉了内核调度的接口地方。 3、linux的应用程序的安装启动也可以类比下我们每天都在用的Windows。Windows应用程序的安装其实也是把一些执行文件拷贝到指定的文件夹里（从绿色软件看），点击就可以运行。linux下也是这样。编译好的bin文件放到指定的文件夹目录下，然后用命令启动执行。 * linuxinitmain.c Copyright (C) 1991, 1992 Linus Torvalds GK 2595 - Changed to support mounting root fs via NFS Added initrd change_root: Werner Almesberger Hans Lermen, Feb ‘96 Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May ‘96 Simplified starting of init: Michael A. Griffith grif@acm.org start_kernel-rest_init-kernel_init创建用户init pid1 -kthreadd管理内核线程 pidx -pid0，是idle线程 在rest_init中，会创建kernel_init线程，它负责创建用户init进程,完成工作后，自己 化身为idle线程 * #include linuxtypes.h#include linuxmodule.h#include linuxproc_fs.h#include linuxkernel.h#include linuxsyscalls.h#include linuxstackprotector.h#include linuxstring.h#include linuxctype.h#include linuxdelay.h#include linuxioport.h#include linuxinit.h#include linuxinitrd.h#include linuxbootmem.h#include linuxacpi.h#include linuxtty.h#include linuxpercpu.h#include linuxkmod.h#include linuxvmalloc.h#include linuxkernel_stat.h#include linuxstart_kernel.h#include linuxsecurity.h#include linuxsmp.h#include linuxprofile.h#include linuxrcupdate.h#include linuxmoduleparam.h#include linuxkallsyms.h#include linuxwriteback.h#include linuxcpu.h#include linuxcpuset.h#include linuxcgroup.h#include linuxefi.h#include linuxtick.h#include linuxinterrupt.h#include linuxtaskstats_kern.h#include linuxdelayacct.h#include linuxunistd.h#include linuxrmap.h#include linuxmempolicy.h#include linuxkey.h#include linuxbuffer_head.h#include linuxpage_cgroup.h#include linuxdebug_locks.h#include linuxdebugobjects.h#include linuxlockdep.h#include linuxkmemleak.h#include linuxpid_namespace.h#include linuxdevice.h#include linuxkthread.h#include linuxsched.h#include linuxsignal.h#include linuxidr.h#include linuxkgdb.h#include linuxftrace.h#include linuxasync.h#include linuxkmemcheck.h#include linuxsfi.h#include linuxshmem_fs.h#include linuxslab.h#include linuxperf_event.h #include asmio.h#include asmbugs.h#include asmsetup.h#include asmsections.h#include asmcacheflush.h #ifdef CONFIG_X86_LOCAL_APIC#include asmsmp.h#endif static int kernel_init(void *); extern void init_IRQ(void);extern void fork_init(unsigned long);extern void mca_init(void);extern void sbus_init(void);extern void prio_tree_init(void);extern void radix_tree_init(void);#ifndef CONFIG_DEBUG_RODATAstatic inline void mark_rodata_ro(void) { }#endif #ifdef CONFIG_TCextern void tc_init(void);#endif * Debug helper: via this flag we know that we are in ‘early bootup code’ where only the boot processor is running with IRQ disabled. This means two things - IRQ must not be enabled before the flag is cleared and some operations which are not allowed with IRQ disabled are allowed while the flag is set. *bool early_boot_irqs_disabled __read_mostly; enum system_states system_state __read_mostly;EXPORT_SYMBOL(system_state); * Boot command-line arguments * #define MAX_INIT_ARGS CONFIG_INIT_ENV_ARG_LIMIT#define MAX_INIT_ENVS CONFIG_INIT_ENV_ARG_LIMIT extern void time_init(void);* Default late time init is NULL. archs can override this later. void (__initdata late_time_init)(void);extern void softirq_init(void); * Untouched command line saved by arch-specific code. char __initdata boot_command_line[COMMAND_LINE_SIZE]; Untouched saved command line (eg. for proc) *char saved_command_line; Command line for parameter parsing *static char *static_command_line; static char *execute_command;static char *ramdisk_execute_command; * If set, this is an indication to the drivers that reset the underlying device before going ahead with the initialization otherwise driver might rely on the BIOS and skip the reset operation. This is useful if kernel is booting in an unreliable environment. For ex. kdump situaiton where previous kernel has crashed, BIOS has been skipped and devices will be in unknown state. *unsigned int reset_devices;EXPORT_SYMBOL(reset_devices); static int __init set_reset_devices(char *str){ reset_devices 1; return 1;} __setup(“reset_devices”, set_reset_devices); static const char * argv_init[MAX_INIT_ARGS+2] { “init”, NULL, };const char * envp_init[MAX_INIT_ENVS+2] { “HOME“, “TERMlinux”, NULL, };static const char *panic_later, *panic_param; extern const struct obs_kernel_param __setup_start[], __setup_end[]; static int __init obsolete_checksetup(char *line){ const struct obs_kernel_param *p; int had_early_param 0; p = __setup_start; do { int n = strlen(p-str); if (parameqn(line, p-str, n)) { if (p-early) { /* Already done in parse_early_param? * (Needs exact match on param part). * Keep iterating, as we can have early * params and __setups of same names 8( */ if (line[n] == \\0 || line[n] == =) had_early_param = 1; } else if (!p-setup_func) { printk(KERN_WARNING Parameter %s is obsolete, ignored , p-str); return 1; } else if (p-setup_func(line + n)) return 1; } p++; } while (p __setup_end); return had_early_param; } * This should be approx 2 Bo*oMips to start (note initial shift), and will still work even if initially too large, it will just take slightly longer *unsigned long loops_per_jiffy (112);EXPORT_SYMBOL(loops_per_jiffy);static int __init debug_kernel(char *str){ console_loglevel 10; return 0;}static int __init quiet_kernel(char *str){ console_loglevel 4; return 0;}early_param(“debug”, debug_kernel);early_param(“quiet”, quiet_kernel);static int __init loglevel(char str){ int newlevel; Only update loglevel value when a correct setting was passed, to prevent blind crashes (when loglevel being set to 0) that are quite hard to debug if (get_option(str, newlevel)) { console_loglevel newlevel; return 0; } return -EINVAL;}early_param(“loglevel”, loglevel); Change NUL term back to “”, to make “param” the whole string. *static int __init repair_env_string(char *param, char val){ if (val) { paramval or param”val”? * if (val param+strlen(param)+1) val[-1] ‘’; else if (val param+strlen(param)+2) { val[-2] ‘’; memmove(val-1, val, strlen(val)+1); val–; } else BUG(); } return 0;}* Unknown boot options get handed to init, unless they look like unused parameters (modprobe will find them in proccmdline). *static int __init unknown_bootoption(char *param, char val){ repair_env_string(param, val); Handle obsolete-style parameters if (obsolete_checksetup(param)) return 0; Unused module parameter. if (strchr(param, ‘.’) (!val || strchr(param, ‘.’) val)) return 0; if (panic_later) return 0; if (val) { Environment option * unsigned int i; for (i 0; envp_init[i]; i++) { if (i MAX_INIT_ENVS) { panic_later “Too many boot env vars at %s; panic_param = param; } if (!strncmp(param, envp_init[i], val - param)) break; } envp_init[i] = param; } else { /* Command line option */ unsigned int i; for (i = 0; argv_init[i]; i++) { if (i == MAX_INIT_ARGS) { panic_later = Too many boot init vars at %s’”; panic_param param; } } argv_init[i] param; } return 0;}static int __init init_setup(char str){ unsigned int i; execute_command str; In case LILO is going to boot us with default command line, it prepends “auto” before the whole cmdline which makes the shell think it should execute a script with such name. So we ignore all arguments entered before init… [MJ] * for (i 1; i MAX_INIT_ARGS; i++) argv_init[i] NULL; return 1;}__setup(“init”, init_setup);static int __init rdinit_setup(char str){ unsigned int i; ramdisk_execute_command str; See “auto” comment in init_setup * for (i 1; i MAX_INIT_ARGS; i++) argv_init[i] NULL; return 1;}__setup(“rdinit”, rdinit_setup); #ifndef CONFIG_SMPstatic const unsigned int setup_max_cpus NR_CPUS;#ifdef CONFIG_X86_LOCAL_APICstatic void __init smp_init(void){ APIC_init_uniprocessor();}#else#define smp_init() do { } while (0)#endifstatic inline void setup_nr_cpu_ids(void) { }static inline void smp_prepare_cpus(unsigned int maxcpus) { }#endif* We need to store the untouched command line for future reference. We also need to store the touched command line since the parameter parsing is performed in place, and we should allow a component to store reference of namevalue for future reference. *static void __init setup_command_line(char command_line){ saved_command_line alloc_bootmem(strlen (boot_command_line)+1); static_command_line alloc_bootmem(strlen (command_line)+1); strcpy (saved_command_line, boot_command_line); strcpy (static_command_line, command_line);} We need to finalize in a non-__init function or else race conditions between the root thread and the init thread may cause start_kernel to be reaped by free_initmem before the root thread has proceeded to cpu_idle. gcc-3.4 accidentally inlines this function, so use noinline. static __initdata DECLARE_COMPLETION(kthreadd_done);static noinline void __init_refok rest_init(void){ int pid; rcu_scheduler_starting();READ-COPY UPDATE启动 We need to spawn init first so that it obtains pid 1, however the init task will end up wanting to create kthreads, which, if we schedule it before we create kthreadd, will OOPS. 创建一个内核线程，它的线程函数是kernel_init,pid1,内核进程 kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND); numa策略设置 numa_default_policy(); 全局链表kthread_create_list中的kthread内核线程都被运行 kthreadd线程管理和调度其它内核线程 pid kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); rcu_read_lock(); 通过pid,ini_pid_ns取得kthreadd地址 kthreadd_task find_task_by_pid_ns(pid, init_pid_ns); rcu_read_unlock(); 通知在kthreadd_done条件的kernel_init线程 complete(kthreadd_done); The boot idle thread must execute schedule() at least once to get things moving: idle 线程初始化 init_idle_bootup_task(current); 抢占禁用 schedule_preempt_disabled(); Call into cpu_idle with preempt disabled cpu_idle();} Check for early params. *static int __init do_early_param(char *param, char *val){ const struct obs_kernel_param p; for (p __setup_start; p __setup_end; p++) { if ((p-early parameq(param, p-str)) || (strcmp(param, “console”) 0 strcmp(p-str, “earlycon”) 0) ) { if (p-setup_func(val) ! 0) printk(KERN_WARNING “Malformed early option ‘%s’ ”, param); } } We accept everything at this stage. * return 0;}void __init parse_early_options(char cmdline){ parse_args(“early options”, cmdline, NULL, 0, 0, 0, do_early_param);} Arch code calls this early on, or if not, just before other parsing. void __init parse_early_param(void){ static __initdata int done 0; static __initdata char tmp_cmdline[COMMAND_LINE_SIZE]; if (done) return; All fall through to do_early_param. strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE); parse_early_options(tmp_cmdline); done 1;} Activate the first processor. static void __init boot_cpu_init(void){int cpu smp_processor_id(); Mark the boot cpu “present”, “online” etc for SMP and UP case set_cpu_online(cpu, true);set_cpu_active(cpu, true);set_cpu_present(cpu, true);set_cpu_possible(cpu, true);}void __init __weak smp_setup_processor_id(void){}void __init __weak thread_info_cache_init(void){} Set up kernel memory allocators static void __init mm_init(void){ page_cgroup requires contiguous pages, bigger than MAX_ORDER unless SPARSEMEM. page_cgroup_init_flatmem(); mem_init(); kmem_cache_init(); percpu_init_late(); pgtable_cache_init(); vmalloc_init();}asmlinkage void __init start_kernel(void){ char * command_line; extern const struct kernel_param __start___param[], __stop___param[]; Need to run as early as possible, to initialize the lockdep hash: 初始化2个hash表-Lock Dependency Validator(内核依赖的关系表) lockdep_init(); smp_setup_processor_id(); 空函数 debug_objects_early_init();初始化内核调试相关 Set up the the initial canary ASAP: boot_init_stack_canary();栈溢出保护初始化 控制组初始化-cgroup-资源任务分组管理 cgroup_init_early(); local_irq_disable();关中断 early_boot_irqs_disabled true; Interrupts are still disabled. Do necessary setups, then enable them tick_init();时钟初始化 boot_cpu_init();启动cpu初始化 page_address_init();页面初始化 printk(KERN_NOTICE “%s”, linux_banner); setup_arch(command_line);架构相关初始化 mm_init_owner(init_mm, init_task);内存管理初始化 mm_init_cpumask(init_mm);内存管理初始化 setup_command_line(command_line);处理命令行(保存2份) setup_nr_cpu_ids();cpuid相关 setup_per_cpu_areas();每cpu变量申请空间(包括gdt) smp中用来启动的cpu smp_prepare_boot_cpu(); arch-specific boot-cpu hooks 建立系统内存页区链表 build_all_zonelists(NULL); 内存页相关初始化 page_alloc_init(); printk(KERN_NOTICE “Kernel command line: %s ”, boot_command_line); 命令行boot_command_line parse_early_param(); 解析参数 parse_args(“Booting kernel”, static_command_line, __start___param, __stop___param - __start___param, -1, -1, unknown_bootoption); jump_label_init(); These use large bootmem allocations and must precede kmem_cache_init() 内存初始化相关 setup_log_buf(0); pidhash_init(); vfs_caches_init_early(); sort_main_extable(); trap_init(); mm_init(); Set up the scheduler prior starting any interrupts (such as the timer interrupt). Full topology setup happens at smp_init() time - but meanwhile we still have a functioning scheduler. 调度初始化 sched_init(); Disable preemption - early bootup scheduling is extremely fragile until we cpu_idle() for the first time. 抢占禁用 preempt_disable(); if (!irqs_disabled()) { printk(KERN_WARNING “start_kernel(): bug: interrupts were “ “enabled very early, fixing it ”); local_irq_disable(); } idr_init_cache();idr perf_event_init();performance event rcu_init();read-copy-update 机制 radix_tree_init();radix树机制 init some links before init_ISA_irqs() * early_irq_init();中断请求 init_IRQ();中断请求 prio_tree_init();优先查找树 init_timers();时钟 hrtimers_init();High-resolution kernel timers高精度内核时钟 softirq_init();软中断 timekeeping_init();时间相关 time_init();时间 profile_init();分配内核性能统计保存的内存 call_function_init();smp中每cpu的call_single_queue初始化 if (!irqs_disabled()) printk(KERN_CRIT “start_kernel(): bug: interrupts were “ “enabled early ”); early_boot_irqs_disabled false;中断请求开 local_irq_enable();本地中断开 kmem_cache_init_late();kmem后期初始化 * HACK ALERT! This is early. We’re enabling the console before we’ve done PCI setups etc, and console_init() must be aware of this. But we do want output early, in case something goes wrong. console_init();初始化系统控制台结构 if (panic_later) panic(panic_later, panic_param); 锁依赖信息 lockdep_info(); Need to run this when irqs are enabled, because it wants to self-test [hardsoft]-irqs onoff lock inversion bugs too: * locking_selftest(); #ifdef CONFIG_BLK_DEV_INITRD if (initrd_start !initrd_below_start_ok page_to_pfn(virt_to_page((void *)initrd_start)) min_low_pfn) { printk(KERN_CRIT “initrd overwritten (0x%08lx 0x%08lx) - “ “disabling it. ”, page_to_pfn(virt_to_page((void )initrd_start)), min_low_pfn); initrd_start 0; }#endif page_cgroup_init();control groups初始化 debug_objects_mem_init();对象调试 kmemleak_init();检测内核内存泄漏的功能 setup_per_cpu_pageset();申请并初始化每cpu页set numa_policy_init();numa相关 if (late_time_init) late_time_init(); 初始化每cpusched_clock_dataktime_now sched_clock_init(); calibrate_delay();计算cpuMIPS百万条指令s pidmap_init();pid进程id表初始化 anon_vma_init();虚拟地址#ifdef CONFIG_X86 if (efi_enabled)efi bois efi_enter_virtual_mode();#endif thread_info_cache_init();申请thread_info的内存 cred_init();credential健在分配 根据物理内存大小，计算可创建进线程数量 fork_init(totalram_pages); proc_caches_init();进程内存初始化 buffer_init();页高速缓存 key_init();红黑树内存，存keys security_init();安全相关 dbg_late_init();调试相关 vfs_caches_init(totalram_pages);虚拟文件系统初始化 signals_init();sigqueue申请内存，信号系统 rootfs populating might need page-writeback page_writeback_init();页回写#ifdef CONFIG_PROC_FS proc_root_init();proc文件系统初始化#endif cgroup_init();cgroup相关 cpuset_init();cpuset相关 taskstats_init_early();进程计数器 delayacct_init();进程延时审计 check_bugs();系统bug相关测试 acpi总线 acpi_early_init(); before LAPIC and SMP init sfi_init_late();Simple Firmware Interface 功能追踪初始化,一种调试工具 ftrace_init(); Do the rest non-__init’ed, we’re now alive rest_init();} Call all constructor functions linked into the kernel. *static void __init do_ctors(void){#ifdef CONFIG_CONSTRUCTORS ctor_fn_t *fn (ctor_fn_t *) __ctors_start; for (; fn (ctor_fn_t *) __ctors_end; fn++) (*fn)();#endif}bool initcall_debug;core_param(initcall_debug, initcall_debug, bool, 0644);static char msgbuf[64];static int __init_or_module do_one_initcall_debug(initcall_t fn){ ktime_t calltime, delta, rettime; unsigned long long duration; int ret; printk(KERN_DEBUG “calling %pF @ %i ”, fn, task_pid_nr(current)); calltime ktime_get(); ret fn(); rettime ktime_get(); delta ktime_sub(rettime, calltime); duration (unsigned long long) ktime_to_ns(delta) 10; printk(KERN_DEBUG “initcall %pF returned %d after %lld usecs ”, fn, ret, duration); return ret;}int __init_or_module do_one_initcall(initcall_t fn){ int count preempt_count(); int ret; if (initcall_debug) ret do_one_initcall_debug(fn); else ret fn(); msgbuf[0] 0; if (ret ret ! -ENODEV initcall_debug) sprintf(msgbuf, “error code %d “, ret); if (preempt_count() ! count) { strlcat(msgbuf, “preemption imbalance “, sizeof(msgbuf)); preempt_count() count; } if (irqs_disabled()) { strlcat(msgbuf, “disabled interrupts “, sizeof(msgbuf)); local_irq_enable(); } if (msgbuf[0]) { printk(“initcall %pF returned with %s ”, fn, msgbuf); } return ret;}extern initcall_t __initcall_start[];extern initcall_t __initcall0_start[];extern initcall_t __initcall1_start[];extern initcall_t __initcall2_start[];extern initcall_t __initcall3_start[];extern initcall_t __initcall4_start[];extern initcall_t __initcall5_start[];extern initcall_t __initcall6_start[];extern initcall_t __initcall7_start[];extern initcall_t __initcall_end[];static initcall_t *initcall_levels[] __initdata { __initcall0_start, __initcall1_start, __initcall2_start, __initcall3_start, __initcall4_start, __initcall5_start, __initcall6_start, __initcall7_start, __initcall_end,};static char *initcall_level_names[] __initdata { “early parameters”, “core parameters”, “postcore parameters”, “arch parameters”, “subsys parameters”, “fs parameters”, “device parameters”, “late parameters”,};static void __init do_initcall_level(int level){ extern const struct kernel_param __start___param[], __stop___param[]; initcall_t *fn; strcpy(static_command_line, saved_command_line); parse_args(initcall_level_names[level], static_command_line, __start___param, __stop___param - __start___param, level, level, repair_env_string); for (fn initcall_levels[level]; fn initcall_levels[level+1]; fn++) do_one_initcall(fn);}static void __init do_initcalls(void){ int level; for (level 0; level ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level);} Ok, the machine is now initialized. None of the devices have been touched yet, but the CPU subsystem is up and running, and memory and process management works. Now we can finally start doing some real work.. *static void __init do_basic_setup(void){ cpuset_init_smp();smp cpuset相关 usermodehelper_init();khelper单线程工作队列 shmem_init();sheme机制 driver_init();驱动各子系统 init_irq_proc();proc中创建irq目录 do_ctors();内核中所有构造函数,介于.ctors段中的函数 usermodehelper_enable(); 所有编译进内核的驱动模块初始化函数 do_initcalls();}static void __init do_pre_smp_initcalls(void){ initcall_t *fn; for (fn __initcall_start; fn __initcall0_start; fn++) do_one_initcall(*fn); }static void run_init_process(const char init_filename){ argv_init[0] init_filename; kernel_execve(init_filename, argv_init, envp_init);} This is a non __init function. Force it to be noinline otherwise gcc makes it inline to init() and it becomes part of init.text section 这是个非Init函数，防止gcc让它内联到init()，并成为Init.text段的一部分 static noinline int init_post(void){ need to finish all async __init code before freeing the memory 在释放init内存前，必须完成所有__init代码执行 * async_synchronize_full(); free_initmem();释放init.*段中的内存 修改页表，保证只读数据段为只读属性read only mark_rodata_ro(); 系统运行状态标志 system_state SYSTEM_RUNNING; numa默认策略 numa_default_policy(); 当前进程不能被杀掉，只为它是init current-signal-flags | SIGNAL_UNKILLABLE; 如果ramdisk_execute_command变量指定了init程序，执行它 if (ramdisk_execute_command) { run_init_process(ramdisk_execute_command); printk(KERN_WARNING “Failed to execute %s ”, ramdisk_execute_command); } * We try each of these until one succeeds. The Bourne shell can be used instead of init if we are trying to recover a really broken machine. 又一个程序，看能不能执行，如果不能，则执行下面4个之一 * if (execute_command) { run_init_process(execute_command); printk(KERN_WARNING “Failed to execute %s. Attempting “ “defaults… ”, execute_command); } run_init_process(“sbininit”); run_init_process(“etcinit”); run_init_process(“bininit”); run_init_process(“binsh”); 两个变量和4个init都不能成功执行，报错 panic(“No init found. Try passing init option to kernel. “ “See Linux Documentationinit.txt for guidance.”); }static int __init kernel_init(void * unused){ * * Wait until kthreadd is all set-up.等待kthreadd的启动完成 wait_for_completion(kthreadd_done); Now the scheduler is fully set up and can do blocking allocations * gfp_allowed_mask __GFP_BITS_MASK; * init can allocate pages on any node set_mems_allowed(node_states[N_HIGH_MEMORY]); * init can run on any cpu. set_cpus_allowed_ptr(current, cpu_all_mask); cad_pid为接收Ctrl-alt-del操作的INT信号的进程ID,设置成了init的pid 说明init可接受这3个键 cad_pid task_pid(current); smp系统准备、激活所有cpu smp_prepare_cpus(setup_max_cpus); do_pre_smp_initcalls(); lockup_detector_init(); smp_init(); sched_init_smp(); 初始化设备驱动、内核模块 do_basic_setup(); Open the devconsole on the rootfs, this should never fail * 打开devconsole设备 * if (sys_open((const char __user ) “devconsole”, O_RDWR, 0) 0) printk(KERN_WARNING “Warning: unable to open an initial console. ”); * 复制两次标准输入0，一个是标准输入1，一个是标准错误2 (void) sys_dup(0); (void) sys_dup(0); * check if there is an early userspace init. If yes, let it do all * the work * 是否有早期用户空间init进程，有的话，让其执行 * if (!ramdisk_execute_command) ramdisk_execute_command “init”; if (sys_access((const char __user ) ramdisk_execute_command, 0) ! 0) { ramdisk_execute_command NULL; prepare_namespace(); } * Ok, we have completed the initial bootup, and * we’re essentially up and running. Get rid of the * initmem segments and start the user-mode stuff.. * 启动用户空间的init进程 init_post(); return 0;}","tags":["linux","启动"],"categories":["LINUX"]},{"title":"platform_device的一篇知乎解析","path":"/2025/08/18/platform_device的一篇知乎解析/","content":"platform_device的一篇知乎解析 (4 封私信 21 条消息) 驱动入口点——platform_device解析 - 知乎","tags":["linux","platform"],"categories":["驱动"]},{"title":"platform总线匹配方式","path":"/2025/08/18/platform总线匹配方式/","content":"platform总线匹配方式重要结构体struct platform_devicestruct platform_device const char\t*name;\tint id;\tbool id_auto;\tstruct device\tdev;\tu32 num_resources;\tstruct resource\t*resource;\tconst struct platform_device_id\t*id_entry;\tchar *driver_override; /* Driver name to force a match 第一种匹配方式：匹配优先级最高*/\t/* MFD cell pointer */\tstruct mfd_cell *mfd_cell;\t/* arch specific additions */\tstruct pdev_archdata\tarchdata;; struct platform_driverstruct platform_driver int (*probe)(struct platform_device *);\tint (*remove)(struct platform_device *);\tvoid (*shutdown)(struct platform_device *);\tint (*suspend)(struct platform_device *, pm_message_t state);\tint (*resume)(struct platform_device *);\tstruct device_driver driver;//第二种匹配方式：.of_match_table成员用于compatible属性匹配,类型为const struct of_device_id *of_match_table;推荐方式 //第三种匹配方式.acpi_match_table成员用于acpi方式匹配\tconst struct platform_device_id *id_table;//第四种匹配方式：用于ID表匹配，传统方式\tbool prevent_deferred_probe;; 先讨论platform_match这个函数 /** * platform_match - bind platform device to platform driver. * @dev: device. * @drv: driver. * * Platform device IDs are assumed to be encoded like this: * nameinstance, where name is a short description of the type of * device, like pci or floppy, and instance is the enumerated * instance of the device, like 0 or 42. Driver IDs are simply * name. So, extract the name from the platform_device structure, * and compare it against the name of the driver. Return whether they match * or not. */static int platform_match(struct device *dev, struct device_driver *drv)\tstruct platform_device *pdev = to_platform_device(dev);\tstruct platform_driver *pdrv = to_platform_driver(drv);\t/* When driver_override is set, only bind to the matching driver */\tif (pdev-driver_override) return !strcmp(pdev-driver_override, drv-name);\t/* Attempt an OF style match first */\tif (of_driver_match_device(dev, drv)) return 1;\t/* Then try ACPI style match */\tif (acpi_driver_match_device(dev, drv)) return 1;\t/* Then try to match against the id table */\tif (pdrv-id_table) return platform_match_id(pdrv-id_table, pdev) != NULL;\t/* fall-back to driver name match */\treturn (strcmp(pdev-name, drv-name) == 0); 函数按照以下顺序进行匹配，一旦某个匹配成功就返回： driver_override（强制绑定） 设备树匹配 ACPI匹配 ID表匹配 名称匹配（兜底方案) 详细分析数据类型转化：struct platform_device *pdev = to_platform_device(dev);struct platform_driver *pdrv = to_platform_driver(drv); 将通用的device和device_driver结构转换为platform特定的结构体，方便访问platform特有的字段。 to_platform_device用于通过struct device类型的dev指针，得到包含它的struct platform_device类型的指针。 to_platform_driver用于通过struct device_driver类型的drv指针，得到包含它的struct platform_driver类型的指针。 这两个宏定义由contain_of宏定义实现 #define to_platform_device(x) container_of((x), struct platform_device, dev)#define to_platform_driver(drv)\t(container_of((drv), struct platform_driver, driver)) driver_override匹配if (pdev-driver_override) return !strcmp(pdev-driver_override, drv-name); 检查设备是否指定了强制绑定的驱动名称 如果指定，则只与该名称完全匹配的驱动绑定 这通常用于调试或强制特定设备使用特定驱动 设备树匹配if (of_driver_match_device(dev,drv))\treturn 1; 调用设备树匹配函数 通过设备节点的”compatible”属性与驱动的of_match_table进行匹配 这是现代嵌入式系统中最常用的匹配方式 ACPI匹配if (acpi_driver_match_device(dev, drv)) return 1; 在ACPI系统中，通过ACPI_hid和驱动进行匹配 主要用于x86系统 ID表匹配if (pdrv-id_table)\treturn platform_match_id(pdrv-id_table,pdev) != NULL; 使用驱动中定义的id_table与设备名称进行匹配 遍历驱动的ID表，查找与设备名称匹配的项 名称匹配return (strcmp(pdev-name,drv-name) == 0) 简单地比较设备名称和驱动名称是否相同 这是最基本的匹配方式 区分设备树匹配和ID表匹配1. of_driver_match_device 用于**设备树(Device Tree)**匹配机制 通过设备树中的compatible属性进行匹配 工作原理// 在设备树中my_device: my-device@10000000 compatible = vendor,device-name, generic-name; reg = 0x10000000 0x1000;;// 在驱动中static const struct of_device_id my_of_match[] = .compatible = vendor,device-name, .data = my_data , .compatible = generic-name, .data = generic_data , ;static struct platform_driver my_driver = .driver = .name = my-driver, .of_match_table = my_of_match, , .probe = my_probe,; 匹配过程 遍历驱动的of_match_table数组 将设备树节点的compatible属性与表中条目逐一比较 找到第一个匹配项即成功 2. platform_match_id 用于传统platform设备ID表匹配机制 通过设备和驱动的名称进行匹配 工作原理c// 在驱动中定义ID表static const struct platform_device_id my_id_table[] = my-device-name, .driver_data = MY_DATA_1 , my-old-device, .driver_data = MY_DATA_2 , ;static struct platform_driver my_driver = .driver = .name = my-driver, , .id_table = my_id_table, // 使用ID表匹配 .probe = my_probe,;// 在板级文件或设备注册时static struct platform_device my_device = .name = my-device-name, // 与ID表中的名称匹配 .id = -1, // ...; 匹配过程 遍历驱动的id_table数组 将设备的name字段与表中条目的name字段比较 找到匹配项即成功，并将匹配的表项保存到设备的id_entry字段 设备树匹配和ID表匹配不同点 维度 of_driver_match_device（设备树匹配） platform_match_id（ID 表匹配） 匹配依据 基于设备树（Device Tree）中的 compatible 属性。 基于驱动中定义的 id_table（struct platform_device_id 数组）。 适用场景 主要用于使用设备树的系统（现代嵌入式系统主流，如 ARM、RISC-V 平台）。 主要用于不使用设备树的系统（如部分 x86 平台、老的嵌入式系统），或作为设备树匹配的补充。 实现逻辑 1. 设备在设备树中通过 compatible 属性声明自己的「兼容标识」（如 vendor,chip-name）； 2. 驱动通过 of_match_table 成员声明自己支持的 compatible 列表； 3. 函数比较设备的 compatible 与驱动的 of_match_table，若有一致则匹配成功。 1. 驱动通过 id_table 定义支持的设备名称列表（name 字段）和设备 ID（id 字段）； 2. 设备通过 name 和 id 成员标识自己； 3. 函数遍历 id_table，若设备的 name 和 id 与表中某条目一致，则匹配成功。 灵活性 更高。compatible 属性可包含多个值（如 vendor,chip-v2、vendor,chip-v1），支持「向下兼容」（驱动可匹配多个版本的设备）。 较低。依赖精确的名称和 ID 匹配，通常只能匹配固定名称或 ID 的设备。 在匹配链中的优先级 较高（在 platform_match 中先于 platform_match_id 执行）。 较低（在设备树、ACPI 匹配失败后才执行）。 3. 实例文件地址：drivers\\gpio\\gpio-mxc.c static const struct of_device_id mxc_gpio_dt_ids[] = .compatible = fsl,imx1-gpio, .data = mxc_gpio_devtype[IMX1_GPIO], , .compatible = fsl,imx21-gpio, .data = mxc_gpio_devtype[IMX21_GPIO], , .compatible = fsl,imx31-gpio, .data = mxc_gpio_devtype[IMX31_GPIO], , .compatible = fsl,imx35-gpio, .data = mxc_gpio_devtype[IMX35_GPIO], , /* sentinel */ ; static const struct platform_device_id mxc_gpio_devtype[] = .name = imx1-gpio, .driver_data = IMX1_GPIO,\t, .name = imx21-gpio, .driver_data = IMX21_GPIO,\t, .name = imx31-gpio, .driver_data = IMX31_GPIO,\t, .name = imx35-gpio, .driver_data = IMX35_GPIO,\t, /* sentinel */\t; static struct platform_driver mxc_gpio_driver = .driver = .name\t= gpio-mxc, .pm = mxc_gpio_dev_pm_ops, .of_match_table = mxc_gpio_dt_ids,//支持设备树匹配模式\t,\t.probe = mxc_gpio_probe,\t.id_table\t= mxc_gpio_devtype,//支持ID表匹配模式;","tags":["linux","platform"],"categories":["驱动"]},{"title":"platformbus及其初始化过程分析","path":"/2025/08/18/platformbus及其初始化过程分析/","content":"platformbus及其初始化过程分析 platform基本概念对于usb设备、i2c设备、pci设备、spi设备等等，他们与cpu的通信都是直接挂在相应的总线下面与cpu进行数据交互的，但是在嵌入式系统中，并不是所有的设备都可以归属到这些常见的总线中。所有linux驱动模型为了保持完整性，将这些设备挂载在一条虚拟的总线上，即platform总线，从而避免了有些设备挂载在总线上，而有些设备没有挂载在总线上。 linux_platform_driver 机制和传统的device_driver机制（即：通过 driver_register 函数进行注册）相比，一个十分明显的优势在于platform机制将设备本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时，通过 platform device提供的标准接口进行申请并使用。 1.1paltform驱动管理和注册机制设备用struct platform_device表示，驱动用struct platform_driver表示 platform 是一个虚拟的地址总线，相比 PCI、USB，它主要用于描述SOC上的片上资源。platform 所描述的资源有一个共同点：在CPU 的总线上直接取址。平台设备会分到一个名称（用在驱动绑定中）以及一系列诸如地址和中断请求号（IRQ）之类的资源。 Linux platform总线、platform设备、platform驱动之间的关系及框架（1） 当系统向内核注册每一个驱动程序时，都要通过调用platform_driver_register函数将驱动程序注册到总线（bus），并将其放入所属总线的drv链表中，注册驱动的时候会调用所属总线的match函数寻找该总线上与之匹配的每一个设备，如果找到与之匹配的设备则会调用相应的probe函数将相应的设备和驱动进行绑定； （2） 当系统向内核注册每一个设备时，可以通过调用platform_device_register函数，也可以通过解析DTB由内核完成platform device的创建，并将设备platform device注册到总线platform bus，并将其放入所属总线的dev链表中，注册设备的时候同样也会调用所属总线的match函数寻找该总线上与之匹配的每一个驱动程序，如果找到与之匹配的驱动程序时会调用相应的probe函数将相应的设备和驱动进行绑定；而这一匹配的过程是由总线自动完成的。 platform bus关键结构体 struct bus_type const char *name; // 总线名字 struct bus_attribute *bus_attrs; // 该总线的属性 struct device_attribute *dev_attrs; // 该总线下设备的属性 struct driver_attribute *drv_attrs; // 该总线下设备驱动的属性 int (*match)(struct device *dev, struct device_driver *drv); // 该总线下设备与设备驱动的匹配函数 int (*uevent)(struct device *dev, struct kobj_uevent_env *env); // 事件函数 热拨插 int (*probe)(struct device *dev); // 总线下的 探针函数 int (*remove)(struct device *dev); // 总线下的 卸载函数 void (*shutdown)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); const struct dev_pm_ops *pm; // 电源管理相关的 struct bus_type_private *p; // 总线的私有数据 p-subsys.kobj 表示该总线在驱动模型中对应的对象;struct bus_type_private struct kset subsys; // 这个是bus主要的kset struct kset *drivers_kset; // 这个kset指针用来指向该总线的 drivers目录的 struct kset *devices_kset; // 这个kse指针用来指向该总线的devices目录的 struct klist klist_devices; // 用来挂接该总线下的设备的一个链表头 struct klist klist_drivers; // 用来挂接该总线下的设备驱动的一个链表头 struct blocking_notifier_head bus_notifier; unsigned int drivers_autoprobe:1; // 是否需要在设备驱动注册时候子自动匹配设备 struct bus_type *bus; // 指向本bus结构体; platform bus初始化流程platform bus的初始化由函数platfrom_bus_init()函数来完成。由于platform bus本身也是一种设备，因此调用了原始的系统接口device_register()和bus_register()分别完成platform_bus设备和platform_bus_type本身的初始化； start_kernel() // init/main.c rest_init(); pid = kernel_thread(kernel_init, NULL, CLONE_FS); kernel_init(void *unused) kernel_init_freeable(); do_basic_setup(); driver_init(); // kernel/drivers/base/init.c devices_init(); #device初始化 buses_init(); #bus初始化 classes_init(); #class初始化 platform_bus_init(); #platform bus初始化 kernel/drivers/base/platform.c early_platform_cleanup();// 进行一些早期的平台清理 error = device_register(platform_bus);//注册设备 (在/sys/devices/目录下建立 platform目录对应的设备对象 /sys/devices/platform/) error = bus_register(platform_bus_type); // 将Platform bus总线注册进系统 of_platform_register_reconfig_notifier(); do_initcalls();// init/main.c for (level = 0; level ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level); for (fn = initcall_levels[level]; fn initcall_levels[level+1]; fn++) do_one_initcall(*fn);//此处调用相关模块的初始化其中，struct device platform_bus = .init_name = platform,; static const struct dev_pm_ops platform_dev_pm_ops = .runtime_suspend = pm_generic_runtime_suspend, .runtime_resume = pm_generic_runtime_resume, USE_PLATFORM_PM_SLEEP_OPS; struct bus_type platform_bus_type = .name = platform, .dev_groups = platform_dev_groups, .match = platform_match, .uevent = platform_uevent, .pm = platform_dev_pm_ops,;c //向系统注册一个设备int device_register(struct device *dev) device_initialize(dev)//初始化设备结构体成员 device_add(dev);//通过调用kobject_add()将设备对象添加到系统中，加入到设备链表//初始化设备结构体成员void device_initialize(struct device *dev) dev-kobj.kset = devices_kset; kobject_init(dev-kobj, device_ktype); INIT_LIST_HEAD(dev-dma_pools); mutex_init(dev-mutex); lockdep_set_novalidate_class(dev-mutex); spin_lock_init(dev-devres_lock); INIT_LIST_HEAD(dev-devres_head); device_pm_init(dev); set_dev_node(dev, -1);#ifdef CONFIG_GENERIC_MSI_IRQ INIT_LIST_HEAD(dev-msi_list);#endif INIT_LIST_HEAD(dev-links.consumers); INIT_LIST_HEAD(dev-links.suppliers); dev-links.status = DL_DEV_NO_DRIVER;int device_add(struct device *dev) dev = get_device(dev); error = device_private_init(dev); dev_set_name(dev, %s, dev-init_name); parent = get_device(dev-parent); kobj = get_device_parent(dev, parent); set_dev_node(dev, dev_to_node(parent)); error = kobject_add(dev-kobj, dev-kobj.parent, NULL); ..... int bus_register(struct bus_type *bus) int retval; struct bus_type_private *priv; // 定义一个bus_type_private 结构体指针 priv = kzalloc(sizeof(struct bus_type_private), GFP_KERNEL); // 申请分配内存 if (!priv) return -ENOMEM; priv-bus = bus; // 使用 priv-bus 指向我们传进来的bus bus-p = priv; // 通过 bus-p 指向priv 这里其实就是将bus与priv建立关系，这个跟之前的evice、class的设计是一样的 BLOCKING_INIT_NOTIFIER_HEAD(priv-bus_notifier); retval = kobject_set_name(priv-subsys.kobj, %s, bus-name); // 给我们的bus在设备驱模型中的对象设置名字 bus-p-subsys.kobj if (retval) goto out; // 这里就是对bus的私有数据进行一些填充 priv-subsys.kobj.kset = bus_kset; // 设置bus对象的父对象 也就是 /sys/bus 这目录 作为他的上层目录 所有的具体的总线类型对象都是在这个目录下 priv-subsys.kobj.ktype = bus_ktype; // 设置bus对象的 对象类型为 bus_ktype priv-drivers_autoprobe = 1; // 配置为在注册设备或者是注册设备驱动时自动进行配置 这个就决定为什么我们在注册设备或者是设备驱动能够进行自动匹配 retval = kset_register(priv-subsys); // 注册kset结构体(内部会调用kobject_add_internal函数，也就是将bus对象添加到 /sys/bus/目录下， /sys/bus/xxx_busType 对应具体的总线) if (retval) goto out; retval = bus_create_file(bus, bus_attr_uevent); // 在该bus下建立属性文件 (对应的就是 bus下的 uevent属性) if (retval) goto bus_uevent_fail; priv-devices_kset = kset_create_and_add(devices, NULL, // 在具体总线的目录下创建 kset 容器对象 /sys/bus/xxx_busType/devices priv-subsys.kobj); // 通过priv-devices_kset指针去指向 这个目录对应的对象 if (!priv-devices_kset) retval = -ENOMEM; goto bus_devices_fail; priv-drivers_kset = kset_create_and_add(drivers, NULL, // /sys/bus/xxx_busType /drivers priv-subsys.kobj); // 通过 priv-drivers_kset 指针去指向 这个目录对应的对象 if (!priv-drivers_kset) retval = -ENOMEM; goto bus_drivers_fail; klist_init(priv-klist_devices, klist_devices_get, klist_devices_put); // 初始化链表 klist klist_init(priv-klist_drivers, NULL, NULL); // 初始化链表 klist retval = add_probe_files(bus); // 添加探针文件 其实内部做的还是添加属性文件 /sys/bus/xxx_busType/drivers_probe /sys/bus/xxx_busType/drivers_autoprobe if (retval) goto bus_probe_files_fail; retval = bus_add_attrs(bus); // 根据 bus-bus_attrs 中的属性设置来添加属性文件 if (retval) goto bus_attrs_fail; pr_debug(bus: %s: registered , bus-name); return 0; bus_attrs_fail: remove_probe_files(bus); bus_probe_files_fail: kset_unregister(bus-p-drivers_kset); bus_drivers_fail: kset_unregister(bus-p-devices_kset); bus_devices_fail: bus_remove_file(bus, bus_attr_uevent); bus_uevent_fail: kset_unregister(bus-p-subsys); kfree(bus-p); out: bus-p = NULL; return retval; 参考：​ 设备树和Platform架构–4–platform bus概述及其初始化-CSDN博客","tags":["linux","platform"],"categories":["驱动"]},{"title":"pkg-config 了解","path":"/2025/08/18/pkg-config/","content":"pkg-config 了解开源库的编译链接参数管理神器 pkg-config是LinuxUnix 系统下用于管理开源库编译和链接参数的命令行工具，核心作用是自动化解析库的元数据（安装路径、依赖关系、编译 链接参数），避免开发者手动输入冗长的-I（头文件路径）、-L（库路径）、-l（库名）参数，同时解决库的依赖链传递问题。 pkg-config原理 查找 .pc 配置文件 而.pc配置文件路径一般位于： 环境变量PKG_CONFIG_PATH用户自定义路径（如手动安装的库放在usrlocallibpkgconfig） 系统架构相关路径如usrlibx86_64-linux-gnupkgconfig（DebianUbuntu 系） 系统全局路径如usrlibpkgconfig、usrsharepkgconfig 可通过pkg-config –variable pc_path pkg-config查看当前的搜索路径 递归解析 .pc 配置文件 输出最终的编译链接参数 pc文件语法规范 变量定义：VARvalue（如prefixusr） 变量引用：${VAR}（如includedir${prefix}include） 注释：以#开头（无多行注释，需每行加#） 多行内容：行尾加\\（如依赖项过长时换行） 依赖版本：库名 版本号（支持） 举例解释以gtk+-3.0.pc内容为例，文件路径：/usr/lib/x86_64-linux-gnu/pkgconfig/gtk+-3.0.pc prefix=/usrexec_prefix=$prefixlibdir=/usr/lib/x86_64-linux-gnuincludedir=$prefix/includetargets=x11 broadway waylandgtk_binary_version=3.0.0gtk_host=x86_64-pc-linux-gnuName: GTK+Description: GTK+ Graphical UI LibraryVersion: 3.24.33Requires: gdk-3.0 atk = 2.32.0 cairo = 1.14.0 cairo-gobject = 1.14.0 gdk-pixbuf-2.0 = 2.30.0 gio-2.0 = 2.57.2Requires.private: atk atk-bridge-2.0 wayland-client = 1.14.91 xkbcommon = 0.2.0 wayland-cursor = 1.14.91 wayland-egl epoxy = 1.4 fribidi = 0.19.7 pangoft2 gio-unix-2.0 = 2.57.2Libs: -L$libdir -lgtk-3 Cflags: -I$includedir/gtk-3.0 基础路径prefix=/usrexec_prefix=$prefixlibdir=/usr/lib/x86_64-linux-gnuincludedir=$prefix/includetargets=x11 broadway wayland 上述内容描述了gtk安装的一些信息： prefix： 根安装目录前缀为usr exec_prefix: 可执行文件前缀。通常继承prefix，仅当库的可执行文件和库文件分离时才单独设置（如usrlocalbin和usrlocallib） libdir：库文件路径为usrlibx86_64-linux-gnu includedir： 头文件根路径，后续会通过Cflags追加具体的子目录 targets： 支持的窗口系统目标 版本与平台信息gtk_binary_version=3.0.0gtk_host=x86_64-pc-linux-gnuName: GTK+Description: GTK+ Graphical UI LibraryVersion: 3.24.33 gtk_binary_version: GTK + 二进制兼容版本即SOVERSION（共享库版本），是 Linux 共享库的核心机制：系统中实际的库文件是libgtk-3.so.0（或libgtk-3.so.3.24.33）3.0.0表示：主版本 3，次版本 0，修订版 0—— 只要主版本不变，共享库就保持二进制兼容（程序编译时链接libgtk-3.so，运行时可加载任何兼容的版本） gtk_host: 构建主机的三元组格式为架构-厂商-系统，是 autotools（autoconfautomake） 的标准标识：x86_64：CPU 架构pc：厂商（pc 表示通用个人计算机）linux-gnu：系统（Linux+GNU 工具链）用于交叉编译时识别目标平台（如编译 ARM 架构的 GTK + 程序时，该值会变为arm-linux-gnueabihf） Name: pkg-config 查询名必须唯一，是pkg-config的核心查询标识（如pkg-config –cflags gtk+-3.0中的gtk+-3.0） Version: 库的发布版本 依赖项配置公共依赖（Requires）：程序必须依赖的库 Requires: gdk-3.0 atk = 2.32.0 cairo = 1.14.0 cairo-gobject = 1.14.0 gdk-pixbuf-2.0 = 2.30.0 gio-2.0 = 2.57.2 定义：使用 GTK + 的程序在编译和运行时都依赖的库，这些库的符号会被 GTK + 暴露给上层程序，因此程序必须链接这些库私有依赖（Requires.private）：GTK + 内部依赖的库 Requires.private: atk atk-bridge-2.0 wayland-client = 1.14.91 xkbcommon = 0.2.0 wayland-cursor = 1.14.91 wayland-egl epoxy = 1.4 fribidi = 0.19.7 pangoft2 gio-unix-2.0 = 2.57.2 定义：GTK + 库自身内部使用的库，这些库的符号不会暴露给上层程序，因此程序不需要直接链接（但静态链接时需要）核心设计逻辑：动态链接时：程序只需要链接libgtk-3.so，libgtk-3.so已经内部链接了这些私有依赖库，因此程序无需关心。静态链接时：需要将这些私有依赖库一起链接（pkg-config 的–static参数会自动处理）。 编译与链接参数Libs: -L$libdir -lgtk-3 Cflags: -I$includedir/gtk-3.0 这部分是直接的编译 链接参数，但实际使用时 pkg-config 会递归合并所有依赖库的参数(1) Libs（链接参数）• 字面含义：-Lusrlibx86_64-linux-gnu（指定库路径） + -lgtk-3（链接 libgtk-3.so）。• 实际输出：执行pkg-config –libs gtk+-3.0时，会递归解析Requires中的所有库（如 gdk-3.0）的 Libs 参数，最终输出的参数包含所有依赖库的链接路径和库名，例如： -L/usr/lib/x86_64-linux-gnu -lgtk-3 -lgdk-3 -lpangocairo-1.0 -lpango-1.0 -lharfbuzz -latk-1.0 -lcairo-gobject -lcairo -lgdk_pixbuf-2.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0 (2) Cflags（编译参数）• 字面含义：-Iusrincludegtk-3.0（指定 GTK + 头文件路径）。• 实际输出：执行pkg-config –cflags gtk+-3.0时，会递归解析Requires中的所有库的 Cflags 参数，最终输出的参数包含所有依赖库的头文件路径，例如： -I/usr/include/gtk-3.0 -I/usr/include/at-spi2-atk/2.0 -I/usr/include/at-spi-2.0 -I/usr/include/dbus-1.0 常用命令与示例以下均以gtk+-3.0为例（对应你提供的.pc文件）： (1) 基础：获取编译 + 链接参数（最常用）# 同时输出编译参数和链接参数pkg-config --cflags --libs gtk+-3.0 (2) 单独获取编译参数（Cflags）pkg-config --cflags gtk+-3.0# 输出：头文件路径（包括所有依赖库的头文件） (3) 单独获取链接参数（Libs）pkg-config --libs gtk+-3.0# 输出：库路径、库名（包括所有依赖库的链接参数） (4) 查看库的版本# 查看当前安装的库版本pkg-config --modversion gtk+-3.0# 输出：3.24.33（对应你.pc文件中的Version字段）# 查看pkg-config自身版本pkg-config --version (5) 版本校验# 检查库是否存在（返回0表示存在，非0表示不存在）pkg-config --exists gtk+-3.0echo $? # 输出0# 检查库版本是否≥3.20（返回0表示满足）pkg-config --atleast-version=3.20 gtk+-3.0echo $? # 输出0# 检查库版本是否≤3.25（返回0表示满足）pkg-config --max-version=3.25 gtk+-3.0echo $? # 输出0# 检查库版本是否等于3.24.33（返回0表示满足）pkg-config --exact-version=3.24.33 gtk+-3.0echo $? # 输出0 (6) 查看库的元数据# 查看库的描述信息pkg-config --describe-package gtk+-3.0# 输出：GTK+ Graphical UI Library (3.24.33)# 查看库的所有依赖（公共依赖）pkg-config --print-requires gtk+-3.0# 输出：gdk-3.0 atk cairo cairo-gobject gdk-pixbuf-2.0 gio-2.0# 查看库的私有依赖pkg-config --print-requires-private gtk+-3.0# 输出：atk atk-bridge-2.0 wayland-client ...# 递归查看所有依赖（包括依赖的依赖）pkg-config --print-requires --recursive gtk+-3.0 (7) 态链接参数（–static）当需要静态链接库时，需添加--static参数，pkg-config会自动包含私有依赖（Requires.private）的链接参数： pkg-config --cflags --libs --static gtk+-3.0 高级用法1. 自定义.pc文件路径如果手动安装的库放在/opt/gtk，其.pc文件在/opt/gtk/lib/pkgconfig，可通过PKG_CONFIG_PATH指定路径： # 临时生效（当前终端）export PKG_CONFIG_PATH=/opt/gtk/lib/pkgconfig:$PKG_CONFIG_PATH# 永久生效（添加到~/.bashrc或/etc/profile）echo export PKG_CONFIG_PATH=/opt/gtk/lib/pkgconfig:$PKG_CONFIG_PATH ~/.bashrcsource ~/.bashrc 2. 交叉编译时的使用交叉编译（如 x86_64 编译 ARM 架构程序）时，需指定交叉编译的.pc文件路径： # 假设ARM库的.pc文件在/opt/arm-linux-gnueabihf/lib/pkgconfigexport PKG_CONFIG_PATH=/opt/arm-linux-gnueabihf/lib/pkgconfigexport PKG_CONFIG_LIBDIR=/opt/arm-linux-gnueabihf/lib/pkgconfig # 覆盖系统默认路径（可选）# 此时pkg-config会解析ARM架构的库参数pkg-config --cflags --libs gtk+-3.0 3. 与建工具集成(1) Makefile 中使用# 定义变量CFLAGS := $(pkg-config --cflags gtk+-3.0)LDFLAGS := $(pkg-config --libs gtk+-3.0)# 编译规则my_gtk_app: main.c\tgcc main.c -o my_gtk_app $(CFLAGS) $(LDFLAGS) (2) CMake 中使用# 查找pkg-configfind_package(PkgConfig REQUIRED)# 查找gtk+-3.0库pkg_check_modules(GTK3 REQUIRED gtk+-3.0)# 包含头文件路径include_directories($GTK3_INCLUDE_DIRS)# 链接库link_directories($GTK3_LIBRARY_DIRS)add_executable(my_gtk_app main.c)target_link_libraries(my_gtk_app $GTK3_LIBRARIES)# 添加编译宏add_definitions($GTK3_CFLAGS_OTHER)","tags":["linux","pkg-config"],"categories":["嵌入式"]},{"title":"通过platform实现LED设备驱动一些基础知识","path":"/2025/08/18/platform的LED设备驱动一些基础知识(未完成)/","content":"通过platform实现LED设备驱动一些基础知识首先要知道一个字符设备驱动的流程为：分配file_operations结构体，设置file_operations结构体，注册file_operations结构体。具体来说就是：1.确定一个主设备号，2.定义自己的file_operations结构体，3.实现file_operations结构体中的openwirteread函数，4.把file_operations结构体告诉内核，即注册file_operations结构体，5.实现入口函数，在这个入口函数中注册file_operations结构体。 首先要区分：设备号(devid)，主设备号(major)，次设备号(minor)主设备号：用于标识不同的驱动程序 次设备号：用于区分同一主设备号下的不同设备实例。 设备号：内核设备的唯一标识符。是主设备号和次设备号的组合，通过MKDEV(major,minor)宏生成。 三者之间的关系： 设备号devid通过devid=MKDEV(marjor,minor)获得 主设备号major通过marjor=MAJOR(devid)获得 次设备号minor通过minor=MINOR(devid)获得 举例1：动态分配设备号 通过alloc_chrdev_region获得设备号，使用MAJOR和MINOR得到主设备号major和次设备号MINOR class_create会在sysclass下创建一个名为“GPIO_NAME”的类 根据设备号devid，通过device_create()创建GPIOLED_NAME设备 。会在sysclassGPIO_NAME的类下面再创建一个名为GPIO_NAME的设备节点。同样该节点在devGPIO_NAME中，应用程序可以open打开这个设备 alloc_chrdev_region(gpioled.devid, 0, GPIOLED_CNT, GPIOLED_NAME);gpioled.major = MAJOR(gpioled.devid);gpioled.minor = MINOR(gpioled.devid);.../* 4、创建类 */gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME);/* 5,创建设备 */gpioled.device = device_create(gpioled.class, NULL, gpioled.devid, NULL, GPIOLED_NAME); 举例2：分配设备号 通过register_chrdev注册lfile_operation结构体，得到主设备号 再使用MKDEV(major,i)得到设备号devid，根据devid创建100ask_led0等设备 major = register_chrdev(0, 100ask_led, led_drv); /* /dev/100ask_led */led_class = class_create(THIS_MODULE, 100ask_led_class);for (i = 0; i LED_NUM; i++)device_create(led_class, NULL, MKDEV(major, i), NULL, 100ask_led%d, i); /* /dev/100ask_led0,1,... */ 再来看下如何分配设备号：设备号的分配可以分为动态分配和静态分配。 静态分配函数原型：static inline int regiser_chrdev(unsigned int major,const char *name,const struct file_operations* fops) 使用示例：major = register_chrdev(0, 100ask_led, led_drv); 参数： major:主设备号，一般为0，让系统自动分配一个未使用的主设备号 name:名字，可以通过cat procdevices查看 fops:需要注册的file_operations结构体 返回值：成功则返回主设备号 动态分配函数原型：int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) 使用示例：alloc_chrdev_region(gpioled.devid, 0, GPIOLED_CNT, GPIOLED_NAME); 参数： dev:用于保存申请到的设备号，dev_t为unsigned int 类型数据 baseminor:次设备号的起始地址，一般为0表示次设备号从0开始 count:需要申请的设备号数量，一般为1 name:设备名字，同register_chrdev一样，可以在procdevices查看 返回值： 成功返回 如果给定了设备的主设备号和次设备号，使用register_chrdev_region函数原型：int register_chrdev_region(dev_t from, unsigned count, const char *name) 动态分配设备号下注册字符设备驱动静态分配不仅分配了设备号，还直接完成了字符设备file_operations的注册，但是会占据主设备号下面的所有次设备号。 动态分配仅仅分配了字符设备的设备号(devid)，需要配合cdev_init和cdev_add将设备和文件操作绑定。在分析cdev_init和cdev_add之前，先来看看cdev结构体有哪些成员 cdev结构体：struct cdev struct kobject kobj;\tstruct module *owner;\tconst struct file_operations *ops;\tstruct list_head list;\tdev_t dev; //设备号\tunsigned int count;; 其中dev_t dev就是设备号，file_operations *ops就是最重要的那个设备文件操作结构体指针，一般包括以下内容，这里仅作为示例： static const struct file_operations led_fops = .owner =\tTHIS_MODULE,\t.write =\tled_write,\t.open =\tled_open,\t.release\t=\tled_release,; cdev_init定义好cdev变量之后，cdev_add用于向Linux系统添加字符设备(cdev结构体)，但在使用cdev_add之前需要先对cdev结构体变量进行初始化，cdev_init函数原型如下： void cdev_init(struct cdev* cdev,const struct file_operations *fops) 参考示例： cdev_init(gpioled.cdev, led_fops); 参数： cdev:cdev就是要进行初始化的cdev结构体变量 fops:就是我们一直提到的file_operations结构体，通过cdev_init将cdev和file_operations绑定 cdev_add对cdev初始化之后就可以通过cdev_add向linux系统中添加这个字符设备。cdev_add原型为： int cdev_add(struct cdev *p,dev_t dev,unsigned count) 参考示例： cdev_add(gpioled.cdev, gpioled.devid, GPIOLED_CNT); 参数： p:指向cdev指针 dev:显示传入的设备号，应该会将devid(通过alloc_chrdev_region)保存到cdev-dev(设备号)中 count:要添加的设备的数量 以上便实现了一个字符设备驱动的大部分内容了：包括确定主设备号(动态分配和静态分配)，定义自己的file_operations结构体，3.实现file_operations结构体中的openwirteread函数(没写出细节)，4.把file_operations结构体告诉内核，即注册file_operations结构体(静态注册register_chrdev，cdev_add)，5.实现入口函数(实际上上述所有案例代码都位于init函数或者probe函数中) 设备树 在根节点下创建gpioled gpioled 18 #address-cells = 1; 19 #size-cells = 1; 20 compatible = atkalpha-gpioled; 21 pinctrl-names = default; 22 pinctrl-0 = pinctrl_leds; 23 led-gpio = gpio5 3 GPIO_ACTIVE_LOW; 24 status = okay; 25 ; 在imx6ul-evk下创建pinctrl_leds节点 pinctrl_leds: ledgrp 738 fsl,pins = 739 MX6ULL_PAD_SNVS_TAMPER3__GPIO5_IO03 0x000110A0740 ;741 ; 看几个重要的结构体 cdev再看一遍，实际上只用到了owner，其他暂时未用到 struct cdev struct kobject kobj;\tstruct module *owner;\tconst struct file_operations *ops;\tstruct list_head list;\tdev_t dev;\tunsigned int count;; 再看class这个庞大的结构体,反正就是通过gpioled.class class_create(THIS_MODULE, GPIOLED_NAME);创建了一个类，啥也没设置，类下边有很多的成员，同样也有owner name啥的。在class结构体前，可以看到这样的一句话： * A class is a higher-level view of a device that abstracts out low-level* implementation details. Drivers may see a SCSI disk or an ATA disk, but,* at the class level, they are all simply disks. Classes allow user space* to work with devices based on what they do, rather than how they are* connected or how they work. 翻译过来大概就是：类是设备的更高的视角，类抽象出了低层次的实现细节。比如，驱动程序会区分SCSI磁盘和ATA磁盘，但是在类看来，他们都是简单的磁盘。类允许用户空间根据他们的功能进行使用，而不是设备的连接方式和工作方式。 struct class const char *name;\tstruct module *owner;\tstruct class_attribute *class_attrs;\tconst struct attribute_group\t**dev_groups;\tstruct kobject *dev_kobj;...省略一些函数\tconst struct dev_pm_ops *pm;\tstruct subsys_private *p;; device结构体也是一个庞大的结构体，gpioled.device device_create(gpioled.class, NULL, gpioled.devid, NULL, GPIOLED_NAME); platform_device结构体 struct platform_device const char\t*name;//会在/sys/devices/platform/name中表现出来\tint id;\tbool id_auto;\tstruct device\tdev;\tu32 num_resources;\tstruct resource\t*resource;\tconst struct platform_device_id\t*id_entry;\tchar *driver_override; /* Driver name to force a match */\t/* MFD cell pointer */\tstruct mfd_cell *mfd_cell;\t/* arch specific additions */\tstruct pdev_archdata\tarchdata;; platform_driver - device_driver- 代码源码在nfs_rootfsmyled_driver目录下","tags":["linux","platform","LED"],"categories":["驱动"]},{"title":"dw-spi-mmio控制器驱动","path":"/2025/08/18/spi子系统dw控制器probe过程/","content":"dw-spi-mmio控制器驱动需要知道：SPI大致分为了以下三个层次，分别是SPI核心，SPI控制器驱动，SPI设备驱动。 SPI核心层代码位于kernel/include/linux/spi/spi.h和kernel/drivers/spi/spi.c，核心层提供了SPI总线驱动和设备驱动的注册，注册方法，并提供一些控制器驱动实现的回调函数。核心层包含一些重要的结构体，struct spi_controller,struct spi_transfer,struct spi_message等。 控制器驱动就是本文核心。主要实现SPI硬件数据收发功能，只有这样，挂接在SPI总线上的SPI设备才能通过SPI控制器读写数据并与CPU进行数据交互。 SPI设备驱动一般挂接在受CPU控制的SPI控制器上，通过SPI控制器与CPU进行数据交互。 graph TD subgraph 用户空间层 U3[应用程序] end subgraph 内核空间层 K4[SPI设备驱动] K3[SPI设备驱动] K2[SPI核心] K1[SPI控制器驱动] end subgraph 硬件层 H1[SPI控制器] H2[SPI设备1] H3[SPI设备2] end U3 -- K4 U3 -- K3 K4 -- K2 K3 -- K2 K2 -- K1 K1 -- H1 H1 -- H2 H1 -- H3 设备树配置spi0: spi@f0383000 compatible = snps,dw-apb-ssi; status = disabled; interrupt-parent = gic; interrupts = GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH; reg = 0x0 0xf0383000 0x0 0x1000; reg-io-width = 4; num-cs = 1; dmas = dw_axi_dmac 0x1 0 0 dw_axi_dmac 0x0 0 0; dma-names = tx, rx;;spi0 status = disabled;\t#address-cells = 1;\t#size-cells = 0;\t// pinctrl-names = default;\t// pinctrl-0 = spi0_pinctrl gpiob1_pinctrl;\tcs-gpios = portb 1 GPIO_ACTIVE_LOW;\tspi0_flash0: wnbnd0@0 compatible = jedec,spi-nor; spi-max-frequency = 400000; reg = 0; #address-cells = 1; #size-cells = 1; partition@spi-test0 label = test0; reg = 0x0 0x800000; /* 8MB */ ;\t;; spi0控制器下挂载了spi0_flash的flash。 spi0控制器对应的文件为：kernel/drivers/spi/spi-dw-mmio.c 与dw相关的驱动文件还有kerneldriversspispi-dw-core.c kerneldriversspispi-dw-dma.c spi0_flash0对应的驱动文件为：kernel/drivers/mtd/devices/m25p80.c 与flash相关的重要驱动文件有kerneldriversmtdspi-norspi-nor.c，实现了spi_nor_scan，spi_nor_setup。在spi-nor.h中只有spi_nor_scan开放出来了，因此这个函数需要重点分析 关于片选引脚： 在spi_device中有成员：chip_select，表示spi_master下的第几个设备 在spi_controller中有一个cs_gpios数组，里面存放有下面各个spi设备的片选引脚 spi_device的片选引脚就是：cs_gpios[spi_device.chip_select] 在spi_device中cs_gpio是可选项，也可以把spi_device的片选引脚记录在这里 在spi_controller中的是cs_gpios数组 SPI控制器驱动spi-dw-mimo.c注册的是平台驱动 SPI 控制器驱动（platform 驱动类型），负责匹配设备树中的 SPI 控制器节点（spi@f0383000） static const struct of_device_id dw_spi_mmio_of_match[] = .compatible = snps,dw-apb-ssi, .data = dw_spi_dw_apb_init, /* end of table */; compatible字段：这是匹配的 “关键字”，与设备树中控制器节点的compatible属性完全对应。设备树中spi@f0383000的compatible = snps,dw-apb-ssi，与第一个条目匹配。 .data字段：可选的附加数据，这里指向dw_spi_dw_apb_init函数，用于初始化该类型控制器的特定参数（这里实现的是DMA配置实现) static struct platform_driver dw_spi_mmio_driver = .probe = dw_spi_mmio_probe, // 设备匹配成功后执行的初始化函数\t.remove = dw_spi_mmio_remove, // 设备移除时执行的清理函数\t.driver = .name\t= DRIVER_NAME, // 驱动名称（辅助匹配，优先级低于compatible） .of_match_table = dw_spi_mmio_of_match, // 关联设备树匹配表 .acpi_match_table = ACPI_PTR(dw_spi_mmio_acpi_match), // 关联ACPI匹配表（用于非设备树系统） .pm = SPI_DEV_PM_OPS, // 电源管理操作集\t,; SPI 控制器是直接挂在 CPU 总线上的设备（如 APB 总线），属于platform设备类型（内核对 “挂在总线上的设备” 的抽象），因此其驱动需用platform_driver结构体进行注册 SPI从设备驱动SPI 从设备驱动（spi_driver 类型），负责匹配 SPI 总线上的从设备（即wnbnd0@0 flash） 这里只列出通过spi总线访问nor flash的情况，对于通过qspi控制器访问nor flash暂时还没细看 static struct spi_driver m25p80_driver = .driver = .name\t= m25p80, // 驱动名称 .of_match_table = m25p_of_table, // 关联设备树匹配表\t,\t.id_table\t= m25p_ids, // 基于SPI设备名称的匹配表（旧方式，优先级低于of_match_table）\t.probe\t= m25p_probe, // 设备匹配成功后执行的初始化函数\t.remove\t= m25p_remove, // 设备移除时的清理函数; SPI 闪存是挂在 SPI 总线上的从设备，属于spi设备类型（内核对 “SPI 总线上的设备” 的抽象），因此其驱动需用spi_driver结构体 id_table的作用：早期没有设备树时，通过 SPI 设备的name字段匹配（如name = m25p80），现在主要用于兼容旧设备，优先级低于of_match_table 设备与驱动的匹配流程（结合设备树） 内核启动时扫描设备树：解析spi@f0383000（控制器）和wnbnd0@0（闪存）节点，分别创建platform_device（控制器设备）和spi_device（闪存设备）结构体，其中包含节点的compatible属性。 驱动加载时注册匹配信息： spi-dw-mmio.ko加载后，通过platform_driver_register()注册dw_spi_mmio_driver，内核将其of_match_table加入全局设备树匹配表。 m25p80.ko加载后，通过spi_register_driver()注册m25p80_driver，内核将其of_match_table加入全局设备树匹配表。 匹配过程： 对于spi@f0383000（platform 设备）：内核遍历所有platform_driver，发现dw_spi_mmio_driver的of_match_table中compatible = snps,dw-apb-ssi与设备一致，触发dw_spi_mmio_probe()初始化控制器。 对于wnbnd0@0（spi 设备）：内核遍历所有spi_driver，发现m25p80_driver的of_match_table中compatible = jedec,spi-nor与设备一致，触发m25p_probe()初始化闪存。 匹配成功后：控制器驱动初始化 SPI 硬件，设备驱动通过 SPI 核心层接口（如spi_sync()）与控制器交互，完成数据传输。 SPI DW控制器驱动probe解析当设备树中的spi节点被解析为paltform_device之后，会与platform_driver.driver-of_device_id中的compatible属性进行match，匹配成功后则会调用probe函数 static const struct of_device_id dw_spi_mmio_of_match[] = .compatible = snps,dw-apb-ssi, .data = dw_spi_dw_apb_init, /* end of table */;MODULE_DEVICE_TABLE(of, dw_spi_mmio_of_match); probe函数调用关系dw_spi_mmio_probe\t//分配dw_spi_mmio结构体\tstruct dw_spi_mmio *dwsmmio = devm_kzalloc(pdev-dev, sizeof(struct dw_spi_mmio),GFP_KERNEL);\t//获取寄存器资源 并赋值给paddr\tstruct resource *mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\tdwsmmio-dws.paddr = mem-start;\t//进行地址ioremap，并与spi device进行绑定\tdwsmmio-dws.regs = devm_ioremap_resource(pdev-dev, mem);\t//设置中断\tdwsmmio-dws.irq = platform_get_irq(pdev, 0);\t//获取时钟\tdwsmmio-clk = devm_clk_get(pdev-dev, NULL);\tdwsmmio-pclk = devm_clk_get(pdev-dev, pclk);//optional\tdwsmmio-dws.max_freq = clk_get_rate(dwsmmio-clk);\t//获取复位控制器\tdwsmmio-rstc = devm_reset_control_get_optional_exclusive(pdev-dev,spi);\treset_control_deassert(dwsmmio-rstc); //获取设备树属性\tdevice_property_read_u32(pdev-dev, reg-io-width, dwsmmio-dws.reg_io_width);\tdevice_property_read_u32(pdev-dev, num-cs, dwsmmio-dws.num-cs); //获取总线num,id代表不同spi实例\tdwsmmio-dws.bus_num = pdev-id; //私有数据 获取struct of_device_id dw_spi_mmio_of_match[0] = // .compatible = snps,dw-apb-ssi, .data = dw_spi_dw_apb_init,\t//;中的data指针数据，这里是函数指针，指向dw_spi_dw_apb_init。该函数完成DMA的dma_ops操作集的实现配置\tinit_func = of_device_get_match_data(pdev-dev);\tret = init_func(pdev, dwsmmio); /*将dw_spi添加到 * 后续重点分析dw_spi_add_host*/\tret = dw_spi_add_host(pdev-dev, dwsmmio-dws); //将dwsmmio添加到device设备的driver_data中，以共供后续使用\tplatform_set_drvdata(pdev, dwsmmio); dma_ops操作集初始化完成DMA的dma_ops操作集的实现配置，文件位置在kernel/drivers/spi/spi-dw-dma.c可以通过标志位配置是否使用dma传输。 init_func = of_device_get_match_data(pdev-dev);\tret = init_func(pdev, dwsmmio);\t==static int dw_spi_dw_apb_init(pdev,dwsmmio) static int dw_spi_dw_apb_init(struct platform_device *pdev, struct dw_spi_mmio *dwsmmio)\tdw_spi_dma_setup_generic(dwsmmio-dws);\treturn 0;static const struct dw_spi_dma_ops dw_spi_dma_generic_ops = .dma_init\t= dw_spi_dma_init_generic,\t.dma_exit\t= dw_spi_dma_exit,\t.dma_setup\t= dw_spi_dma_setup,\t.can_dma\t= dw_spi_can_dma,\t.dma_transfer\t= dw_spi_dma_transfer,\t.dma_stop\t= dw_spi_dma_stop,;void dw_spi_dma_setup_generic(struct dw_spi *dws)\tdws-dma_ops = dw_spi_dma_generic_ops;EXPORT_SYMBOL_GPL(dw_spi_dma_setup_generic); SPI DW控制器驱动add_host解析ret = dw_spi_add_host(pdev-dev, dwsmmio-dws);dw_spi_add_host\t//分配spi_master结构体\tdws-master = spi_alloc_master(dev, 0); //设置DMA寄存器偏移地址\tdws-dma_addr = (dma_addr_t)(dws-paddr + DW_SPI_DR);\t/* Restart the controller, disable all interrupts, clean rx fifo */\tspi_hw_init(dev, dws);\t//请求中断\tret = request_irq(dws-irq, dw_spi_irq, IRQF_SHARED, dev_name(dev),master); //初始化memory operations成员\tdw_spi_init_mem_ops(dws); //初始化其他成员\tdws-master-mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;\tdws-master-bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\tdws-master-bus_num = dws-bus_num;\tdws-master-num_chipselect = dws-num_cs;\tdws-master-setup = dw_spi_setup;\tdws-master-cleanup = dw_spi_cleanup;\t//控制片选信号（硬件片选或 GPIO 模拟）\tif (dws-set_cs) dws-master-set_cs = dws-set_cs;//GPIO模拟 走这个分支？!\telse dws-master-set_cs = dw_spi_set_cs;//硬件片选 dws-master-transfer_one = dw_spi_transfer_one;\tdws-master-handle_err = dw_spi_handle_err;\tif (dws-mem_ops.exec_op)//1 dws-master-mem_ops = dws-mem_ops;\tdws-master-max_speed_hz = dws-max_freq;\tdws-master-dev.of_node = dev-of_node;\tdws-master-dev.fwnode = dev-fwnode;\tdws-master-flags = SPI_MASTER_GPIO_SS;//使用GPIO片选标志？\tdws-master-auto_runtime_pm = true;\tdevice_property_read_u32(dev, rx-sample-delay-ns,dws-def_rx_sample_dly_ns);\t// DMA支持：若驱动实现了DMA操作函数（dma_ops）,则调用dma_init初始化DMA通道\t// dma_ops是在probe的init_func进行实现的\tif (dws-dma_ops dws-dma_ops-dma_init) ret = dws-dma_ops-dma_init(dev, dws); if (ret) dev_warn(dev, DMA init failed ); else master-can_dma = dws-dma_ops-can_dma; master-flags |= SPI_CONTROLLER_MUST_TX; //注册将dws-master注册进spi controller中\tret = spi_register_controller(dws-master); //文件系统调试 dw_spi_debugfs_init(dws); //将dws与master绑定，后续驱动逻辑可通过dev_set/get_drvdata(master-dev) 和 spi_controller_get_devdata(master)访问硬件相关的私有配置（如寄存器基地址、中断号等等）\tspi_controller_set_devdata(master, dws); SPI DW控制器驱动dw_spi_transfer_one解析static int dw_spi_transfer_one(struct spi_controller *master, struct spi_device *spi, struct spi_transfer *transfer)\tstruct dw_spi *dws = spi_controller_get_devdata(master);\tstruct dw_spi_cfg cfg = .tmode = SPI_TMOD_TR, .dfs = transfer-bits_per_word, .freq = transfer-speed_hz,\t;\tint ret;\tdws-dma_mapped = 0;\tdws-n_bytes = DIV_ROUND_UP(transfer-bits_per_word, BITS_PER_BYTE);\tdws-tx = (void *)transfer-tx_buf;\tdws-tx_len = transfer-len / dws-n_bytes;\tdws-rx = transfer-rx_buf;\tdws-rx_len = dws-tx_len;\t/* Ensure the data above is visible for all CPUs */\tsmp_mb();\tspi_enable_chip(dws, 0);\tdw_spi_update_config(dws, spi, cfg);\t/* Check if current transfer is a DMA transaction */\tif (master-can_dma master-can_dma(master, spi, transfer)) dws-dma_mapped = master-cur_msg_mapped;\t/* For poll mode just disable all interrupts */\tspi_mask_intr(dws, 0xff);\t// DMA模式 对应设备树中 dmas 属性 if (dws-dma_mapped) // DMA 传输初始化 ret = dws-dma_ops-dma_setup(dws, transfer); if (ret) return ret; spi_enable_chip(dws, 1);\tif (dws-dma_mapped) // 优先 DMA 传输模式 return dws-dma_ops-dma_transfer(dws, transfer); // 轮询模式\telse if (dws-irq == IRQ_NOTCONNECTED) return dw_spi_poll_transfer(dws, transfer);\t// 默认中断传输模式\tdw_spi_irq_setup(dws);\treturn 1; dw_spi_transfer_one实现了SPI传输，有3种模式，DMA模式 poll轮询模式 中断传输模式。在ts芯片中优先使用DMA模式进行传输 SPI DW控制器驱动spi_register_controller解析int spi_register_controller(struct spi_controller *ctlr) //完成解析cs-gpios属性 status = of_spi_register_master(ctlr); for (i = 0; i nb; i++) cs[i] = of_get_named_gpio(ctlr-dev.of_node, cs-gpios, i);\t// if (ctlr-bus_num = 0) /* 用指定的总线号分配 id */ mutex_lock(board_lock); id = idr_alloc(spi_master_idr, ctlr, ctlr-bus_num, ctlr-bus_num + 1, GFP_KERNEL); mutex_unlock(board_lock); if (WARN(id 0, couldnt get idr)) return id == -ENOSPC ? -EBUSY : id; ctlr-bus_num = id; //核心数据初始化 INIT_LIST_HEAD(ctlr-queue); // 初始化传输请求队列 spin_lock_init(ctlr-queue_lock); // 保护传输队列的自旋锁 spin_lock_init(ctlr-bus_lock_spinlock); // 总线锁定的自旋锁 mutex_init(ctlr-bus_lock_mutex); // 总线锁定的互斥锁 mutex_init(ctlr-io_mutex); // I/O 操作互斥锁 ctlr-bus_lock_flag = 0; // 总线锁定状态标记 init_completion(ctlr-xfer_completion); // 传输完成量 if (!ctlr-max_dma_len) ctlr-max_dma_len = INT_MAX; // DMA 最大传输长度默认值\t//注册控制器为内核设备 dev_set_name(ctlr-dev, spi%u, ctlr-bus_num); // 设置设备名（如 spi0） status = device_add(ctlr-dev); // 注册到内核设备模型 if (status 0) /* 注册失败，释放总线号 */ mutex_lock(board_lock); idr_remove(spi_master_idr, ctlr-bus_num); mutex_unlock(board_lock); goto done; //传输队列初始化（驱动模式适配） if (ctlr-transfer) dev_info(dev, controller is unqueued, this is deprecated ); else status = spi_controller_initialize_queue(ctlr); if (status) device_del(ctlr-dev); /* 释放总线号 */ mutex_lock(board_lock); idr_remove(spi_master_idr, ctlr-bus_num); mutex_unlock(board_lock); goto done; /* 初始化统计信息锁 */ spin_lock_init(ctlr-statistics.lock); /* 将控制器添加到全局链表，并匹配板级设备 */ mutex_lock(board_lock); list_add_tail(ctlr-list, spi_controller_list); // 加入全局控制器链表 list_for_each_entry(bi, board_list, list) // 遍历板级设备信息 spi_match_controller_to_boardinfo(ctlr, bi-board_info); // 匹配设备 mutex_unlock(board_lock); of_register_spi_devices(ctlr); // 从设备树注册 SPI 从设备 即M25P80驱动 acpi_register_spi_devices(ctlr); // 从 ACPI 注册 SPI 从设备 SPI DW控制器注册从设备of_register_spi_devices 遍历控制器设备树节点的子节点（每个子节点代表一个 SPI 从设备），解析 compatible、reg（reg表示片选号，代表第几个spi设备，不是寄存器）、spi-max-frequency 等属性，自动创建 struct spi_device 并注册。 spi_register_controller\tof_register_spi_devices of_register_spi_device /* Alloc an spi_device */ spi = spi_alloc_device(ctlr); /* Select device driver */ rc = of_modalias_node(nc, spi-modalias,sizeof(spi-modalias)); rc = of_spi_parse_dt(ctlr, spi, nc); /* Register the new device */ rc = spi_add_device(spi); spi0 spi0_flash0: wnbnd0@0 compatible = jedec,spi-nor; spi-max-frequency = 1000000; reg = 0; #address-cells = 1; #size-cells = 1; partition@spi-test0 label = test0; reg = 0x0 0x800000; /* 8MB */ ;\t;; SPI从设备驱动(补充)针对上一节中SPI从设备驱动的具体补充。由于这个从设备既和spi总线有关，又和mtd子系统有关，同时又从属于spi-nor系统框架之下，因此要想搞明白需要花很大的时间。这里只是简单介绍一些查到的介绍。 前置知识mtd子系统MTD设备通常可分为四层 ，设备节点、MTD设备层、MTD原始设备层和硬件驱动层。 硬件驱动层主要文件位于 drivers/mtd/chips : CFI/jedec接口通用驱动 drivers/mtd/nand : nand通用驱动和部分底层驱动程序 drivers/mtd/maps : nor flash映射关系相关函数 drivers/mtd/spi-nor: nor flash底层驱动 MTD设备层主要文件位于 mtdchar.c : MTD字符设备接口相关实现 mtdblock.c : MTD块设备接口相关实现 设备节点位于/dev/mtdx和/dev/mtdblockX，分别是字符设备节点和块设备节点。两者一般是一一对应的，在物理上两者其实是同一个东西，但是在软件上是进行区分的，可以理解为他们是对同一分区的不同描述方法。 devmtdx:是mtdchar.c注册生成的，支持open,read,write,ioctl等。flash_erase, nanddump等都是对字符节点，通过read,write,ioctl等执行 对应mtdblock.c和mtd_blkdevs.c，是Flash驱动中用add_mtd_partitions()添加MTD设备分区，而生成的对应的块设备 MTD块设备驱动程序可以让flash器件伪装成块设备，实际上它通过把整块的erase block放到ram里面进行访问，然后再更新到flash，用户可以在这个块设备上创建通常的文件系统 对于MTD块设备，MTD设备层是不提供ioctl的实现方法的，不能使用nandwrite,flash_eraseall,flash_erase等工具去对devmtdblockN去进行操作 mtd-utils工具只能用与devmtdN的MTD字符设备 mount、umount命令只对devmtdblockN的MTD块设备有效 需要注意的是：MTD设备既非块设备也不是字符设备，但可以同时提供字符设备和块设备接口来操作它 spi-nor 系统框架SPI总线只能处理字节流，总线控制器的操作与所连接的特定设备无关。SPI控制器只知道发送或接收字节（Tx和Rx）。因此，我们定义一个新的分层方案，在该方案下，控制器驱动程序知道SPI NOR协议的操作码、寻址和其他细节。 内容越看越多，暂时就整理这么多吧。先把从设备驱动分析一下，mtd子系统和spi nor系统框架单独整理到一个新文件中。 重要结构体struct spi_norstruct spi_nor struct mtd_info mtd;//指向mtd_info结构体，所有的存储设备，都可以挂载到mtd子系统中\tstruct mutex lock;\tstruct device *dev;\tu32 page_size;//SPI NOR的页面大小\tu8 addr_width;// 地址字节数\tu8 erase_opcode;//用于擦除扇区的操作码\tu8 read_opcode;\tu8 read_dummy;\tu8 program_opcode;//program操作码 //spi_nor_protocol 1线 4线 8线\tenum spi_nor_protocol\tread_proto;//用于读取操作的SPI协议\tenum spi_nor_protocol\twrite_proto;//用于写操作的SPI协议\tenum spi_nor_protocol\treg_proto;//用于读\\写\\擦除操作的SPI协议\tbool sst_write_second;\tu32 flags;\tu8 cmd_buf[SPI_NOR_MAX_CMD_SIZE];\tint (*prepare)(struct spi_nor *nor, enum spi_nor_ops ops);\tvoid (*unprepare)(struct spi_nor *nor, enum spi_nor_ops ops);\tint (*read_reg)(struct spi_nor *nor, u8 opcode, u8 *buf, int len);\tint (*write_reg)(struct spi_nor *nor, u8 opcode, u8 *buf, int len);\tssize_t (*read)(struct spi_nor *nor, loff_t from, size_t len, u_char *read_buf);\tssize_t (*write)(struct spi_nor *nor, loff_t to, size_t len, const u_char *write_buf);\tint (*erase)(struct spi_nor *nor, loff_t offs);\tint (*flash_lock)(struct spi_nor *nor, loff_t ofs, uint64_t len);\tint (*flash_unlock)(struct spi_nor *nor, loff_t ofs, uint64_t len);\tint (*flash_is_locked)(struct spi_nor *nor, loff_t ofs, uint64_t len);\tvoid *priv;; 设备树匹配spi0 spi0_flash0: wnbnd0@0 compatible = jedec,spi-nor; spi-max-frequency = 1000000; reg = 0; #address-cells = 1; #size-cells = 1; partition@spi-test0 label = test0; reg = 0x0 0x800000; /* 8MB */ ;\t;; static const struct of_device_id m25p_of_table[] = /* * Generic compatibility for SPI NOR that can be identified by the * JEDEC READ ID opcode (0x9F). Use this, if possible. */ .compatible = jedec,spi-nor ,\t;static struct spi_driver m25p80_driver = .driver = .name\t= m25p80, // 驱动名称 .of_match_table = m25p_of_table, // 关联设备树匹配表\t,\t.id_table\t= m25p_ids, // 基于SPI设备名称的匹配表（旧方式，优先级低于of_match_table）\t.probe\t= m25p_probe, // 设备匹配成功后执行的初始化函数\t.remove\t= m25p_remove, // 设备移除时的清理函数; probe函数static int m25p_probe(struct spi_device *spi)\tstruct flash_platform_data\t*data;\tstruct m25p *flash;\tstruct spi_nor *nor;\tstruct spi_nor_hwcaps hwcaps = .mask = SNOR_HWCAPS_READ | SNOR_HWCAPS_READ_FAST | SNOR_HWCAPS_PP,\t;\tchar *flash_name;\tint ret;\tprintk(m25p80: %s , __func__);\tdata = dev_get_platdata(spi-dev);\tflash = devm_kzalloc(spi-dev, sizeof(*flash), GFP_KERNEL);\tif (!flash) return -ENOMEM;\tnor = flash-spi_nor;\t/* install the hooks */\tnor-read = m25p80_read;\tnor-write = m25p80_write;\tnor-write_reg = m25p80_write_reg;\tnor-read_reg = m25p80_read_reg;\tnor-dev = spi-dev;\tspi_nor_set_flash_node(nor, spi-dev.of_node);\tnor-priv = flash;\tspi_set_drvdata(spi, flash);\tflash-spi = spi;\tif (spi-mode SPI_RX_QUAD) hwcaps.mask |= SNOR_HWCAPS_READ_1_1_4; if (spi-mode SPI_TX_QUAD) hwcaps.mask |= (SNOR_HWCAPS_READ_1_4_4 | SNOR_HWCAPS_PP_1_1_4 | SNOR_HWCAPS_PP_1_4_4); else if (spi-mode SPI_RX_DUAL) hwcaps.mask |= SNOR_HWCAPS_READ_1_1_2; if (spi-mode SPI_TX_DUAL) hwcaps.mask |= SNOR_HWCAPS_READ_1_2_2; if (data data-name) nor-mtd.name = data-name;\t/* For some (historical?) reason many platforms provide two different * names in flash_platform_data: name and type. Quite often name is * set to m25p80 and then type provides a real chip name. * If thats the case, respect type and ignore a name. */\tif (data data-type) flash_name = data-type;\telse if (!strcmp(spi-modalias, spi-nor)) flash_name = NULL; /* auto-detect */\telse flash_name = spi-modalias;\tret = spi_nor_scan(nor, flash_name, hwcaps);\tif (ret) printk(%s %d ret:%d,__func__,__LINE__,ret); return ret; return mtd_device_register(nor-mtd, data ? data-parts : NULL, data ? data-nr_parts : 0); 可以按照顺序划分为以下几个部分 设置struct spi_nor结构体 设置struct spi_nor_hwcaps结构体 spi_nor_scan注册struct spi_nor结构体 后面需要重点分析spi_nor_scan结构体 mtd device注册 spi_nor_scan**(重点分析)**int spi_nor_scan(struct spi_nor *nor, const char *name, const struct spi_nor_hwcaps *hwcaps)\tstruct spi_nor_flash_parameter params;\tconst struct flash_info *info = NULL;\tstruct device *dev = nor-dev;\tstruct mtd_info *mtd = nor-mtd;\tstruct device_node *np = spi_nor_get_flash_node(nor);\tint ret;\tint i;\tprintk(spi_nor_scan start );\tret = spi_nor_check(nor);\tif (ret) return ret;\t/* Reset SPI protocol for all commands. */\tnor-reg_proto = SNOR_PROTO_1_1_1;\tnor-read_proto = SNOR_PROTO_1_1_1;\tnor-write_proto = SNOR_PROTO_1_1_1;\tif (name) info = spi_nor_match_id(name);\t/* Try to auto-detect if chip name wasnt specified or not found */\tif (!info) info = spi_nor_read_id(nor);\tif (IS_ERR_OR_NULL(info)) return -ENOENT;\t/* * If caller has specified name of flash model that can normally be * detected using JEDEC, lets verify it. */\tif (name info-id_len) const struct flash_info *jinfo; jinfo = spi_nor_read_id(nor); if (IS_ERR(jinfo)) return PTR_ERR(jinfo); else if (jinfo != info) /* * JEDEC knows better, so overwrite platform ID. We * cant trust partitions any longer, but well let * mtd apply them anyway, since some partitions may be * marked read-only, and we dont want to lose that * information, even if its not 100% accurate. */ dev_warn(dev, found %s, expected %s , jinfo-name, info-name); info = jinfo; mutex_init(nor-lock);\t/* * Make sure the XSR_RDY flag is set before calling * spi_nor_wait_till_ready(). Xilinx S3AN share MFR * with Atmel spi-nor */\tif (info-flags SPI_S3AN) nor-flags |= SNOR_F_READY_XSR_RDY;\t/* Parse the Serial Flash Discoverable Parameters table. */\tret = spi_nor_init_params(nor, info, params);\tif (ret) return ret;\t/* * Atmel, SST, Intel/Numonyx, and others serial NOR tend to power up * with the software protection bits set */\tif (JEDEC_MFR(info) == SNOR_MFR_ATMEL || JEDEC_MFR(info) == SNOR_MFR_INTEL || JEDEC_MFR(info) == SNOR_MFR_SST || info-flags SPI_NOR_HAS_LOCK) write_enable(nor); write_sr(nor, 0); spi_nor_wait_till_ready(nor); if (!mtd-name) mtd-name = dev_name(dev);\tmtd-priv = nor;\tmtd-type = MTD_NORFLASH;\tmtd-writesize = 1;\tmtd-flags = MTD_CAP_NORFLASH;\tmtd-size = params.size;\tmtd-_erase = spi_nor_erase;\tmtd-_read = spi_nor_read;\t/* NOR protection support for STmicro/Micron chips and similar */\tif (JEDEC_MFR(info) == SNOR_MFR_MICRON || info-flags SPI_NOR_HAS_LOCK) nor-flash_lock = stm_lock; nor-flash_unlock = stm_unlock; nor-flash_is_locked = stm_is_locked; if (nor-flash_lock nor-flash_unlock nor-flash_is_locked) mtd-_lock = spi_nor_lock; mtd-_unlock = spi_nor_unlock; mtd-_is_locked = spi_nor_is_locked; /* sst nor chips use AAI word program */\tif (info-flags SST_WRITE) mtd-_write = sst_write;\telse mtd-_write = spi_nor_write;\tif (info-flags USE_FSR) nor-flags |= SNOR_F_USE_FSR;\tif (info-flags SPI_NOR_HAS_TB) nor-flags |= SNOR_F_HAS_SR_TB;\tif (info-flags NO_CHIP_ERASE) nor-flags |= SNOR_F_NO_OP_CHIP_ERASE;\tif (info-flags USE_CLSR) nor-flags |= SNOR_F_USE_CLSR;\tif (info-flags SPI_NOR_NO_ERASE) mtd-flags |= MTD_NO_ERASE;\tmtd-dev.parent = dev;\tnor-page_size = params.page_size;\tmtd-writebufsize = nor-page_size;\tif (np) /* If we were instantiated by DT, use it */ if (of_property_read_bool(np, m25p,fast-read)) params.hwcaps.mask |= SNOR_HWCAPS_READ_FAST; else params.hwcaps.mask = ~SNOR_HWCAPS_READ_FAST; else /* If we werent instantiated by DT, default to fast-read */ params.hwcaps.mask |= SNOR_HWCAPS_READ_FAST; /* Some devices cannot do fast-read, no matter what DT tells us */\tif (info-flags SPI_NOR_NO_FR) params.hwcaps.mask = ~SNOR_HWCAPS_READ_FAST;\t/* * Configure the SPI memory: * - select op codes for (Fast) Read, Page Program and Sector Erase. * - set the number of dummy cycles (mode cycles + wait states). * - set the SPI protocols for register and memory accesses. * - set the Quad Enable bit if needed (required by SPI x-y-4 protos). */\tret = spi_nor_setup(nor, info, params, hwcaps);\tif (ret) return ret;\tif (nor-addr_width) /* already configured from SFDP */ else if (info-addr_width) nor-addr_width = info-addr_width; else if (mtd-size 0x1000000) /* enable 4-byte addressing if the device exceeds 16MiB */ nor-addr_width = 4; if (JEDEC_MFR(info) == SNOR_MFR_SPANSION || info-flags SPI_NOR_4B_OPCODES) spi_nor_set_4byte_opcodes(nor, info); else set_4byte(nor, info, 1); else nor-addr_width = 3; if (nor-addr_width SPI_NOR_MAX_ADDR_WIDTH) dev_err(dev, address width is too large: %u , nor-addr_width); return -EINVAL; if (info-flags SPI_S3AN) ret = s3an_nor_scan(info, nor); if (ret) return ret; dev_info(dev, %s (%lld Kbytes) , info-name, (long long)mtd-size 10);\tdev_dbg(dev, mtd .name = %s, .size = 0x%llx (%lldMiB), .erasesize = 0x%.8x (%uKiB) .numeraseregions = %d , mtd-name, (long long)mtd-size, (long long)(mtd-size 20), mtd-erasesize, mtd-erasesize / 1024, mtd-numeraseregions);\tprintk(spi_nor_scan end );\tif (mtd-numeraseregions) for (i = 0; i mtd-numeraseregions; i++) dev_dbg(dev, mtd.eraseregions[%d] = .offset = 0x%llx, .erasesize = 0x%.8x (%uKiB), .numblocks = %d , i, (long long)mtd-eraseregions[i].offset, mtd-eraseregions[i].erasesize, mtd-eraseregions[i].erasesize / 1024, mtd-eraseregions[i].numblocks);\treturn 0;EXPORT_SYMBOL_GPL(spi_nor_scan); 需要重点分析 几个重要的函数m25p80_read_regstatic int m25p80_read_reg(struct spi_nor *nor, u8 code, u8 *val, int len)\tstruct m25p *flash = nor-priv;\tstruct spi_device *spi = flash-spi;\tint ret;\tret = spi_write_then_read(spi, code, 1, val, len);\tif (ret 0) dev_err(spi-dev, error %d reading %x , ret, code);\treturn ret; m25p80_write_regstatic int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\tstruct m25p *flash = nor-priv;\tstruct spi_device *spi = flash-spi;\tflash-command[0] = opcode;\tif (buf) memcpy(flash-command[1], buf, len);\treturn spi_write(spi, flash-command, len + 1); m25p80_writestatic ssize_t m25p80_write(struct spi_nor *nor, loff_t to, size_t len, const u_char *buf)\tstruct m25p *flash = nor-priv;\tstruct spi_device *spi = flash-spi;\tunsigned int inst_nbits, addr_nbits, data_nbits, data_idx;\tstruct spi_transfer t[3] = ;\tstruct spi_message m;\tint cmd_sz = m25p_cmdsz(nor);\tssize_t ret;\t/* get transfer protocols. */\tinst_nbits = spi_nor_get_protocol_inst_nbits(nor-write_proto);\taddr_nbits = spi_nor_get_protocol_addr_nbits(nor-write_proto);\tdata_nbits = spi_nor_get_protocol_data_nbits(nor-write_proto);\tspi_message_init(m);\tif (nor-program_opcode == SPINOR_OP_AAI_WP nor-sst_write_second) cmd_sz = 1;\tflash-command[0] = nor-program_opcode;\tm25p_addr2cmd(nor, to, flash-command);\tt[0].tx_buf = flash-command;\tt[0].tx_nbits = inst_nbits;\tt[0].len = cmd_sz;\tspi_message_add_tail(t[0], m);\t/* split the op code and address bytes into two transfers if needed. */\tdata_idx = 1;\tif (addr_nbits != inst_nbits) t[0].len = 1; t[1].tx_buf = flash-command[1]; t[1].tx_nbits = addr_nbits; t[1].len = cmd_sz - 1; spi_message_add_tail(t[1], m); data_idx = 2; t[data_idx].tx_buf = buf;\tt[data_idx].tx_nbits = data_nbits;\tt[data_idx].len = len;\tspi_message_add_tail(t[data_idx], m);\tret = spi_sync(spi, m);\tif (ret) return ret;\tret = m.actual_length - cmd_sz;\tif (ret 0) return -EIO;\treturn ret; m25p80_readstatic ssize_t m25p80_read(struct spi_nor *nor, loff_t from, size_t len, u_char *buf)\tstruct m25p *flash = nor-priv;\tstruct spi_device *spi = flash-spi;\tunsigned int inst_nbits, addr_nbits, data_nbits, data_idx;\tstruct spi_transfer t[3];\tstruct spi_message m;\tunsigned int dummy = nor-read_dummy;\tssize_t ret;\tint cmd_sz;\t/* get transfer protocols. */\tinst_nbits = spi_nor_get_protocol_inst_nbits(nor-read_proto);\taddr_nbits = spi_nor_get_protocol_addr_nbits(nor-read_proto);\tdata_nbits = spi_nor_get_protocol_data_nbits(nor-read_proto);\t/* convert the dummy cycles to the number of bytes */\tdummy = (dummy * addr_nbits) / 8;\tif (spi_flash_read_supported(spi)) struct spi_flash_read_message msg; memset(msg, 0, sizeof(msg)); msg.buf = buf; msg.from = from; msg.len = len; msg.read_opcode = nor-read_opcode; msg.addr_width = nor-addr_width; msg.dummy_bytes = dummy; msg.opcode_nbits = inst_nbits; msg.addr_nbits = addr_nbits; msg.data_nbits = data_nbits; ret = spi_flash_read(spi, msg); if (ret 0) return ret; return msg.retlen; spi_message_init(m);\tmemset(t, 0, sizeof(t));\tflash-command[0] = nor-read_opcode;\tm25p_addr2cmd(nor, from, flash-command);\tt[0].tx_buf = flash-command;\tt[0].tx_nbits = inst_nbits;\tt[0].len = m25p_cmdsz(nor) + dummy;\tspi_message_add_tail(t[0], m);\t/* * Set all dummy/mode cycle bits to avoid sending some manufacturer * specific pattern, which might make the memory enter its Continuous * Read mode by mistake. * Based on the different mode cycle bit patterns listed and described * in the JESD216B specification, the 0xff value works for all memories * and all manufacturers. */\tcmd_sz = t[0].len;\tmemset(flash-command + cmd_sz - dummy, 0xff, dummy);\t/* split the op code and address bytes into two transfers if needed. */\tdata_idx = 1;\tif (addr_nbits != inst_nbits) t[0].len = 1; t[1].tx_buf = flash-command[1]; t[1].tx_nbits = addr_nbits; t[1].len = cmd_sz - 1; spi_message_add_tail(t[1], m); data_idx = 2; t[data_idx].rx_buf = buf;\tt[data_idx].rx_nbits = data_nbits;\tt[data_idx].len = min3(len, spi_max_transfer_size(spi), spi_max_message_size(spi) - cmd_sz);\tspi_message_add_tail(t[data_idx], m);\tret = spi_sync(spi, m);\tif (ret) return ret;\tret = m.actual_length - cmd_sz;\tif (ret 0) return -EIO;\treturn ret;","tags":["linux","SPI","platform"],"categories":["驱动"]},{"title":"Linux sys 虚拟文件系统分析","path":"/2025/08/18/sys class/","content":"Linux sys 虚拟文件系统分析系统中所有的设备（对象）都会在sysdevices 体现出来，是 sysfs 文件系统中最重要的目录结构；而 sysbus、sysclass、sysdev 分别将设备按照挂载的总线类型、功能分类以及设备号的形式将设备组织存放 在这些目录中，这些目录下的文件都是链接到了sysdevices 中。 应用层想要对底层硬件进行操控，通常可以通过两种方式： ⚫ dev目录下的设备文件（设备节点）； ⚫ sys目录下设备的属性文件。 系统中的所有设备根据其功能分类组织到了sysclass 目录下，所以sysclassleds 目录下便存放了所有的 LED 类设备 未完…","tags":["linux","platform","sys"],"categories":["驱动"]},{"title":"以spi_device继承spi_controller分析继承和关联的使用区别","path":"/2025/08/18/以spi_device继承spi_controller分析继承和关联的使用区别/","content":"以spi_device继承spi_controller分析继承和关联的使用区别区分 “继承” 和 “从属关联”要清晰区分 “继承” 和 “从属关联”，需从 核心定义、内存结构、逻辑关系、代码表现 四个维度切入 —— 这两个概念的本质差异，是 “是否存在层级归属与属性复用”，而非简单的 “引用关系”。 一、核心定义：本质差异 概念 核心逻辑 通俗类比 继承（Inheritance） 子类（派生类）“is a”（是一种）父类（基类），继承父类的所有属性和行为，同时可扩展自身特性。 核心是 “层级归属 + 属性复用”。 猫（子类）是一种动物（父类），继承 “呼吸、进食” 等动物的通用行为，同时有 “抓老鼠” 的特有行为。 从属关联（DependencyAssociation） A 对象 “depends on”（依赖 从属）B 对象，A 需借助 B 的能力完成工作，但 A 不继承 B 的属性或行为，两者是独立的个体。 核心是 “功能依赖 + 独立存在”。 学生（A）从属班级（B）：学生需要班级提供的 “上课、考勤” 功能，但学生不继承班级的 “班级编号、班主任” 等属性，学生和班级是独立的实体。 二、四个关键区分维度1. 内存结构：“包含” vs “引用”继承和从属关联在代码的内存布局上有本质不同，这是最硬核的区分依据： （1）继承：子类内存包含父类成员在 C 语言（内核常用）中，继承通过 “结构体嵌套” 实现 ——父类结构体作为子类结构体的第一个成员，子类内存中会完整包含父类的所有成员，可直接访问父类属性。示例（内核设备模型的继承）： // 父类：通用设备基类struct device const char *name; // 通用属性：设备名 struct device *parent; // 通用属性：父设备 // 其他通用成员...;// 子类：SPI从设备（继承 struct device）struct spi_device struct device dev; // 第一个成员 = 父类，内存上包含父类所有成员 u32 max_speed_hz; // 子类特有属性：最大速率 struct spi_controller *controller; // 关联控制器（非继承） // 其他子类特有成员...; 内存布局：spi_device 的内存起始地址 其内部 dev 的地址，可通过 spi_device 指针直接访问 dev 的成员（如 spi_dev-dev.name）。 内核宏 to_spi_device(dev) 本质：将 struct device * 指针强制转换为 struct spi_device *，依赖 “父类是子类第一个成员” 的内存布局 —— 这是继承的典型特征。 （2）从属关联：仅通过指针 “引用”，不包含对方成员从属关联中，A 对象仅持有 B 对象的指针 句柄，内存上不包含 B 的任何成员，无法直接访问 B 的属性（需通过指针间接访问）。示例（spi_device 与 spi_controller 的关联）： struct spi_device struct device dev; // 继承的父类 // 仅持有控制器的指针，不包含 spi_controller 的任何成员 struct spi_controller *controller; ;struct spi_controller struct device dev; // 自身继承的父类 u16 num_chipselect; // 控制器特有属性：片选数量; 内存布局：spi_device 的 controller 指针仅存储 spi_controller 的内存地址，spi_device 内存中没有 num_chipselect 等控制器成员。 访问控制器属性：必须通过指针间接访问（如 spi_dev-controller-num_chipselect），而非直接访问 —— 这是关联的典型特征。 2. 逻辑关系：“是一种” vs “依赖一种”（1）继承：“是一种”（is a）子类是父类的 “特殊化”，具备父类的所有本质特征，同时增加特有特征。 例 1：spi_device 是一种 struct device（符合设备模型的通用设备），spi_controller 也是一种 struct device。 例 2：“哈士奇” 是一种 “狗”，“狗” 是一种 “动物”—— 层级归属明确。 （2）从属关联：“依赖一种”（depends on）A 对象需要 B 对象的能力才能工作，但 A 不是 B 的 “特殊化”，两者是独立的逻辑实体。 例 1：spi_device 依赖 spi_controller 的 “传输数据” 能力，但 spi_device 不是 “一种”spi_controller（从设备是被管理者，控制器是管理者，角色完全不同）。 例 2：“手机” 依赖 “基站” 的 “信号传输” 能力，但手机不是 “一种” 基站。 3. 属性与行为：“复用” vs “隔离”（1）继承：子类复用父类的属性和行为父类的属性（如 struct device 的 name）和行为（如内核提供的 device_add 注册函数），子类可直接复用，无需重复定义。 例：spi_device 和 spi_controller 都无需自己实现 “设备注册” 逻辑，直接复用 device_add 函数（通过 dev 成员）。 （2）从属关联：属性和行为完全隔离A 对象和 B 对象的属性、行为互不复用，各自有独立的定义。 例：spi_device 的 max_speed_hz（从设备速率）与 spi_controller 的 max_speed_hz（控制器最大速率）是完全独立的属性，前者受后者约束，但不复用后者的值。 例：spi_controller 的 transfer_one（传输函数）是控制器的行为，spi_device 无法复用，只能通过 controller-transfer_one 调用该行为。 4. 生命周期：“绑定” vs “独立”（1）继承：子类与父类生命周期绑定子类的生命周期与父类完全一致 —— 创建子类时，父类成员会同时初始化；销毁子类时，父类成员也会同时释放。 例：创建 spi_device 时，其内部的 struct device dev 会被一起初始化；销毁 spi_device 时，dev 也会被 device_del 清理。 （2）从属关联：生命周期独立A 对象和 B 对象的生命周期可独立存在，互不影响。 例 1：spi_controller 先注册（生命周期开始），之后 spi_device 再注册（依赖已存在的控制器）；spi_device 可先注销（生命周期结束），控制器仍可继续管理其他从设备。 例 2：“学生” 毕业（生命周期结束），“班级” 仍可存在（继续招收新学生）。 三、总结：一句话区分 继承：子类是父类的 “一种”，内存包含父类成员，复用父类属性和行为，生命周期绑定（如 spi_device ← struct device）。 从属关联：A 依赖 B 的能力，内存仅持有 B 的指针，属性行为完全隔离，生命周期独立（如 spi_device → spi_controller）。 回到你最初的疑问：spi_device 没有继承 spi_controller，而是通过指针 “从属关联” 到 spi_controller；两者真正的继承关系，是都继承自内核的 struct device（通用设备基类）。 在实际编程中，如何判断应该使用继承还是从属关联？在实际编程（尤其是驱动开发、框架设计等场景）中，判断使用继承还是从属关联，核心是围绕 “逻辑关系”“复用需求”“生命周期”“耦合度” 四个维度做决策，可按以下步骤逐步判断，结合具体场景落地。 一、第一步：先判断核心逻辑关系 ——“is a” 还是 “has adepends on”这是最根本的判断标准，直接决定两种设计的适用场景： 1. 若满足 “is a”（A 是 B 的一种）→ 优先用继承当 A 实体本质上是 B 实体的特殊化版本，具备 B 的所有核心特征，且需要在此基础上扩展特有属性 行为时，用继承。判断问题：能否用 “XX 是一种 XX” 描述两者关系？能则选继承。 典型场景示例： 内核设备模型：spi_device 是一种 struct device（符合通用设备的所有特征：有名称、能匹配驱动、支持电源管理），因此 spi_device 继承 struct device。 面向对象编程：Dog 是一种 Animal（有呼吸、进食等通用行为，扩展 “汪汪叫” 特有行为），因此 Dog 继承 Animal。 驱动开发：i2c_client（I2C 从设备）是一种 struct device，因此继承 struct device。 2. 若满足 “has a”（A 包含 依赖 B 的能力）→ 优先用从属关联当 A 实体需要 借助 B 实体的能力完成工作，但 A 不是 B 的 “特殊化版本”，两者是独立个体时，用从属关联。判断问题：能否用 “XX 需要 XX 的帮助才能工作” 或 “XX 包含 XX 的引用” 描述？能则选关联。 典型场景示例： SPI 子系统：spi_device 需要 spi_controller 的 “数据传输能力” 才能收发数据，但 spi_device 不是 “一种”spi_controller（角色是 “被管理者” vs “管理者”），因此用指针关联（spi_controller *controller）。 硬件驱动：“LED 设备” 需要 “GPIO 控制器” 的 “引脚控制能力” 才能亮灭，但 LED 不是 “一种” GPIO 控制器，因此用 struct gpio_desc *gpio 关联 GPIO 引脚。 应用开发：“播放器” 需要 “音频解码器” 的 “解码能力” 才能播放音乐，但播放器不是 “一种” 解码器，因此用指针关联解码器实例。 二、第二步：判断属性 行为的复用需求若第一步的逻辑关系不明确，可通过 “是否需要复用属性 行为” 进一步判断： 1. 需要复用属性 行为 → 用继承继承的核心价值是避免重复代码：父类的属性（如 struct device 的 name、parent）和行为（如内核提供的 device_add 注册函数），子类可直接复用，无需重新定义。反例：若 spi_device 不继承 struct device，则需要自己实现设备命名、驱动匹配、电源管理等逻辑，导致代码冗余（I2C、USB 等其他总线设备也需重复实现）。 2. 仅需调用功能，无需复用属性 → 用从属关联从属关联中，A 仅需调用 B 的特定接口（如 spi_controller-transfer_one），无需复用 B 的属性（如 num_chipselect），此时用指针关联即可，避免不必要的属性暴露。反例：若 spi_device 继承 spi_controller，则会被迫包含 num_chipselect、dma_tx 等与从设备无关的属性，造成内存浪费和逻辑混乱。 三、第三步：判断生命周期是否绑定两种设计的生命周期关系不同，直接影响资源管理的安全性： 1. 生命周期必须绑定（同生共死）→ 用继承继承中，子类的生命周期与父类完全绑定：创建子类时，父类成员会同步初始化；销毁子类时，父类成员也会同步释放，无需单独管理父类资源。示例：创建 spi_device 时，其内部的 struct device dev 会通过 device_initialize 初始化；销毁 spi_device 时，dev 会通过 device_del 自动清理，无需单独处理 dev 的生命周期。 2. 生命周期独立（可分别创建 销毁）→ 用从属关联从属关联中，A 和 B 的生命周期相互独立：B 可先于 A 创建（如 spi_controller 先注册，spi_device 后注册），A 可先于 B 销毁（如 spi_device 注销后，spi_controller 仍管理其他设备）。示例：spi_controller 注册后，可动态添加 删除多个 spi_device；即使所有 spi_device 都注销，spi_controller 仍可保留（除非主动卸载控制器驱动）。 四、第四步：考虑耦合度需求（松耦合优先）继承会导致强耦合（子类依赖父类的实现细节），关联则是松耦合（仅依赖接口，不依赖实现），实际编程中应优先选择松耦合设计，除非继承的收益（复用、逻辑清晰）远大于耦合成本。 1. 需降低耦合（便于扩展 维护）→ 优先关联若 B 的实现可能变化（如更换不同厂商的 SPI 控制器），A 只需适配 B 的接口（如 transfer_one 函数），无需修改 A 的代码，此时关联更合适。示例：更换 SPI 控制器驱动时，spi_device 无需修改（只需确保新控制器实现 transfer_one 接口），因为 spi_device 仅通过指针调用接口，不依赖控制器的内部实现。 2. 需统一规范（不允许灵活修改）→ 用继承若需要强制所有子类遵循统一的接口或属性（如内核设备模型要求所有设备必须有 struct device 成员），则用继承，确保规范不被打破。示例：内核所有硬件设备（SPI、I2C、PCI 等）都必须继承 struct device，以保证电源管理、sysfs 接口等功能的统一性，不允许通过关联绕过这一规范。 五、总结：决策流程图（实际编程可按此步骤）​ A[“判断两个实体关系”] – B{是否满足“is a”？} graph TD A[判断两个实体关系] -- B是否满足is a关系 B --|是| C[用继承,复用属性/行为,生命周期绑定] B --|否| D是否仅需调用对方功能,无需复用属性? D --|是| E[用从属关联,指针引用,松耦合,生命周期独立] D --|否| F[重新审视逻辑关系是否误判is a?] F --|确认不是is a| E F --|确认是is a| C 关键结论 继承：适用于 “XX 是一种 XX”、需复用属性 行为、生命周期绑定、需统一规范的场景（如内核设备模型、类的特殊化）。 从属关联：适用于 “XX 依赖 XX 的能力”、仅需调用接口、生命周期独立、需降低耦合的场景（如设备与控制器的关系、模块间的功能调用）。 回到之前的 SPI 例子： spi_device 继承 struct device：因为 “spi_device 是一种设备”，需复用设备命名、电源管理等功能，生命周期绑定。 spi_device 关联 spi_controller：因为 “spi_device 依赖控制器的传输能力”，仅需调用接口，生命周期独立，需降低耦合。 优点 清晰的逻辑层级，降低理解成本继承直接体现 “is a” 的语义关系，子类与基类的层级明确，代码阅读者可快速理解实体间的逻辑归属，无需额外文档说明。 示例：看到 struct spi_device 嵌套 struct device，可立刻判断 “SPI 从设备是一种内核通用设备”；看到 struct spi_controller 也嵌套 struct device，可判断 “SPI 控制器也是一种通用设备”—— 这种层级关系比通过指针关联更直观。 收益：提升代码可读性，降低团队协作中的认知成本。 优点 统一接口与框架化管理基类可定义 通用操作规范，所有子类遵循同一接口，便于框架统一管理不同类型的子类，实现 “多态” 效果（C 中通过函数指针和基类接口间接实现）。 示例：内核设备模型通过 struct device 定义了统一的设备生命周期接口（probe、remove、suspend、resume）。无论子类是 spi_device 还是 i2c_client，框架都能通过 struct device * 指针调用通用接口（如 dev_pm_domain_attach(dev)），无需区分设备类型 —— 这是内核能统一管理所有硬件设备的关键。 收益：简化框架设计，支持 “新增子类无需修改框架”（如新增一种总线设备，只需嵌套 struct device 即可融入现有模型）。","tags":["linux","SPI","platform"],"categories":["驱动"]},{"title":"本地仓库覆盖远程非空仓库","path":"/2025/08/18/本地仓库覆盖远程非空仓库/","content":"本地仓库覆盖远程非空仓库 远程仓库已有一个初始提交（README.md） 本地文件夹结构和远程不一致 ✅ 目标让本地仓库覆盖并上传到 GitHub 仓库 🚀直接覆盖远程仓库如果远程仓库里只有一个 README.md，可以直接让本地版本覆盖掉远程内容 在本地项目目录执行： git init # 如果还没初始化git branch -M main # 统一分支名git remote add origin https://github.com/xxx/yyy.gitgit fetch origin # 获取远程分支git pull origin main --allow-unrelated-histories 上面的命令会把远程的 README.md 拉到本地，并允许合并不同来源的项目。 然后执行： # 如果产生冲突，比如 README.md 同名，可以手动选择保留哪一个git add .git commit -m xxxgit push -u origin main --force ⚠️ 说明： --allow-unrelated-histories 用于合并两个独立项目的历史。 --force 是为了覆盖远程旧内容（请确认无重要文件后使用）。 😄完","tags":["git","ssh"],"categories":["GIT"]},{"title":"杂项笔记-不完整","path":"/2025/08/18/简单系统调用过程分析/","content":"简单系统调用过程分析前言我写了一段C代码： int main()\tprintf(hello world! );\treturn 0; 在终端执行： strace -o printf.log ./print_helloworld 终端中输出： hello world! printf.log中的内容为： execve(./print_helloworld, [./print_helloworld], 0x7ffddeb59340 /* 37 vars */) = 0brk(NULL) = 0x55b56c23f000arch_prctl(0x3001 /* ARCH_??? */, 0x7ffd179dbd20) = -1 EINVAL (Invalid argument)mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f16cdaba000access(/etc/ld.so.preload, R_OK) = -1 ENOENT (No such file or directory)openat(AT_FDCWD, /etc/ld.so.cache, O_RDONLY|O_CLOEXEC) = 3newfstatat(3, , st_mode=S_IFREG|0644, st_size=34783, ..., AT_EMPTY_PATH) = 0mmap(NULL, 34783, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f16cdab1000close(3) = 0openat(AT_FDCWD, /lib/x86_64-linux-gnu/libc.so.6, O_RDONLY|O_CLOEXEC) = 3read(3, \\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\0\\1\\0\\0\\0P\\237\\2\\0\\0\\0\\0\\0..., 832) = 832pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0..., 784, 64) = 784pread64(3, \\4\\0\\0\\0 \\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0..., 48, 848) = 48pread64(3, \\4\\0\\0\\0\\24\\0\\0\\0\\3\\0\\0\\0GNU\\0I\\17\\357\\204\\3$\\f\\221\\2039x\\324\\224\\323\\236S..., 68, 896) = 68newfstatat(3, , st_mode=S_IFREG|0755, st_size=2220400, ..., AT_EMPTY_PATH) = 0pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0..., 784, 64) = 784mmap(NULL, 2264656, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f16cd888000mprotect(0x7f16cd8b0000, 2023424, PROT_NONE) = 0mmap(0x7f16cd8b0000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7f16cd8b0000mmap(0x7f16cda45000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bd000) = 0x7f16cda45000mmap(0x7f16cda9e000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x215000) = 0x7f16cda9e000mmap(0x7f16cdaa4000, 52816, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f16cdaa4000close(3) = 0mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f16cd885000arch_prctl(ARCH_SET_FS, 0x7f16cd885740) = 0set_tid_address(0x7f16cd885a10) = 19390set_robust_list(0x7f16cd885a20, 24) = 0rseq(0x7f16cd8860e0, 0x20, 0, 0x53053053) = 0mprotect(0x7f16cda9e000, 16384, PROT_READ) = 0mprotect(0x55b552fa8000, 4096, PROT_READ) = 0mprotect(0x7f16cdaf4000, 8192, PROT_READ) = 0prlimit64(0, RLIMIT_STACK, NULL, rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY) = 0munmap(0x7f16cdab1000, 34783) = 0newfstatat(1, , st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x5), ..., AT_EMPTY_PATH) = 0getrandom(\\x26\\xbc\\x99\\x15\\xfc\\x24\\x0d\\x5b, 8, GRND_NONBLOCK) = 8brk(NULL) = 0x55b56c23f000brk(0x55b56c260000) = 0x55b56c260000write(1, hello world! , 13) = 13exit_group(0) = ?+++ exited with 0 +++ 涉及到的系统调用（1）涉及到strace 命令 通过man strace可以看到他是一个跟踪系统调用和信号传递的工具 It intercepts and records the system calls which are called by a process and the signals which are received by a process. The name of each system call, its arguments and its return value are printed on standard error or to the file specified with the -o option. （2）这个案例中涉及一些系统调用 arch_prctl 用于设置架构特定线程状态的系统调用。它允许在 x86 和 x86-64 架构上执行特定的操作，如设置和获取 FS 和 GS 寄存器的基地址，以及启用或禁用 CPUID 指令。 mmap execve 允许进程用一个全新的程序替换当前运行的程序。这个过程中，旧程序的栈、数据和堆段会被新程序所替换。execve函数不会创建新进程，而是在原有进程的基础上执行另一个程序，进程ID保持不变。 access openat 用于相对于指定目录文件描述符打开文件，是 open 函数的扩展版本，提供了更灵活的文件打开方式，支持相对路径操作，避免了某些竞态条件。 newfstatat set_tid_address set_robust_list rseq brk write close exit_group 具体分析1. 程序启动 (execve)execve(./print_helloworld, [./print_helloworld], 0x7ffddeb59340 /* 37 vars */) = 0 execve：这是程序启动时的系统调用，用于执行可执行文件。execve 会替换当前进程的映像为指定的程序，这里是 ./print_helloworld。 它传递了参数 [./print_helloworld]，表示没有命令行参数传入。 0x7ffddeb59340 是进程环境变量的位置（堆栈中的内存位置）。 2. 分配内存 (brk 和 mmap)brk(NULL) = 0x55b56c23f000 brk：brk 系统调用是为了调整程序的堆内存边界，分配内存。这里它返回了一个地址，表明堆的开始位置。 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f16cdaba000 mmap：这个调用分配了一块 8192 字节的内存区域。PROT_READ|PROT_WRITE 表示这块内存可读可写，MAP_PRIVATE|MAP_ANONYMOUS 表示这是匿名内存（没有文件映射）。它返回了内存区域的起始地址。 3. 加载动态链接库 (openat 和 read)openat(AT_FDCWD, /etc/ld.so.cache, O_RDONLY|O_CLOEXEC) = 3read(3, \\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\0\\1\\0\\0\\0P\\237\\2\\0\\0\\0\\0\\0..., 832) = 832 openat：打开共享库缓存文件 /etc/ld.so.cache，它包含了动态库路径的信息。O_RDONLY 表示只读模式，O_CLOEXEC 表示当执行 exec 系统调用时会自动关闭该文件。 read：从文件中读取数据，这里是读取到 ELF 格式的共享库文件的部分内容。 4. 继续读取共享库信息 (pread64)pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@, 784, 64) = 784pread64(3, \\4\\0\\0\\0 \\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0, 48, 848) = 48 pread64：从文件描述符中读取共享库的特定偏移位置的数据。这部分通常用于解析 ELF 文件头，提取程序头信息、节头等数据。 5. 加载 libc 库newfstatat(3, , st_mode=S_IFREG|0755, st_size=2220400, ..., AT_EMPTY_PATH) = 0pread64(3, \\6\\0\\0\\0\\4\\0\\0\\0@, 784, 64) = 784mmap(NULL, 2264656, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f16cd888000 mmap：加载共享库 libc.so.6 的内容到内存中，大小为 2264656 字节。该内存映射使用了 PROT_READ（只读）权限，以防止写入修改库内容。 6. 保护库的只读区域 (mprotect)mprotect(0x7f16cd8b0000, 2023424, PROT_NONE) = 0 mprotect：将库的一部分内存设置为不可访问（PROT_NONE），以保护代码区不被修改。 7. 内存映射（执行区域）mmap(0x7f16cd8b0000, 1658880, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7f16cd8b0000 mmap：将库的代码部分映射到进程的地址空间，且此区域可执行（PROT_EXEC）。这使得程序能够执行共享库中的代码。 8. 设置堆栈信息 (arch_prctl 和 set_tid_address)arch_prctl(ARCH_SET_FS, 0x7f16cd885740) = 0set_tid_address(0x7f16cd885a10) = 19390 arch_prctl：设置与体系结构相关的特定寄存器。这通常用于线程的控制。 set_tid_address：设置当前线程的 ID 地址。 9. 进程的内存保护和资源限制 (mprotect, prlimit64)mprotect(0x7f16cda9e000, 16384, PROT_READ) = 0prlimit64(0, RLIMIT_STACK, NULL, rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY) = 0 mprotect：对堆栈的内存进行保护，使其只读。 prlimit64：检查进程的栈内存限制，确保栈内存足够。 10. 写入标准输出 (write)write(1, hello world! , 13) = 13 write：调用 write 系统调用将数据输出到文件描述符 1（即标准输出）。它将 hello world! 输出到终端。 11. 程序退出 (exit_group)exit_group(0) = ? exit_group：这是进程退出时的系统调用，0 表示程序正常退出。 总结整个过程可以按以下步骤总结： 程序启动：execve 启动 ./print_helloworld 程序。 内存分配：程序通过 brk 和 mmap 分配内存。 加载共享库：通过 openat 和 read 读取共享库，加载 libc.so.6 库，映射到进程内存中。 设置堆栈和线程：通过 arch_prctl 和 set_tid_address 设置线程和堆栈信息。 保护内存：通过 mprotect 保护程序的代码和数据区域，防止非法访问。 执行代码：通过 mmap 映射并执行共享库代码。 输出结果：通过 write 输出字符串 hello world! 到终端。 程序退出：程序调用 exit_group 正常退出。 strace 输出展示了系统调用的详细信息，揭示了程序如何通过操作系统接口加载库、分配内存、执行代码和输出结果的过程。 (10 条消息) posix是什么都不知道，还好意思说你懂Linux？ - 知乎 (11 条消息) 系统调用与内存管理（sbrk、brk、mmap、munmap） - 知乎 关于init进程可执行文件目录： dky@DESKTOP-57A415L:/$ ls -la init -rwxrwxrwx 1 root root 2260248 Nov 10 2024 initdky@DESKTOP-57A415L:/$ file init init: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped init是 Linux 系统启动的第一个用户态进程（PID 通常为 1），负责初始化系统环境、启动后续的服务进程。 init对应的systemd源代码仓库 https://github.com/systemd/systemd.git 经过确认，wsl的init对应与WSL环境专用的初始化程序，其对应的代码仓库为： https://github.com/microsoft/WSL.git 具体路径位于：https://github.com/microsoft/WSL/blob/master/src/linux/init/main.cpp，发现竟然是用cpp写的，还挺神奇的 查看gcc命令具体位置dky@DESKTOP-57A415L:~$ which gcc/usr/bin/gccdky@DESKTOP-57A415L:~$ readlink -e /usr/bin/gcc/usr/bin/x86_64-linux-gnu-gcc-11 或者 dky@DESKTOP-57A415L:~$ which gcc/usr/bin/gccdky@DESKTOP-57A415L:~$ file /usr/bin/gcc/usr/bin/gcc: symbolic link to gcc-11dky@DESKTOP-57A415L:~$ file /usr/bin/gcc-11/usr/bin/gcc-11: symbolic link to x86_64-linux-gnu-gcc-11 查看gcc头文件库文件搜索路径gcc -print-search-dirs echo main()| gcc -E -v - gcc -v -E -x c /dev/null gcc -Wl,--verbose 21 | grep -E SEARCH_DIR|library search gcc -Wl,--verbose 21 glibc安装glibc下载地址：https://ftp.gnu.org/gnu/glibc/?C=M;O=A glibc是GNU发布的libc库，即c运行库。 glibc是linux系统中最底层的api，几乎其它任何运行库都会依赖于glibc。 glibc除了封装linux操作系统所提供的系统服务外，它本身也提供了许多其它一些必要功能服务的实现。 glibc涉及的系统组件多，无法在超算平台上整体部署高版本glibc，如果需要高版本glibc，可通过源码自行安装。 srun -p 64c512g -n 16 --pty /bin/bashmkdir -p $HOME/01.application/12.glibc cd $HOME/01.application/12.glibcwget http://ftp.gnu.org/gnu/glibc/glibc-2.29.tar.gztar -zxvf glibc-2.29.tar.gz cd glibc-2.29mkdir build cd build../configure --prefix=$HOME/01.application/12.glibc/ --disable-sanity-checksmake -j16make installcd $HOME/01.application/12.glibc/rm -rf glibc-2.29export PATH=$HOME/01.application/12.glibc/bin:$PATHldd --version 参考：https://docs.hpc.sjtu.edu.cn/app/compilers_and_languages/glibc.html glibc编译 cd /home/dky/printrm -rf glibc-buildmkdir glibc-buildcd glibc-build../glibc-2.35/configure \\ --prefix=/home/dky/print/glibc-prefix \\ --disable-werror --disable-werror 很重要，否则很多 warning 会被当成 error 卡住 --prefix 只是“未来如果 install 会装到哪”，不执行 make install 就不会动系统。 –prefix需要配置，否则默认为–prefixusrlocal，如果你把它装进 usrlocal 可能把系统搞坏”，执行configure时会直接拦住。 只编译（不安装） make -j$(nproc) 给 clangd 用：生成 compile_commands.json bear -- make -j$(nproc) -k 然后把它链接到源码根目录： ln -sf /home/dky/print/glibc-build/compile_commands.json \\ /home/dky/print/glibc-2.35/compile_commands.json （或在 VSCode clangd 参数里加：--compile-commands-dir=/home/dky/print/glibc-build） 查看glibc版本ldd --version 运行结果 dky@DESKTOP-57A415L:~/print/glibc-2.42$ ldd --versionldd (Ubuntu GLIBC 2.35-0ubuntu3.1) 2.35Copyright (C) 2022 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Written by Roland McGrath and Ulrich Drepper. GLIBC 的动态库是可以执行运行的, 运行将显示版本号以及版权信息，可以看到版本为：2.35 /lib/x86_64-linux-gnu/libc.so.6 运行结果 dky@DESKTOP-57A415L:~/print/glibc-2.42$ /lib/x86_64-linux-gnu/libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.8) stable release version 2.35.Copyright (C) 2022 Free Software Foundation, Inc.This is free software; see the source for copying conditions.There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE.Compiled by GNU CC version 11.4.0.libc ABIs: UNIQUE IFUNC ABSOLUTEFor bug reporting instructions, please see:https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs. 然后到Index of pubgnuglibc网站上搜索2.35版本进行下载。找到以下版本进行下载 glibc-2.35.tar.gz\t2022-02-03 01:35\t34M 解压并进入对应文件夹 tar -zxvf glibc-2.35.tar.gzcd glibc-2.35 验证下载的glibc就是系统所用的glibc代码 根据echo main(){}| gcc -E -v -查看得到头文件搜索路径，可以得到以下几个头文件搜索路径 dky@DESKTOP-57A415L:~/print$ echo main()| gcc -E -v -...#include ... search starts here:#include ... search starts here: /usr/lib/gcc/x86_64-linux-gnu/11/include /usr/local/include /usr/include/x86_64-linux-gnu /usr/includeEnd of search list.... 可以看到搜索路径都在/usr/*路径下，因此使用find搜索一个典型的头文件stdio.h dky@DESKTOP-57A415L:~$ find /usr -name stdio.h/usr/include/stdio.h/usr/include/c++/11/tr1/stdio.h/usr/include/x86_64-linux-gnu/bits/stdio.h 一共搜索出来3个stdio.h，但是可以确定的是对于C代码来说，使用的stdio.h就是/usr/include/stdio.h 在glibc-2.35中搜索stdio.h dky@DESKTOP-57A415L:~/print/glibc-2.35$ find -name stdio.h./include/stdio.h // 猜测提供给glibc内部使用./include/bits/stdio.h //只包含libio/bits/stdio.h./libio/bits/stdio.h // 与/usr/include/x86_64-linux-gnu/bits/stdio.h 文件相同./libio/stdio.h // 与 /usr/include/stdio.h 文件相同 一共有4个stdio.h 首先认为usrincludestdio.h就是.includestdio.h，但是很遗憾并不是，猜测这个stdio.h是提供给glibc内部接口使用的，看了下具体代码，全部是extern的一些print声明。 接下来看第二个和第三个文件，发现第二个.includebitsstdio.h里面只有一行代码#include libio/bits/stdio.h，即说明第二个文件和第三个文件是类同的，可以认为是同一个文件。又因为这俩文件都包含了bits目录，所以很自然的将.libiobitsstdio.h 与 usrincludex86_64-linux-gnubitsstdio.h对比，发现他俩的内容是一摸一样的。 dky@DESKTOP-57A415L:~/print/glibc-2.35$ cmp ./libio/bits/stdio.h /usr/include/x86_64-linux-gnu/bits/stdio.h 最后只剩下.libiostdio.h 了，将.libiostdio.h 与 usrincludestdio.h使用cmp对比发现两者一模一样。当然也可以在vscode中点击【将已选择项目进行比较】来直观验证 dky@DESKTOP-57A415L:~/print/glibc-2.35$ cmp /home/dky/print/glibc-2.35/libio/stdio.h /usr/include/stdio.h 结论就是：glibc-2.3libiostdio.h对应 usrincludestdio.h 想追踪printf怎么调用到C库的write，最后又如何调到write系统调用，搞了半天也没搞明白，放弃！ 编译内核参考：https://mazhen.tech/p/%E4%BB%8E%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA-linux-%E5%86%85%E6%A0%B8/ 官网上下载：https://www.kernel.org/ 点击最新版本下载：linux-6.18.1.tar.xz tar -Jxvf linux-6.18.1.tar.xzcd linux-6.18.1 为本机WSL编译内核： 查看本机信息： dky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ uname -m x86_64dky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ uname -r5.15.167.4-microsoft-standard-WSL2dky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ cat /proc/version Linux version 5.15.167.4-microsoft-standard-WSL2 (root@f9c826d3017f) (gcc (GCC) 11.2.0, GNU ld (GNU Binutils) 2.37) #1 SMP Tue Nov 5 00:21:55 UTC 2024dky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ dpkg --print-architecture 2/dev/null || trueamd64dky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ lscpu | egrep Architecture|Model name|Vendor ID || trueArchitecture: x86_64Vendor ID: GenuineIntelModel name: 12th Gen Intel(R) Core(TM) i5-12490Fdky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ 可以看到机器架构是x86_64, 清除交叉编译的环境污染： 重置ARCH CROSS_COMPILE CC是因为我的wsl环境默认配置的交叉编译环境为multi_v7_defconfig # 清掉交叉编译残留（只影响当前终端）unset ARCH CROSS_COMPILE CC HOSTCC LLVM# 清理源码树（把之前生成的 .config、临时文件等都清掉）make mrproper 执行make O..build-x86_64 ARCHx86_64 # out-of-tree 构建（不污染源码目录）mkdir -p ../build-x86_64# 生成 x86_64 默认配置make O=../build-x86_64 ARCH=x86_64 x86_64_defconfig 具体输出： dky@DESKTOP-57A415L:~/linux_kernel/linux-6.18.1$ make O=../build-x86_64 ARCH=x86_64 x86_64_defconfigmake[1]: Entering directory /home/dky/linux_kernel/build-x86_64 GEN Makefile HOSTCC scripts/basic/fixdep HOSTCC scripts/kconfig/conf.o HOSTCC scripts/kconfig/confdata.o HOSTCC scripts/kconfig/expr.o LEX scripts/kconfig/lexer.lex.c YACC scripts/kconfig/parser.tab.[ch] HOSTCC scripts/kconfig/lexer.lex.o HOSTCC scripts/kconfig/menu.o HOSTCC scripts/kconfig/parser.tab.o HOSTCC scripts/kconfig/preprocess.o HOSTCC scripts/kconfig/symbol.o HOSTCC scripts/kconfig/util.o HOSTLD scripts/kconfig/conf## configuration written to .config#make[1]: Leaving directory /home/dky/linux_kernel/build-x86_64 编译： # 编译make O=../build-x86_64 ARCH=x86_64 -j$(nproc) “内核源码 + compile_commands.json + VSCode clangd”的最省事配置步骤下面给你一套**“最省事、最不容易踩坑”**的流程：内核源码（source tree）+ 单独构建目录（O）+ 生成 compile_commands.json + VSCode(WSL) + clangd。 你的环境已经确认是 WSL2 + x86_64，所以全程按 x86_64 来。 0. 装好必备工具（WSL 里）sudo apt updatesudo apt install -y clangd python3 bear build-essential flex bison libssl-dev libelf-dev pahole 1. 推荐的目录布局（source 与 build 分开）假设你源码在： ~/linux_kernel/linux-6.18.1 我们用一个独立输出目录： ~/linux_kernel/build-x86_64 cd ~/linux_kernel/linux-6.18.1mkdir -p ../build-x86_64 2. 先把内核“准备好”让 clangd 能解析（生成必要头文件）cd ~/linux_kernel/linux-6.18.1unset ARCH CROSS_COMPILE CC HOSTCC LLVMmake O=../build-x86_64 ARCH=x86_64 x86_64_defconfig# 这一步会生成 include/generated/* 等关键文件（clangd 解析需要）make O=../build-x86_64 ARCH=x86_64 prepare modules_prepare 3. 生成 compile_commands.json（两种方式，选一种）方案 A（最推荐）：用内核自带脚本生成内核一般自带脚本（你 6.x 基本都有）： cd ~/linux_kernel/linux-6.18.1ls scripts/clang-tools/gen_compile_commands.py 如果存在，就这样生成（会在当前目录生成 compile_commands.json）： python3 scripts/clang-tools/gen_compile_commands.py -d ../build-x86_64 如果你希望把 compile_commands.json 放到 build 目录，也可以生成后移动过去： mv compile_commands.json ../build-x86_64/ 方案 B（通吃）：用 bear 抓编译命令如果你更信任 “实际编译过程”，用 bear： cd ~/linux_kernel/linux-6.18.1bear -- make O=../build-x86_64 ARCH=x86_64 -j$(nproc) bear 会在你当前目录生成 compile_commands.json（同样可以 mv 到 build 目录）。 4. VSCode（Remote - WSL）里配置 clangd：一劳永逸4.1 安装启用扩展 安装 clangd 扩展（LLVM 官方那个） 如果你装了 Microsoft 的 CC++ 扩展：建议禁用它的 IntelliSense（否则经常抢解析） 4.2 在工程根目录写 .vscode/settings.json假设你把 compile_commands.json 放在 ../build-x86_64/（推荐）： clangd.arguments: [ --background-index, --compile-commands-dir=/home/dky/linux_kernel/build-x86_64, --header-insertion=never, --clang-tidy=false, -j=8 ], C_Cpp.intelliSenseEngine: disabled 把路径按你真实用户名目录改一下。 -j=8 也可以换成你的 CPU 线程数。 5. 常见坑位（你以后遇到基本就这几个） 又出现 multi_v7_defconfig ARM 说明你某次终端里残留了 ARCH=arm CROSS_COMPILE=...。 解决： unset ARCH CROSS_COMPILE CC HOSTCC LLVM clangd 报大量 “找不到 generated headers autoconf.h” 通常是你没跑 prepare modules_prepare： make O=../build-x86_64 ARCH=x86_64 prepare modules_prepare 你换了 .config 之后（比如 menuconfig），clangd 解析又乱了 重新跑一遍： make O=../build-x86_64 ARCH=x86_64 olddefconfigmake O=../build-x86_64 ARCH=x86_64 prepare modules_preparepython3 scripts/clang-tools/gen_compile_commands.py -d ../build-x86_64 如果你告诉我：你最终把 compile_commands.json 放在源码目录还是 build 目录，我可以给你一份完全匹配你路径的 .vscode/settings.json（直接复制粘贴即可）。 compile_commands.json放在build目录 好，那就按“compile_commands.json 在 build 目录”的最省事做法来（你基本只要照抄路径就行）。 1) 生成与更新（放到 build 目录）在源码目录执行： cd ~/linux_kernel/linux-6.18.1unset ARCH CROSS_COMPILE CC HOSTCC LLVM# 生成/更新配置与 generated 头文件（clangd 必需）make O=../build-x86_64 ARCH=x86_64 x86_64_defconfigmake O=../build-x86_64 ARCH=x86_64 prepare modules_prepare# 生成 compile_commands.json（输出到 build 目录）python3 scripts/clang-tools/gen_compile_commands.py -d ../build-x86_64mv -f compile_commands.json ../build-x86_64/ 验证一下： ls -l ../build-x86_64/compile_commands.json 以后改过 .config 或拉新代码后，只要重复 prepare modules_prepare + 重新生成 compile_commands.json 就行。 2) VSCode（WSL）配置 clangd（直接可用）在源码根目录创建修改： .vscode/settings.json clangd.arguments: [ --background-index, --compile-commands-dir=/home/dky/linux_kernel/build-x86_64, --header-insertion=never, --clang-tidy=false, -j=8 ], C_Cpp.intelliSenseEngine: disabled 把这一路径按你真实路径改成对应的绝对路径即可（你现在的结构看起来就是 /home/dky/linux_kernel/build-x86_64）。 3) 一眼判断 clangd 是否吃到 compile_commands在 VSCode 里打开 View → Output → clangd，你应该能看到它加载 compile commands 的日志。 如果你想命令行快速验证路径是否对（可选）： realpath ~/linux_kernel/build-x86_64/compile_commands.json 4) 最常见的“能跳一部分、但很多红线”一般是 build 目录里缺生成头文件。补一遍就好： make O=~/linux_kernel/build-x86_64 ARCH=x86_64 prepare modules_prepare 如果你愿意贴一下 realpath ~/linux_kernel/build-x86_64 的输出（就一行），我可以把 settings.json 里的路径替你写成完全准确的一份。 编译buildroot参考：The Buildroot user manual 官网上下载：https://buildroot.org/downloads/ 选择一个版本，每个文件名的结构是：buildroot-版本号.压缩格式(.sign)。rc 是候选版本（release candidate），后面的 r2、r3 是修订版，tar.bz2 和 tar.gz 是压缩格式，还有.sign 是签名文件。 因此排除掉rc版本，排除掉带sign的验证文件，这里选一个2020年2月份发布的最后一个稳定版本。点击下载：buildroot-2020.02.12.tar.bz2 tar -xjf buildroot-2020.02.12.tar.bz2cd buildroot-2020.02.12 配置： 选 QEMU 的x86_64相关 defconfig，可以执行：make list-defconfigs 会输出可用的 defconfig 列表，随便选一个，比如:qemu_x86_64_defconfig make qemu_x86_64_defconfig 编译： make V=1 编译产物 ls -lh output/images 运行： 用 QEMU 启动，如果 output/images/ 里有 bzImage 和 rootfs.ext2，（纯串口模式）： qemu-system-x86_64 \\ -kernel output/images/bzImage \\ -drive file=output/images/rootfs.ext2,format=raw \\ -append root=/dev/sda console=ttyS0 \\ -nographic 遇到问题： “真错误点”在 host-m4-1.4.18 这一步，不是配错了。日志里关键报错是： 在 c-stack.c 里做预处理判断：SIGSTKSZ 16384 但你当前系统的 glibc 把 SIGSTKSZ 变成了运行时 sysconf(...)（不再是编译期常量），所以预处理器直接炸：missing binary operator before token (【pasted】 这正是 glibc 2.34+ 的典型兼容性坑：当 _GNU_SOURCE 等启用时 SIGSTKSZ 变成 sysconf(_SC_SIGSTKSZ)，老版本 m4gnulib 会在 #if 里用它从而编译失败。GitHub+1 ✅ 推荐最快修复（在 2020.02.12 里打一个补丁）Buildroot 社区已经给 m4 回补过修复补丁（“c-stack: stop using SIGSTKSZ”）。Buildroot Lists+1 在 buildroot-2020.02.12 目录执行： # 1) 下载补丁到 Buildroot 的 m4 包目录（Buildroot 会自动应用该目录下的 *.patch）mkdir -p package/m4curl -L https://download.automotivelinux.org/AGL/release/lamprey/12.1.17/qemuarm/deploy/sources/arm-agl-linux-gnueabi/m4-1.4.18-r0/0001-c-stack-stop-using-SIGSTKSZ.patch \\ -o package/m4/0001-c-stack-stop-using-SIGSTKSZ.patch# 2) 清掉失败的 host-m4，重新编make host-m4-dircleanmake 日志里那些 _FORTIFY_SOURCE redefined 都只是 warning，不影响；真正导致退出的是上面这个 SIGSTKSZ 的预处理错误。","tags":["linux","kernel"],"categories":["linux"]},{"title":"LVGL移植到IMX6ULL笔记","path":"/2024/12/20/LVGL移植到IMX6ULL/","content":"LVGL移植到IMX6ULL笔记所需库文件及版本问题所需库文件及版本如下： 库文件 版本 仓库地址 描述 lv_port_linux_frame_buffer releasev8.2 https://github.com/lvgl/lv_port_linux.git 适配有frame buffer的linux系统的接口 lv_drivers releasev8.2(49c4b17) https://github.com/lvgl/lv_drivers.git 包含了驱动LVGL图形界面的驱动接口源代码 lvgl releasev8.2.0(0b5a1d4) https://github.com/lvgl/lvgl.git LVGL图形库源代码,包含所需demo 注意一定要版本对应，不然会出现各种稀奇古怪的问题，可以使用下面的方法下载特定版本： 选择对应版本后，选择Download ZIP 使用git命令克隆特定版本 先git整个仓库 git clone https://github.com/lvgl/lvgl.git 然后切换到对应版本 git checkout v8.2.0 移植文件将上述下载到的lv_drivers lvgl 和 lv_port_linux_frame_buffer中 main.c和 Makefile文件的 放在同一目录下，比如我放在了新建的lvgl_demo目录下。将lvgl_demolvgllv_conf_template.h复制到lvgl_demo下并且改名位lvgl_demolv_conf.h将lvgl_demolv_driverslv_drv_conf_template.h复制到lvgl_demo下并且改名位lvgl_demolv_drv_conf.h此时查看 book@100ask:~/Desktop/lvgl_demo2$ lslv_conf.h lv_drivers lv_drv_conf.h lvgl main.c Makefile 此时目录结构为： lvgl_demo├── lvgl├── lv_drivers├── lv_conf.h├── lv_drv_conf.h├── main.c└── Makefile 二级目录使用tree -L 2查看我的lvgl_demo目录结构如下： lvgl_demo├── lv_conf.h├── lv_drivers│ ├── CMakeLists.txt│ ├── display│ ├── docs│ ├── gtkdrv│ ├── indev│ ├── library.json│ ├── LICENSE│ ├── lv_drivers.mk│ ├── lv_drv_conf_template.h│ ├── README.md│ ├── sdl│ ├── wayland│ ├── win32drv│ ├── win_drv.c│ ├── win_drv.h│ └── win_drv.o├── lv_drv_conf.h├── lvgl│ ├── CMakeLists.txt│ ├── component.mk│ ├── demos│ ├── docs│ ├── env_support│ ├── examples│ ├── idf_component.yml│ ├── Kconfig│ ├── library.json│ ├── library.properties│ ├── LICENCE.txt│ ├── lv_conf_template.h│ ├── lvgl.h│ ├── lvgl.mk│ ├── README.md│ ├── README_zh.md│ ├── SConscript│ ├── scripts│ ├── src│ └── tests├── main.c└── Makefile 修改配置文件修改lv_drv_conf.h 使能驱动将#if 1 /*Set it to 1 to enable the content*/改为#if 1 /*Set it to 1 to enable the content*/ 使能frame buffer设备，将USE_FBDEV的值改为1/*----------------------------------------- * Linux frame buffer device (/dev/fbx) *-----------------------------------------*/#ifndef USE_FBDEV# define USE_FBDEV 1#endif#if USE_FBDEV# define FBDEV_PATH /dev/fb0#endif 使能USE_EVDEV，将devinputevent0改为devinputevent1,这里是使触摸设备生效 /*-------------------------------------------------* Mouse or touchpad as evdev interface (for Linux based systems)*------------------------------------------------*/#ifndef USE_EVDEV# define USE_EVDEV 1#endif#ifndef USE_BSD_EVDEV# define USE_BSD_EVDEV 0#endif#if USE_EVDEV || USE_BSD_EVDEV# define EVDEV_NAME /dev/input/event1 /*You can use the evtest Linux tool to get the list of devices and test them*/# define EVDEV_SWAP_AXES 0 /*Swap the x and y axes of the touchscreen*/# define EVDEV_CALIBRATE 0 /*Scale and offset the touchscreen coordinates by using maximum and minimum values for each axis*/ 修改lv_conf.h 使能，这里和上述步骤相同将#if 1 /*Set it to 1 to enable the content*/改为#if 1 /*Set it to 1 to enable the content*/ 修改显存大小可以使能LV_MEM_CUSTOM自己分配也可以自动分配，我选择的是自己分配显存：/*1: use custom malloc/free, 0: use the built-in `lv_mem_alloc()` and `lv_mem_free()`*/#define LV_MEM_CUSTOM 1#if LV_MEM_CUSTOM == 0 /*Size of the memory available for `lv_mem_alloc()` in bytes (= 2kB)*/ #define LV_MEM_SIZE (48U * 1024U) /*[bytes]*/ /*Set an address for the memory pool instead of allocating it as a normal array. Can be in external SRAM too.*/ #define LV_MEM_ADR 0 /*0: unused*/ /*Instead of an address give a memory allocator that will be called to get a memory pool for LVGL. E.g. my_malloc*/ #if LV_MEM_ADR == 0 //#define LV_MEM_POOL_INCLUDE your_alloc_library /* Uncomment if using an external allocator*/ //#define LV_MEM_POOL_ALLOC your_alloc /* Uncomment if using an external allocator*/ #endif #else /*LV_MEM_CUSTOM*/ #define LV_MEM_CUSTOM_INCLUDE stdlib.h /*Header for the dynamic memory function*/ #define LV_MEM_CUSTOM_ALLOC malloc #define LV_MEM_CUSTOM_FREE free #define LV_MEM_CUSTOM_REALLOC realloc#endif /*LV_MEM_CUSTOM*/ 刷新时间可修改可以不修改，记录说明这里可以按需修改/*====================HAL SETTINGS*====================*/ /*Default display refresh period. LVG will redraw changed areas with this period time*/#define LV_DISP_DEF_REFR_PERIOD 10 /*[ms]*/ /*Input device read period in milliseconds*/#define LV_INDEV_DEF_READ_PERIOD 10 /*[ms]*/ TICK的配置这里选择自己定义一个Tick定时器配置函数,更改后的配置如下：/*Use a custom tick source that tells the elapsed time in milliseconds.*It removes the need to manually update the tick with `lv_tick_inc()`)*/uint32_t custom_tick_get(void);#define LV_TICK_CUSTOM 1#if LV_TICK_CUSTOM#define LV_TICK_CUSTOM_INCLUDE stdint.h /*Header for the system time function*/#define LV_TICK_CUSTOM_SYS_TIME_EXPR (custom_tick_get()) /*Expression evaluating to current system time in ms*/#endif /*LV_TICK_CUSTOM*/ LV_COLOR_DEPTH设置/*====================COLOR SETTINGS*====================*/ /*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/#define LV_COLOR_DEPTH 32 /*Swap the 2 bytes of RGB565 color. Useful if the display has an 8-bit interface (e.g. SPI)*/#define LV_COLOR_16_SWAP 0 颜色深度设置为32位，容易遗忘的设置，否则lvgl颜色显示不正常 使能相应的demo模板这里使用的是LV_USE_DEMO_WIDGETS /*=================== * DEMO USAGE ====================*//*Show some widget. It might be required to increase `LV_MEM_SIZE` */#define LV_USE_DEMO_WIDGETS 1#if LV_USE_DEMO_WIDGETS#define LV_DEMO_WIDGETS_SLIDESHOW 0#endif 修改main.c 修改显示器分辨率disp_drv.hor_res = 1024;disp_drv.ver_res = 600; 注释鼠标输入/*Set a cursor for the mouse*/ // LV_IMG_DECLARE(mouse_cursor_icon) // lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */ // lv_img_set_src(cursor_obj, mouse_cursor_icon); /*Set the image source*/ // lv_indev_set_cursor(mouse_indev, cursor_obj); /*Connect the image object to the driver*/ 注释其他不需要的地方，防止编译不通过，比如：// #include lvgl/demos/lv_demos.h 到这里main函数就修改完了，注意到main.c中就有custom_tick_get实现，其他可以按需修改完整的main.c代码如下： #include lvgl/lvgl.h// #include lvgl/demos/lv_demos.h#include lv_drivers/display/fbdev.h#include lv_drivers/indev/evdev.h#include unistd.h#include pthread.h#include time.h#include sys/time.h// #define DISP_BUF_SIZE (128 * 1024)#define DISP_BUF_SIZE (1024 * 600)int main(void) /*LittlevGL init*/ lv_init(); /*Linux frame buffer device init*/ fbdev_init(); /*A small buffer for LittlevGL to draw the screens content*/ static lv_color_t buf[DISP_BUF_SIZE]; /*Initialize a descriptor for the buffer*/ static lv_disp_draw_buf_t disp_buf; lv_disp_draw_buf_init(disp_buf, buf, NULL, DISP_BUF_SIZE); /*Initialize and register a display driver*/ static lv_disp_drv_t disp_drv; lv_disp_drv_init(disp_drv); disp_drv.draw_buf = disp_buf; disp_drv.flush_cb = fbdev_flush; disp_drv.hor_res = 1024; disp_drv.ver_res = 600; lv_disp_drv_register(disp_drv); evdev_init(); // static lv_indev_drv_t indev_drv_1; // lv_indev_drv_init(indev_drv_1); /*Basic initialization*/ // indev_drv_1.type = LV_INDEV_TYPE_POINTER; // /*This function will be called periodically (by the library) to get the mouse position and state*/ // indev_drv_1.read_cb = evdev_read; // lv_indev_t *mouse_indev = lv_indev_drv_register(indev_drv_1); /* Initialize and register a display input driver */ lv_indev_drv_t indev_drv; lv_indev_drv_init(indev_drv); /*Basic initialization*/ indev_drv.type = LV_INDEV_TYPE_POINTER; indev_drv.read_cb = evdev_read; lv_indev_t * my_indev = lv_indev_drv_register(indev_drv); /*Set a cursor for the mouse*/ // LV_IMG_DECLARE(mouse_cursor_icon) // lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */ // lv_img_set_src(cursor_obj, mouse_cursor_icon); /*Set the image source*/ // lv_indev_set_cursor(mouse_indev, cursor_obj); /*Connect the image object to the driver*/ /*Create a Demo*/ // lv_demo_widgets(); lv_demo_music(); /*Handle LitlevGL tasks (tickless mode)*/ while(1) lv_timer_handler(); usleep(5000); return 0;/*Set in lv_conf.h as `LV_TICK_CUSTOM_SYS_TIME_EXPR`*/uint32_t custom_tick_get(void) static uint64_t start_ms = 0; if(start_ms == 0) struct timeval tv_start; gettimeofday(tv_start, NULL); start_ms = (tv_start.tv_sec * 1000000 + tv_start.tv_usec) / 1000; struct timeval tv_now; gettimeofday(tv_now, NULL); uint64_t now_ms; now_ms = (tv_now.tv_sec * 1000000 + tv_now.tv_usec) / 1000; uint32_t time_ms = now_ms - start_ms; return time_ms; Makefile配置 修改了交叉编译工具链为：CC := arm-buildroot-linux-gnueabihf-gcc. 使用echo $CROSS_COMPILE可以查看交叉编译链是什么 将鼠标样式的连接源文件注释掉# CSRCS +=$(LVGL_DIR)/mouse_cursor_icon.c 完整的Makefile如下： ## Makefile## CC ?= gccCC := arm-buildroot-linux-gnueabihf-gccLVGL_DIR_NAME ?= lvglLVGL_DIR ?= $shell pwdCFLAGS ?= -O3 -g0 -I$(LVGL_DIR)/ -Wall -Wshadow -Wundef -Wmissing-prototypes -Wno-discarded-qualifiers -Wall -Wextra -Wno-unused-function -Wno-error=strict-prototypes -Wpointer-arith -fno-strict-aliasing -Wno-error=cpp -Wuninitialized -Wmaybe-uninitialized -Wno-unused-parameter -Wno-missing-field-initializers -Wtype-limits -Wsizeof-pointer-memaccess -Wno-format-nonliteral -Wno-cast-qual -Wunreachable-code -Wno-switch-default -Wreturn-type -Wmultichar -Wformat-security -Wno-ignored-qualifiers -Wno-error=pedantic -Wno-sign-compare -Wno-error=missing-prototypes -Wdouble-promotion -Wclobbered -Wdeprecated -Wempty-body -Wtype-limits -Wshift-negative-value -Wstack-usage=2048 -Wno-unused-value -Wno-unused-parameter -Wno-missing-field-initializers -Wuninitialized -Wmaybe-uninitialized -Wall -Wextra -Wno-unused-parameter -Wno-missing-field-initializers -Wtype-limits -Wsizeof-pointer-memaccess -Wno-format-nonliteral -Wpointer-arith -Wno-cast-qual -Wmissing-prototypes -Wunreachable-code -Wno-switch-default -Wreturn-type -Wmultichar -Wno-discarded-qualifiers -Wformat-security -Wno-ignored-qualifiers -Wno-sign-compareLDFLAGS ?= -lmBIN = demo#Collect the files to compileMAINSRC = ./main.cinclude $(LVGL_DIR)/lvgl/lvgl.mkinclude $(LVGL_DIR)/lv_drivers/lv_drivers.mk# include $(LVGL_DIR)/lv_demos/lv_demos.mk# CSRCS +=$(LVGL_DIR)/mouse_cursor_icon.c OBJEXT ?= .oAOBJS = $(ASRCS:.S=$(OBJEXT))COBJS = $(CSRCS:.c=$(OBJEXT))MAINOBJ = $(MAINSRC:.c=$(OBJEXT))SRCS = $(ASRCS) $(CSRCS) $(MAINSRC)OBJS = $(AOBJS) $(COBJS)## MAINOBJ - OBJFILESall: default%.o: %.c\t@$(CC) $(CFLAGS) -c $ -o $@\t@echo CC $ default: $(AOBJS) $(COBJS) $(MAINOBJ)\t$(CC) -o $(BIN) $(MAINOBJ) $(AOBJS) $(COBJS) $(LDFLAGS)\tmkdir -p $(LVGL_DIR)/obj $(LVGL_DIR)/bin\tmv *.o $(LVGL_DIR)/obj/\tmv $(BIN) $(LVGL_DIR)/bin/clean: rm -f $(BIN) $(AOBJS) $(COBJS) $(MAINOBJ) ./bin/* ./obj/* 运行和结果 使用make编译后，将生成demo可执行文件。然后通过mount挂载，将编译好的demo放到开发板的mnt目录下 开发板上切换到mnt目录，执行.demo运行 结果 注意事项1.注意版本一致，不然容易出现各种各样稀奇古怪的问题，有可能无法编译。我甚至遇到过编译成功之后出来的可执行文件是64位的，而开发板是32位的，导致无法运行。2.修改配置或者源码之后，如果不是预期的效果，可以试试先make clean，然后再make。 参考链接【嵌入式Linux应用开发】1. 移植LVGL到Linux开发板","tags":["嵌入式","LVGL"],"categories":["LVGL"]},{"title":"IMX6ULL移除及恢复原有UI","path":"/2024/12/15/移除及恢复原有UI/","content":"IMX6ULL移除及恢复原有UI有时候需要移除掉IMX6ULL原本的UI，恢复成默认的界面，方便我们做一些LVGL的测试或者运行其他的图形界面。 进入/etc/init.d/目录 进入/etc/init.d/目录下，可以看到有以下文件：其中S99myirhmi2就是我们的目标文件 移除S99myirhmi2移动S99myirhmi2的启动脚本到/root目录下，防止开机时自动启动，使用命令： mv /etc/init.d/S99myirhmi2 /root/sync 移除成功后，重启设备。 reboot 这样就不会进入myirhmi2了,如下，会卡在这个界面： 恢复原有 UI 如果想恢复原有 UI，则执行以下命令即可： mv /root/S99myirhmi2 /etc/init.d/sync 再reboot重启即可恢复 关闭自动黑屏注意：以下命令重启后均失效执行： echo -e \\033[9;0] /dev/tty0 重新启用自动黑屏： echo -e \\033[9;1] /dev/tty0 打开光标 echo -e \\033[?25h /dev/tty1 关闭光标 echo -e “\\033[?25l” /dev/tty1","tags":["ubuntu","UI"],"categories":["UBUNTU"]},{"title":"catkin_make 编译出错","path":"/2024/10/31/catkin_make编译出错/","content":"catkin_make 编译出错报错：usrbinld: 找不到 -lncurses原因：找不到相应的libncurses.so动态库，库文件没有导入到ld检索目录 解决方法：1.使用locate定位libncurses.so locate libncurses.so 输出： /snap/core/17200/lib/x86_64-linux-gnu/libncurses.so.5/snap/core/17200/lib/x86_64-linux-gnu/libncurses.so.5.9/snap/core20/2379/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core20/2379/usr/lib/x86_64-linux-gnu/libncurses.so.6.2/snap/core20/2434/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core20/2434/usr/lib/x86_64-linux-gnu/libncurses.so.6.2/snap/core22/1621/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core22/1621/usr/lib/x86_64-linux-gnu/libncurses.so.6.3/snap/core22/1663/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core22/1663/usr/lib/x86_64-linux-gnu/libncurses.so.6.3/usr/lib/x86_64-linux-gnu/libncurses.so.6/usr/lib/x86_64-linux-gnu/libncurses.so.6.2 随便找一个进行软链接 sudo ln -s /usr/lib/x86_64-linux-gnu/libncurses.so.6 /usr/lib/libncurses.so 更新库缓存 sudo ldconfig 重新catkin_make编译参考链接：https://blog.csdn.net/qq_34761779/article/details/126665354","tags":["ros","笔记"],"categories":["ROS"]},{"title":"roslaunch 出错","path":"/2024/10/31/roslaunch出错/","content":"roslaunch 出错报错：homedkutouch_wsdevellibomni_commonomni_state: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory 原因：缺少libncurses.so.5共享库 解决方法：1.安装libncurses.so.5共享库 sudo apt-get updatesudo apt-get install libncurses5 重新运行roslaunch omni_common omni.launch参考链接：https://blog.csdn.net/qq_38236680/article/details/142253345 接着遇到：Failed to initialize haptic device报错具体报错信息：[ERROR] [1730784892.557095854]: Failed to initialize haptic device[omni_state-1] process has died [pid 13774, exit code 255, cmd homedkutouch_wsdevellibomni_commonomni_state __name:omni_state __log:homedku.roslog6a3020f8-9b2e-11ef-82db-71f799b1505aomni_state-1.log].log file: homedku.roslog6a3020f8-9b2e-11ef-82db-71f799b1505aomni_state-1*.log解决方法：把touch驱动程序关了….这点很坑","tags":["ros","笔记"],"categories":["ROS"]},{"title":"vscode中找不到ros中的一些头文件","path":"/2024/10/31/vscode中找不到ros中的一些头文件/","content":"vscode中找不到ros中的一些头文件一个小问题在VSCode中，我们通常使用ROS的C++开发，但是ROS的C++开发需要使用ROS的API，但是ROS的API在VSCode中找不到，头文件也找不到，但是编译是可以成功的，说明只是vscode的配置问题。最最重要的是，vscode找不到头文件，在写代码的时候就没有代码提示，就无法知道变量下还有哪些值，这就导致根本就无法写代码。例如在头文件中找不到#include sensor_msgs/JointState.h头文件，解决方法如下：经过查找，JointState.h位于/opt/ros/noetic/include/sensor_msgs/JointState.h 在c_cpp_properties.json中添加如下配置： includePath: [ $workspaceFolder/**, /opt/ros/noetic/include], 接着source devel/setup.bash,就会发现头文件下的波浪线消失了，也可以正常打开JointState.h文件。PS:在一开始的解决方案里，在CMakeLists.txt中添加了include_directories(${Boost_INCLUDE_DIR} ${catkin_INCLUDE_DIRS} /opt/ros/noetic/include)，但是cmake是编译的时候才去查找头文件，所以还是需要添加到c_cpp_properties.json中，可以不用管CMakeLists.txt.","tags":["vscode配置"],"categories":["C++笔记"]},{"title":"运算符重载小知识点","path":"/2024/10/31/运算符重载小知识点/","content":"运算符重载小知识点在 C++ 中，运算符重载可以通过成员函数或友元函数来实现。对于成员函数形式的运算符重载，输入参数的数量确实看起来只有一个，但实际上有两个参数： 隐式参数：即调用该运算符的对象本身。在成员函数中，这个对象可以通过 this 指针访问。显式参数：即传递给成员函数的参数 Complex c1(3.5, 2.0);Complex c2(1.0, 4.0);Complex sum = c1 + c2; 在这个例子中，c1 + c2 实际上被编译器解释为 c1.operator+(c2)。这里： c1 是隐式参数，对应 this 指针。c2 是显式参数，传递给 operator+ 函数。因此，虽然 operator+ 函数的定义中只有一个参数，但在实际调用时，c1 和 c2 都参与了运算。 ## 完整代码#include iostreamclass Complex private: double real; double imag;public: // 构造函数 Complex(double r = 0, double i = 0) : real(r), imag(i) // 加法运算符重载 Complex operator+(const Complex other) const Complex result; result.real = this-real + other.real; result.imag = this-imag + other.imag; return result; // 减法运算符重载 Complex operator-(const Complex other) const return Complex(real - other.real, imag - other.imag); // 输出运算符重载 friend std::ostream operator(std::ostream os, const Complex c) os c.real + c.imag i; return os; ;int main() Complex c1(3.5, 2.0); Complex c2(1.0, 4.0); Complex sum = c1 + c2; Complex diff = c1 - c2; std::cout c1: c1 std::endl; std::cout c2: c2 std::endl; std::cout c1 + c2: sum std::endl; std::cout c1 - c2: diff std::endl; return 0; 完","tags":["c++","运算符重载"],"categories":["C++笔记"]},{"title":"Cmake构建自动化编译环境","path":"/2024/10/30/Cmake构建自动化编译环境/","content":"Cmake构建自动化编译环境完整项目文件结构：一个完整的项目应该包括如下文件结构： ProjectName/├── CMakeLists.txt├── src/│ ├── main.cpp│ ├── xxx.cpp│ └── yyy.cpp├── include/│ ├── xxx.h│ └── yyy.h│── build/│── lib/└── test/example/├── thridparty/├── README.md└── autobuild.sh bin:生成的可执行文件 lib：生成的中间库文件 include: src: build:编译过程中产生的临时文件 testexample:示意文件 thridparty:第三方库文件 CMakeLists.txs: autobuild.sh:一键编译，其实就是执行的cmake文件 license: readme: ChatServer文件结构ChatServer/├── .vscode/├── src/│ ├── server│ │ ├── chat_server.cpp│ │ └── CmakeLists.txt│ ││ └── client│ ├── chat_client.cpp│ └── CmakeLists.txt├── include/│ ├── chat_server.h│ ├── chat_client.h│ └── otherfile.h├── build/Makefile├── bin/│ └── 生成的可执行文件├── thridparty/ │ └── json.hpp├── test/├── CMakeLists.txt├── README.md└── autobuild.sh CMakeLists.txt文件解释从顶层开始，每一个子目录下都有自己的CMakeLists.txt文件.下面是每一层的CMakeLists.txt文件,非常不完善，正在补充中… 顶层CMakeLists，路径：chatserverCMakeLists.txt cmake_minimum_required(VERSION 3.0)project(chat)# 配置编译选项set(CMAKE_CXX_FLAGS $CMAKE_CXX_FLAGS -g)# 添加子目录#配置最终的可执行文件的输出路径,PROJECT_SOURCE_DIR表示当前项目的根目录set(EXECUTABLE_OUTPUT_PATH $PROJECT_SOURCE_DIR/bin)#配置头文件的搜索路径include_directories($PROJECT_SOURCE_DIR/include)include_directories($PROJECT_SOURCE_DIR/include/server)#加载子目录,子目录下也需要有CMakeLists.txt文件，子目录都写在src文件下add_subdirectory(src) src中CMakeLists，路径：chatserversrcCMakeLists.txt #添加子目录，在server目录下也有一个CMakeLists.txt文件add_subdirectory(server) srcserver中CMakeLists，路径：chatserversrcserverCMakeLists.txt #定义了一个SRC_LIST变量，包含当前目录下所有的源文件aux_source_directory(. SRC_LIST)#由所有源码生成可执行文件,指定生成可执行文件的名称为ChatServeradd_executable(ChatServer $SRC_LIST)#指定可执行文件需要链接时所依赖的库，muduo_net muduo_base pthreadtarget_link_libraries(ChatServer muduo_net muduo_base pthread) srcclient中CMakeLists，路径：chatserversrcclientCMakeLists.txt # 定义了一个SRC_LIST变量，包含了该目录下所有的源文件aux_source_directory(. SRC_LIST)# 指定生成可执行文件add_executable(ChatClient $SRC_LIST)# 指定可执行文件链接时需要依赖的库文件target_link_libraries(ChatClient pthread) 执行命令：cmake . 或者 cmake ..在哪里执行cmake，就会在哪里生成中间文件和可执行文件因此可以进入build目录执行cmake ..命令，这样生成的文件就在build目录下 未完待续…","tags":["c++","linux","Cmake"],"categories":["LINUX"]},{"title":"Makefile总结及通用模板使用","path":"/2024/10/18/Makefile总结及通用模板使用/","content":"Makefile总结及通用模板使用项目结构./├── a│ ├── Makefile│ ├── sub2.c│ └── sub3.c├── include│ ├── sub2.h│ ├── sub3.h│ └── sub.h├── main.c├── Makefile├── Makefile.build└── sub.c 示例C代码C代码只是作为示例，为了不影响阅读见附录 makefile文件顶层目录下的MakefileCROSS_COMPILE = AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nmSTRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMPCFLAGS := -Wall -O2 -gCFLAGS += -I $(shell pwd)/includeLDFLAGS := export CFLAGS LDFLAGSTOPDIR := $(shell pwd)export TOPDIRTARGET := testobj-y += main.oobj-y += sub.oobj-y += a/# print:# @echo $(TARGET)# @echo $(shell find -name *.o)# @echo obj-y=$(obj-y)# @echo TOPDIR=$(TOPDIR)# TOPDIR=/home/book/Documents/makefile_learn/general_Makefile/example# 执行make 会执行第一个 all 目标。all 分成两个依赖 start_recursive_build 和 $(TARGET)all : start_recursive_build $(TARGET)\t@echo $(TARGET) has been built!start_recursive_build:\t@echo ------------------start_recursive_build begin---------------------\tmake -C ./ -f $(TOPDIR)/Makefile.build\t@echo ------------------start_recursive_build end------------------------$(TARGET) : start_recursive_build\t@echo -------------------------test begin---------------------------------\t$(CC) -o $(TARGET) built-in.o $(LDFLAGS)\t@echo -------------------------test end-----------------------------------clean:\trm -f $(shell find -name *.o)\trm -f $(TARGET)distclean:\trm -f $(shell find -name *.o)\trm -f $(shell find -name *.d)\trm -f $(TARGET) 顶层目录下的Makefile.buildPHONY := __build__build:# 先清空obj-y :=subdir-y :=EXTRA_CFLAGS :=# 再包含 Makefileinclude Makefile# obj-y := a.o b.o c/ d/# $(filter %/, $(obj-y)) : c/ d/# __subdir-y : c d# subdir-y : c d__subdir-y\t:= $(patsubst %/,%,$(filter %/, $(obj-y)))subdir-y\t+= $(__subdir-y)# c/built-in.o d/built-in.osubdir_objs := $(foreach f,$(subdir-y),$(f)/built-in.o)# a.o b.ocur_objs := $(filter-out %/, $(obj-y))dep_files := $(foreach f,$(cur_objs),.$(f).d)dep_files := $(wildcard $(dep_files))ifneq ($(dep_files),) include $(dep_files)endifPHONY += $(subdir-y)# 依赖于子目录a 依赖于built-in.o__build : $(subdir-y) built-in.o# 先去处理子目录a# make -C 进入子目录a,使用顶层的makefile.build来处理这个子目录,即就是这个makefile.build。#子目录中的makefile会对标志位，文件啥的进行赋值，然后执行%.o : %.c下面的规则。$(subdir-y):\t@echo --------------------subdir-y begin---------------------------\t@echo subdir-y=$(subdir-y)\t@echo @=$@\t@echo TOPDIR=$(TOPDIR)\tmake -C $@ -f $(TOPDIR)/Makefile.build\t@echo --------------------subdir-y end---------------------------#这一部分递归了好几次，第一次递归：在子目录a下生成a/built-in.o# 这里subdir-y subdir_objs都为空 cur_objs=sub2.o sub3.o,即ld -r -o built-in.o sub2.o sub3.o obj-y= sub2.o sub3.o# 第二次递归：ld -r -o built-in.o main.o sub.o a/built-in.obuilt-in.o : $(subdir-y) $(cur_objs)\t@echo --------------------built-in.o begin---------------------------\t@echo subdir-y=$(subdir-y)\t@echo @=$@\t@echo cur_objs=$(cur_objs)\t@echo subdir_objs=$(subdir_objs)\t@echo obj-y=$(obj-y)\t@echo CFLAGS_sub3.o=$(CFLAGS_sub3.o)\t$(LD) -r -o $@ $(cur_objs) $(subdir_objs)\t@echo --------------------built-in.o end---------------------------dep_file = .$@.d%.o : %.c\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$@) -Wp,-MD,$(dep_file) -c -o $@ $\t.PHONY : $(PHONY) 子目录下的Makefile目录：a/Makefile # -D 即define 相当于在头文件中定义了宏：DEBUGEXTRA_CFLAGS := -D DEBUG# 单独给sub3.c 定义了宏：DEBUG_SUB3 只适用于sub3.o 并不适用sub2.oCFLAGS_sub3.o := -D DEBUG_SUB3obj-y += sub2.o obj-y += sub3.o make输出结果make -C ./ -f /home/book/Makefile_example/Makefile.buildmake[1]: Entering directory /home/book/Makefile_example--------------------subdir-y begin---------------------------subdir-y= a@=aTOPDIR=/home/book/Makefile_examplemake -C a -f /home/book/Makefile_example/Makefile.buildmake[2]: Entering directory /home/book/Makefile_example/agcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -Wp,-MD,.sub2.o.d -c -o sub2.o sub2.cgcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -D DEBUG_SUB3 -Wp,-MD,.sub3.o.d -c -o sub3.o sub3.c--------------------built-in.o begin---------------------------subdir-y=@=built-in.ocur_objs=sub2.o sub3.osubdir_objs=obj-y= sub2.o sub3.oCFLAGS_sub3.o=-D DEBUG_SUB3ld -r -o built-in.o sub2.o sub3.o --------------------built-in.o end---------------------------make[2]: Leaving directory /home/book/Makefile_example/a--------------------subdir-y end---------------------------gcc -Wall -O2 -g -I /home/book/Makefile_example/include -Wp,-MD,.main.o.d -c -o main.o main.cgcc -Wall -O2 -g -I /home/book/Makefile_example/include -Wp,-MD,.sub.o.d -c -o sub.o sub.c--------------------built-in.o begin---------------------------subdir-y= a@=built-in.ocur_objs=main.o sub.osubdir_objs=a/built-in.oobj-y= main.o sub.o a/CFLAGS_sub3.o=ld -r -o built-in.o main.o sub.o a/built-in.o--------------------built-in.o end---------------------------make[1]: Leaving directory /home/book/Makefile_example------------------start_recursive_build end-------------------------------------------------test begin---------------------------------gcc -o test built-in.o -------------------------test end-----------------------------------test has been built! 分析过程1.顶层目录执行make之后，先会执行第一个目标all ，all依赖于start_recursive_build和$(TARGET),$(TARGET)即最终生成的test。所以先会执行start_recursive_build这个目标下的规则来生成built-in.o，接着执行test这个目标下的规则，将生成的built-in.o文件链接生成test最终文件 2.最重要的是start_recursive_build begin这个目标如何在各个源代码目录下生成各自的built-in.o. 2.1执行make -C ./ -f $(TOPDIR)/Makefile.build命令，进入当前目录（还是当前目录，没变），使用顶层目录（还是当前目录）下的Makefile.build作为make执行的makefile文件。 2.1在Makefile.build文件中，首先是obj-y ,subdir-y，EXTRA_CFLAGS这些变量的清楚，然后再重新赋值。不再详细分析。主要看__build : $(subdir-y) built-in.o，在当前情况下subdir-y就是a，执行$(subdir-y):下的规则make -C $@ -f $(TOPDIR)/Makefile.build，进入a目录，使用顶层目录下的Makefile.build对a目录下的文件进行处理。因为a目录下的makefile做了一些变量的赋值操作，所以此时的obj-y= sub2.o sub3.o CFLAGS_sub3.o=-D DEBUG_SUB3。所以此时的%.o : %.c规则就展开成了这个样子 %.o : %.c\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(CF 展开为： gcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -Wp,-MD,.sub2.o.d -c -o sub2.o sub2.cgcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -D DEBUG_SUB3 -Wp,-MD,.sub3.o.d -c -o sub3.o sub3.c 这样就生成了sub2.o和sub3.o.但是此时还没完，因为我们的目标是在子目录下生成a/built-in.o 2.2在子目录a中当然也会执行到built-in.o : $(subdir-y) $(cur_objs),此时subdir-y为空，因为a下面没有子目录了。而cur_objs=sub2.o sub3.o。此时通过规则$(LD) -r -o $@ $(cur_objs) $(subdir_objs)来将sub2.o sub3.o链接成a/built-in.o。这个命令展开实际为： ld -r -o built-in.o sub2.o sub3.o 此时就完成了我们的任务：生成:a/built-in.o. 所以我们也可看到make输出：离开a文件夹 make[2]: Leaving directory /home/book/Makefile_example/a 3.回到主目录之后，继续使用makefile.build来处理顶层文件夹的源文件。比如将main.c sub.c文件转换成.o.d文件（当然在a目录下也做了这个工作）。接下来的工作就是生成顶层目录下的built-in.o文件。注意此时make已经切换到了顶层目录。此时subdir-y=a,cur_objs=main.o sub.o subdir_objs=a/built-in.o。此时通过规则$(LD) -r -o $@ $(cur_objs) $(subdir_objs)来将main.o sub.o a/built-in.o链接成顶层目录下的built-in.o 这个命令展开实际为 ld -r -o built-in.o main.o sub.o a/built-in.o 3.1至此，built-in.o的生成工作就大功告成了，此时可以看到make离开文件夹（不知道离开了没，我感觉没有），start_recursive_build endend. make[1]: Leaving directory /home/book/Makefile_example 4.现在顶层目录的built-in.o已经有了，顶层目录下的built-in.o汇聚了所有子目录的.o信息以及main.o的信息。只需要通过gcc -o test built-in.o 即可生成我们的最终目标test 5.最终start_recursive_build和$(TARGET)都有了，打印输出： test has been built! Makefile零碎知识点目标冒号后面没有依赖项的情况对于只有目标而没有依赖项的情况，说明该目标不依赖任何文件或者目标，直接执行后面的命令。这种情况一般用于伪目标。 常见的伪目标有：clean install help 清理操作 clean:\trm -f *.o 安装操作 install: modules_install\t$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@\tmodules_install:\t$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@ install 目标依赖于 modules_install，但这里我们关注的是 modules_install 自身。modules_install 没有依赖项，直接执行命令进入内核源码目录并安装模块 其执行逻辑大概就是make判断当前目标是否比依赖新，结果没有发现目标文件，当然不可能比依赖新，就执行后面的语句。但是当Makefile目录下如果有clean文件时候，再执行make时候就会提示make: clean is up to date.。如果想避免这种情况，就需要使用 .PHONY : clean告诉make clean是个伪目标，不管有没有clean这个文件。 为什么使用无依赖项的目标？ 伪目标：用于触发特定操作而非生成文件。例如，clean、install、help 等目标通常不生成实际文件，而是执行清理、安装或显示帮助信息等操作。 简化逻辑：某些操作不需要依赖其他文件或目标，直接执行命令即可。例如，清理操作只需要删除特定文件，而不需要等待其他文件生成。 灵活性：允许开发者定义任意数量的伪目标，方便扩展和维护 Makefile。 多个目标共享同一组命令modules modules_install help clean:\t$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@ 当调用这些目标中的任何一个时，都会执行相同的命令，即进入内核源码目录并根据目标名称执行相应的操作。 默认执行第一个目标如果有多个伪目标，默认情况下使用make命令指挥执行第一个目标。例如一个完整的Makefile内容如下(测试用例)，默认是执行第一个目标help，可以使用make clean执行clean目标。 help:\t@echo Available targets:\t@echo all - Build the module\t@echo install - Install the module\t@echo clean - Clean up build filesclean:\trm -f *.o make -C directory [target] -C directory：表示进入指定的目录 directory，然后在该目录中执行Make命令 [target]：可选参数，表示要执行的目标。如果没有指定目标，则默认执行Makefile中的第一个目标。 操作示例1：执行命令make -C test，输出为。这个案例的Makefile内容就是上文只包含help和clean的那个。 book@100ask:~/Documents/makefile_learn$ make -C testmake: Entering directory /home/book/Documents/makefile_learn/testAvailable targets: all - Build the module install - Install the module clean - Clean up build filesmake: Leaving directory /home/book/Documents/makefile_learn/test 操作示例2：执行命令make -C test clean book@100ask:~/Documents/makefile_learn$ make -C test clean make: Entering directory /home/book/Documents/makefile_learn/testrm -f *.omake: Leaving directory /home/book/Documents/makefile_learn/test make -C directory -f makefile -C directory：表示进入指定的目录 directory，然后在该目录中执行Make命令。 -f makefile：指定要使用的Makefile文件为 makefile。默认情况下，make 会查找名为 Makefile 或 makefile 的文件，但使用 -f 可以明确指定其他文件。 make -C ./ -f $(TOPDIR)/Makefile.build -C ./：表示进入当前目录（. 表示当前目录）。这通常用于确保在特定的工作目录中执行Make操作。 -f $(TOPDIR)/Makefile.build：指定使用位于 $(TOPDIR) 目录下的 Makefile.build 文件作为Makefile。$(TOPDIR) 是一个变量，通常定义为项目的顶层目录路径。 附录：示例C代码main.c#include stdio.hextern void sub_fun(void);extern void sub2_fun(void);void sub3_fun(void);int main(int argc, char* argv[]) printf(Main fun! ); sub_fun(); sub2_fun(); sub3_fun(); return 0; sub.c#include stdio.h#include sub.hvoid sub_fun(void) printf(Sub fun, A = %d! , A); asub2.c#include stdio.h#include sub2.hvoid sub2_fun(void) printf(Sub2 fun, B = %d! , B); #ifdef DEBUG\tprintf(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);#endif asub3.c#include stdio.h#include sub3.hvoid sub3_fun(void) printf(Sub3 fun, C = %d! , C);\t#ifdef DEBUG printf(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);#endif#ifdef DEBUG_SUB3 printf(It is only debug info for sub3. );#endif includesub.h#define A 1void sub_fun(void); includesub2.h#define B 2void sub2_fun(void); includesub3.h#define B 2void sub2_fun(void); Makefile模板顶层Makefile# 如果给pc机编译则不需要设置，如果给arm板编译则需要设置# arm-buildroot-linux-gnueabihf-CROSS_COMPILE = AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nmSTRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMPCFLAGS := -Wall -O2 -g# 以后所有的.c文件都会去 当前目录下的include目录下查找头文件，给所有的.c文件都要用到这个属性CFLAGS += -I $(shell pwd)/include# 链接选项 可以指定库在哪里，需要链接哪些库 LDFLAGS := -L dir -l libnameLDFLAGS := export CFLAGS LDFLAGSTOPDIR := $(shell pwd)export TOPDIRTARGET := testobj-y += main.oobj-y += sub.oobj-y += a/all : start_recursive_build $(TARGET)\t@echo $(TARGET) has been built!start_recursive_build:\tmake -C ./ -f $(TOPDIR)/Makefile.build$(TARGET) : start_recursive_build\t$(CC) -o $(TARGET) built-in.o $(LDFLAGS)clean:\trm -f $(shell find -name *.o)\trm -f $(TARGET)distclean:\trm -f $(shell find -name *.o)\trm -f $(shell find -name *.d)\trm -f $(TARGET) 顶层目录Makefile.buildPHONY := __build__build:obj-y :=subdir-y :=EXTRA_CFLAGS :=include Makefile# obj-y := a.o b.o c/ d/# $(filter %/, $(obj-y)) : c/ d/# __subdir-y : c d# subdir-y : c d__subdir-y\t:= $(patsubst %/,%,$(filter %/, $(obj-y)))subdir-y\t+= $(__subdir-y)# c/built-in.o d/built-in.osubdir_objs := $(foreach f,$(subdir-y),$(f)/built-in.o)# a.o b.ocur_objs := $(filter-out %/, $(obj-y))dep_files := $(foreach f,$(cur_objs),.$(f).d)dep_files := $(wildcard $(dep_files))ifneq ($(dep_files),) include $(dep_files)endifPHONY += $(subdir-y)__build : $(subdir-y) built-in.o$(subdir-y):\tmake -C $@ -f $(TOPDIR)/Makefile.buildbuilt-in.o : $(subdir-y) $(cur_objs)\t$(LD) -r -o $@ $(cur_objs) $(subdir_objs)dep_file = .$@.d%.o : %.c\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$@) -Wp,-MD,$(dep_file) -c -o $@ $\t.PHONY : $(PHONY) 子目录Makefile一般是指定源文件和编译选项 # EXTRA_CFLAGS := -D DEBUG# CFLAGS_sub3.o := -D DEBUG_SUB3obj-y += sub2.o obj-y += sub3.o 使用说明本程序的Makefile分为3类:1. 顶层目录的Makefile2. 顶层目录的Makefile.build3. 各级子目录的Makefile一、各级子目录的Makefile： 它最简单，形式如下：EXTRA_CFLAGS := CFLAGS_file.o := obj-y += file.oobj-y += subdir/ obj-y += file.o 表示把当前目录下的file.c编进程序里， obj-y += subdir/ 表示要进入subdir这个子目录下去寻找文件来编进程序里，是哪些文件由subdir目录下的Makefile决定。 EXTRA_CFLAGS, 它给当前目录下的所有文件(不含其下的子目录)设置额外的编译选项, 可以不设置 CFLAGS_xxx.o, 它给当前目录下的xxx.c设置它自己的编译选项, 可以不设置注意: 1. subdir/中的斜杠/不可省略2. 顶层Makefile中的CFLAGS在编译任意一个.c文件时都会使用3. CFLAGS EXTRA_CFLAGS CFLAGS_xxx.o 三者组成xxx.c的编译选项二、顶层目录的Makefile： 它除了定义obj-y来指定根目录下要编进程序去的文件、子目录外， 主要是定义工具链前缀CROSS_COMPILE, 定义编译参数CFLAGS, 定义链接参数LDFLAGS, 这些参数就是文件中用export导出的各变量。三、顶层目录的Makefile.build： 这是最复杂的部分，它的功能就是把某个目录及它的所有子目录中、需要编进程序去的文件都编译出来，打包为built-in.o 详细的讲解请看视频。四、怎么使用这套Makefile：1．把顶层Makefile, Makefile.build放入程序的顶层目录 在各自子目录创建一个空白的Makefile2．确定编译哪些源文件 修改顶层目录和各自子目录Makefile的obj-y : obj-y += xxx.o\tobj-y += yyy/\t这表示要编译当前目录下的xxx.c, 要编译当前目录下的yyy子目录\t3. 确定编译选项、链接选项 修改顶层目录Makefile的CFLAGS，这是编译所有.c文件时都要用的编译选项; 修改顶层目录Makefile的LDFLAGS，这是链接最后的应用程序时的链接选项; 修改各自子目录下的Makefile： EXTRA_CFLAGS, 它给当前目录下的所有文件(不含其下的子目录)设置额外的编译选项, 可以不设置 CFLAGS_xxx.o, 它给当前目录下的xxx.c设置它自己的编译选项, 可以不设置 4. 使用哪个编译器？ 修改顶层目录Makefile的CROSS_COMPILE, 用来指定工具链的前缀(比如arm-linux-) 5. 确定应用程序的名字： 修改顶层目录Makefile的TARGET, 这是用来指定编译出来的程序的名字6. 执行make来编译，执行make clean来清除，执行make distclean来彻底清除 参考韦东山《通用Makefile的使用》","tags":["linux","makefile"],"categories":["c"]},{"title":"typedef总结","path":"/2024/10/18/typedef总结/","content":"typedef总结CC++ typedef用法详解（真的很详细）-CSDN博客 以下是3中常见的通过typedef定义重命名结构体的形式： 匿名方式定义结构体 typedef struct int a; char b; mystruct;//使用mystruct s1; 命名方式定义结构体(用的最多) typedef struct mystruct int a; char b; T_mystruct;//使用T_mystruct s1; T_mystruct为struct mystruct 定义了一个类型别名 定义了一个结构体：mystruct.可以通过struct mystruct xxx;来定义结构体 更推荐的规范做法(实际上感觉用的很少)： struct mystruct int a; int b;;typedef struct mystruct T_mystruct;//typedef struct mystruct pT_mystruct; 这里定义了一个名为 mystruct 的结构体，包含两个整数成员 a 和 b。 使用 typedef 为 struct mystruct 定义了一个别名 T_mystruct T_mystruct 可以用来声明 mystruct 类型的变量","tags":["linux","typedef"],"categories":["c"]},{"title":"三数之和","path":"/2024/10/15/leetcode刷题/每日一刷day37(梦破碎的地方)/","content":"梦破碎的地方，真是太难了.-_-… 三数之和：梦破碎的地方题目：三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c 0 ？请你找出所有满足条件且不重复的三元组。注意： 答案中不可以包含重复的三元组。示例：给定数组 nums [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解法-双指针法思路： 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码：（成功提交但是有逻辑错误和注释理解错误） #include vector#include algorithm#include iostreamusing namespace std;class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint result; //计算nums[i] + nums[left] + nums[right] = 0; //先对nums[]进行一次排序，方便判断 sort(nums.begin(),nums.end()); for(int i = 0;i nums.size();i++) cout nums[i] ; cout endl; //遍历数组 for(int i = 0;i nums.size();i++) //a去重，判断首位元素是否大于0，如果大于0，则三个正数相加不为0 if(nums[i] 0)return result; //b去重 if(i 0 nums[i] == nums[i-1]) continue; int left = i+1; int right = nums.size()-1; //开始收缩 while(leftright) //说明right偏右了 if(nums[i] + nums[left] + nums[right] 0) right--; else if(nums[i] + nums[left] + nums[right] 0) //说明left偏左了 left++; else if(nums[i] + nums[left] + nums[right]==0) result.push_back(vectorintnums[i],nums[left],nums[right]); //去重，如果有的话 while(i0nums[left] == nums[left+1]) left++; while(i0nums[right] == nums[right-1]) right--; left++;right--; //if(nums[i] + nums[left] + nums[right]==0) // result.push_back(nums[i],nums[left],nums[right]); // //去重，如果有的话 // while(i0nums[left] == nums[left+1]) left++; // while(i0nums[right] == nums[right-1]) right--; // left++;right--; // return result; ;int main() Solution solution; vectorint nums1 = -1,0,1,2,-1,-4; //vectorvectorint expected1 = -1, -1, 2, -1, 0, 1; vectorvectorint result1 = solution.threeSum(nums1); //遍历二维数组 for (int i = 0; i result1.size(); i++) for (int j = 0; j result1[i].size(); j++) cout result1[i][j] ; cout endl; return 0; 错误描述： if(nums[i] 0){return result;}这句话不是对a去重，而是判断首位元素是否大于0，如果大于0，则三个正数相加不为0.下一句if(i 0 nums[i] == nums[i-1])才是对a去重 while(i0nums[left] == nums[left+1]) left++;逻辑错误，应该改为while(leftright nums[left] == nums[left+1]) left++;,i0的条件应该不对，虽然通过LeetCode了 代码(更正后) class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint result; //计算nums[i] + nums[left] + nums[right] = 0; //先对nums[]进行一次排序，方便判断 sort(nums.begin(),nums.end()); for(int i = 0;i nums.size();i++) cout nums[i] ; cout endl; //遍历数组 for(int i = 0;i nums.size();i++) //判断首位元素是否大于0，如果大于0，则三个正数相加不为0 if(nums[i] 0)return result; //a去重,如果可以包含重复的三元组，则把这个if语句注释掉,虽然也不太能保留所有重复的三元组 if(i 0 nums[i] == nums[i-1]) continue; int left = i+1; int right = nums.size()-1; //开始收缩 while(leftright) //说明right偏右了 if(nums[i] + nums[left] + nums[right] 0) right--; else if(nums[i] + nums[left] + nums[right] 0) //说明left偏左了 left++; else if(nums[i] + nums[left] + nums[right]==0) result.push_back(vectorintnums[i],nums[left],nums[right]); //去重，如果有的话 //while目的是为了：且不重复的三元组。 //如果可以有重复的三元组，则把这两个while注释掉。 //实际测试虽然也不太能保留所有重复的三元组，不过应该是left++;right--;同时收缩的缘故 while(leftright nums[left] == nums[left+1]) left++; cout left = left endl; while(leftright nums[right] == nums[right-1]) right--; cout right = right endl; left++;right--; return result; ; 语法小计 该题没有语法小计 *","tags":["c++","三数之和"],"categories":["C++刷题笔记"]},{"title":"四数之和之2","path":"/2024/10/15/leetcode刷题/每日一刷day38四数之和/","content":"三数之和给我写崩溃了都，不过最后还是理解了双指针法。四数之和跟三数之和用的方法是一样的，基本可以完全照着抄。又可以继续重拳出击了！ 四数之和之2题目：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 = a, b, c, d n a、b、c 和 d 互不相同(互不相同指的是索引不同，并不是值不相同，即可以同时有两个2，但是这两个2不是同一个数)互不相同：a,b,c,d 都是四个不同的元素，但值可以相同。不如三数之和好理解 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。示例 1： 输入：nums [1,0,-1,0,-2,2], target 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]示例 2： 输入：nums [2,2,2,2,2], target 8 输出：[[2,2,2,2]] 解法-双指针法思路： 1. 2. 3. 复杂度： 时间复杂度： 空间复杂度： 代码： #include vector#include algorithm#include iostreamusing namespace std;class Solution public: vectorvectorint fourSum(vectorint nums, int target) vectorvectorint result; sort(nums.begin(),nums.end()); //计算nums[i]+nums[j]+nums[left]+nums[right] = target; for(int i=0;inums.size();i++) //a去重 if(i0nums[i]targetnums[i]0)return result; if(i0nums[i] == nums[i-1] )continue; for(int j=i+1;jnums.size();j++) if(ji+1 nums[j] == nums[j-1])continue; int left = j+1; int right = nums.size()-1; while(leftright) //说明right偏右了 if(nums[i]+nums[j]+nums[left]+nums[right] target) right--; else if(nums[i]+nums[j]+nums[left]+nums[right] target) //说明left偏左了 left++; else if(nums[i]+nums[j]+nums[left]+nums[right] == target) //说明找到了 result.push_back(vectorintnums[i],nums[j],nums[left],nums[right]); //去重 while(leftrightnums[left]==nums[left+1])left++; while(leftrightnums[right]==nums[right-1])right--; left++;right--; return result; ;int main(int argc, char const *argv[]) Solution solution; vectorint nums1 = -1,0,-5,-2,-2,-4,0,1,-2; //vectorvectorint expected1 = -1, -1, 2, -1, 0, 1; vectorvectorint result1 = solution.fourSum(nums1,-9); //遍历二维数组 for (int i = 0; i result1.size(); i++) for (int j = 0; j result1[i].size(); j++) cout result1[i][j] ; cout endl; return 0; 语法小计 该题没语法小计 *","tags":["c++","四数之和"],"categories":["C++刷题笔记"]},{"title":"翻转字符串里的单词","path":"/2024/10/15/leetcode刷题/每日一刷day40翻转字符串里的单词/","content":"翻转字符串里的单词 翻转字符串里的单词题目：给定一个字符串，逐个翻转字符串中的每个单词。解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。你可以按 任意顺序 返回答案 。示例 1： 输入：” the sky is blue “ 输出：”blue is sky the”示例 2： 输入：” hello world! “ 输出：”world! hello”示例 3： 输入: “a good example” 输出: “example good a” 解法-双指针法思路：以 the sky is blue 为例 移除多余空格the sky is blue 反转整个字符串eulb si yks eht 将每个单词反转blue is sky the 复杂度： 时间复杂度： 空间复杂度： 代码： class Solution public: //反转,闭区间 void reverse(string s,int start,int end) int slow = start,fast = end; while(slow fast) swap(s[slow++],s[fast--]); //去除多余空格 void removeExtraSpaces(string s) //去除首空格 int slow = 0,fast = 0; while(s[fast] == ) fast++; //去除中间空格 for(;fast s.size();fast++) if(s[fast] == s[fast-1] == s[fast]) //说明此处是多余空格，跳过,fast++ continue; else s[slow]=s[fast]; slow++; //去除尾空格,因为去除中间空格时，可能会出现最后一个字符是空格的情况 if(s[slow-1] == ) s.resize(slow-1); else//更新新的字符串长度 s.resize(slow); //反转字符串里的单词 string reverseWords(string s) //去除多余空格 removeExtraSpaces(s); // //反转整个字符串,反转后的字符串首尾都是字母 reverse(s,0,s.size()-1); //将每个单词反转 int begin = 0; for(int i = 0;is.size();++i) if(s[i] == ) reverse(s,begin,i-1); begin = i+1; //单独处理最后一个字母 reverse(s,begin,s.size()-1); return s; ; 语法小计 该题没语法小计 *","tags":["c++","翻转字符串里的单词"],"categories":["C++刷题笔记"]},{"title":"stack实现queue","path":"/2024/10/14/stack实现queue/","content":"class MyQueue {public: stack stIn;输入栈 stack stOut;输出栈 MyQueue() { } void push(int x) { stIn.push(x); } int pop() { //如果输出栈为空，则将输入栈的元素全部弹出并压入输出栈 if(stOut.empty()){ while (!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } //查看队列的第一个元素 int peek() { int ret = this-pop();//使用已有的pop函数，弹出栈顶元素 stOut.push(ret);//再将弹出的元素压入stOut栈中 return ret; } bool empty() { return stIn.empty() stOut.empty(); } };","tags":["c++","stack","queue"],"categories":["C++刷题笔记"]},{"title":"救赎金","path":"/2024/10/14/leetcode刷题/每日一刷day36/","content":"救赎金题目：救赎金给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 解法-数组哈希表思路： 定义record[26]数组，用于记录每个字母出现的次数 统计r中每个字母出现的次数，记录record对应的位置上，实现方式为record递增 统计m中每个字母出现的次数，实现方式为：record对应位置上递减 遍历record[26]，只要有record[i]0,则说明m中的元素r中没有或比r中多，返回false 如果record[26]所有的值都0,则说明r可以从m中挑选字母组成（r中的字母m中都有，并且m中可以比r中多），符合题意！ 复杂度： 时间复杂度： 空间复杂度： 代码： class Solution public: bool canConstruct(string r, string m) //用于记录每个字母出现的次数 int record[26] = 0; //记录r字符串中每个字母出现的次数 for(int i = 0;i r.length();i++) record[r[i] - a]++; //将r对应位置的次数递减 for(int i = 0;i m.length();i++) record[m[i] - a]--; for(int i = 0;i 26;i++) //如果record有位置大于0，说明m中的元素r中没有或比r中多，返回false if(record[i]0)return false; return true; ; 语法小计 该题没有语法小计 *","tags":["c++","救赎金"],"categories":["C++刷题笔记"]},{"title":"反转字符串","path":"/2024/10/14/leetcode刷题/每日一刷day39/","content":"反转字符串题目：反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。示例 1： 输入：s [“h”,”e”,”l”,”l”,”o”] 输出：[“o”,”l”,”l”,”e”,”h”]示例 2： 输入：s [“H”,”a”,”n”,”n”,”a”,”h”] 输出：[“h”,”a”,”n”,”n”,”a”,”H”] 解法-思路：为什么还有这么这样的题目啊？ 为什么我刚开始刷leetcode的时候遇到的题这么难，直接给我劝退呢？ 为什么要如此戏耍我！🤯复杂度： 时间复杂度： 空间复杂度：代码： void reverseString(vectorchar s) char temp; for(int i = 0;i s.size()/2;i++) temp = s[i]; s[i] = s[s.size()-1-i]; s[s.size()-1-i] = temp;","tags":["c++","反转字符串"],"categories":["C++刷题笔记"]},{"title":"吐槽","path":"/2024/10/14/leetcode刷题/每日一刷之抱怨/","content":"真的没有头绪….烦死了 烦死了","tags":["c++","吐槽"],"categories":["C++刷题笔记"]},{"title":"两个数组的交集","path":"/2024/10/12/leetcode刷题/每日一刷day32/","content":"字母异位词题目：两个数组的交集 解法-哈希表思路： 将Num1存储在set容器nums_set中，可以去重 遍历num2,如果Nums_set中有num2，则将num2插入到result_set中 复杂度： 时间复杂度： 空间复杂度： 代码： #includeiostream#includevector#includeunordered_setusing namespace std;class Solution public: vectorint intersection(vectorint nums1, vectorint nums2) unordered_setint result_set; // 存放结果，之所以用set是为了给结果集去重 //通过传递 nums1.begin() 和 nums1.end()， //可以将 nums1 中的所有元素一次性插入到 unordered_set 中，从而快速构建集合。 //unordered_set 自动去除重复元素，因此可以确保最终集合中没有重复项。 unordered_setint nums_set(nums1.begin(), nums1.end()); // 遍历nums2 for (int num : nums2) // 发现nums2的元素 在nums_set里又出现过 if (nums_set.find(num) != nums_set.end()) result_set.insert(num); return vectorint(result_set.begin(), result_set.end()); ; 语法小点： unordered_set 数据结构：基于哈希表 无序存储 去重 set(ordered_set) 数据结构：基于红黑树 有序存储：元素按照升序排序 去重 解释：unordered_setint nums_set(nums1.begin(), nums1.end()); nums1.begin()：返回指向nums1向量中第一个元素的迭代器 nums1.end()：返回指向nums1向量中最后一个元素下一个位置的迭代器 将nums1向量中的所有元素插入到一个无序集合nums_set中，用于去除重复元素并提供快速查找。 解释： for (int num : nums2) for循环用于遍历名为nums2的容器中的每个元素。循环变量num依次取nums2中的每一个值。通常用于对nums2中的每个元素执行相同的操作。 解释： if (nums_set.find(num) != nums_set.end()) { result_set.insert(num); } nums_set.find(num):这个方法会在 nums_set 中查找是否存在值为 num 的元素。查找成功会返回一个指向该元素的迭代器；查找失败会返回 nums_set.end()，表示查找未找到该元素。 nums_set.find(num) ! nums_set.end()：这个条件判断返回的迭代器是否等于 nums_set.end()。 如果不等于nums_set.end()，说明找到了 num，即 nums_set 中存在 num。 如果等于 nums_set.end()，说明没有找到 num，即 nums_set 中不存在 num。","tags":["c++","两个数组的交集"],"categories":["C++刷题笔记"]},{"title":"快乐数","path":"/2024/10/12/leetcode刷题/每日一刷day33/","content":"题目：快乐数:19 解法-哈希表思路： 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class Solutionprivate: /* data */public: int getSum(int n) int sum = 0; int temp = 0; while (n 0) temp = n % 10; temp *= temp; sum += temp; n/=10; return sum; bool isHappy(int n) unordered_setint record; int sum = 0; while(1) sum = getSum(n); if(n==1)return true; if(record.find(sum) != record.end()) //如果sum在record里面找到了，说明陷入了循环，直接返回false return false; else record.insert(sum); n=sum; std::coutsum= sumstd::endl; //return true; ; 语法小点： 1. * * *2. * * *","tags":["c++","快乐数"],"categories":["C++刷题笔记"]},{"title":"两数之和","path":"/2024/10/12/leetcode刷题/每日一刷day34/","content":"两数之和题目：求两数之和 解法-哈希表思路： 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class Solutionprivate: /* data */public: vectorint twoSum(vectorint nums, int target) unordered_mapint,int record; for(int i = 0;inums.size();i++) auto iter = record.find(target-nums[i]); if(iter != record.end()) //找到了 //返回值，和索引 return iter-second,i; else record.insert(nums[i],i); return ; ; 语法小点： map迭代器的使用： 迭代器 iter 指向映射中的一个元素，我一直理解为一个指针，暂时没有出现问题 iter-first 访问的是键（key）部分。 iter-second 访问的是值（value）部分 解释：return {iter-second,i}; 将迭代器 iter-second 和 i 封装成一个“数组”，并返回，先暂时这样理解！","tags":["c++","两数之和"],"categories":["C++刷题笔记"]},{"title":"四数之和","path":"/2024/10/12/leetcode刷题/每日一刷day35/","content":"四数之和题目：四数之和 解法-哈希表思路：只要找到A[i] + B[j] + C[k] + D[l] 0就可以，不用考虑有重复的四个元素相加等于0的情况 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 定义int变量count，用来统计 a+b+c+d 0 出现的次数 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来 最后返回统计值 count 就可以了 复杂度： 时间复杂度： 空间复杂度： 代码： #include vector#include unordered_map#include iostreamusing namespace std;class Solution public: int fourSumCount(vectorint A, vectorint B, vectorint C, vectorint D) unordered_mapint, int umap; //key:a+b的数值，value:a+b数值出现的次数 // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 //注意：umap初始值为空，所以umap[a+b]++是1，如果再次出现相同的a+b，那么umap[a+b]++就是2 for (int a : A) for (int b : B) umap[a + b]++; cout a=ab=bumap[ a+b] = umap[a+b]endl; //遍历umap for(auto i:umap) couti.first=i.first i.second=i.secondendl; int count = 0; // 统计a+b+c+d = 0 出现的次数 // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。 for (int c : C) for (int d : D) //如果在umap中找到0-(c+d)这个key，那么就把对应的value也就是出现次数统计出来 if (umap.find(0 - (c + d)) != umap.end()) count += umap[0 - (c + d)]; return count; ;// 单元测试int main() Solution solution; vectorint A = 1, 2; vectorint B = -2, -1; vectorint C = -1, 2; vectorint D = 0, 2; int result = solution.fourSumCount(A, B, C, D); cout The count of four sum is: result endl; // 应输出 2 return 0; 语法小点： 解释：umap[a + b]++; umap初始值为空，所以umap[a+b]++是1，如果再次出现相同的a+b，那么umap[a+b]++就是2 **","tags":["c++","四数之和"],"categories":["C++刷题笔记"]},{"title":"poll笔记","path":"/2024/09/30/poll笔记/","content":"POLL笔记函数原型#include poll.hint poll(struct pollfd *fds, nfds_t nfds, int timeout); 参数： fds：一个pollfd结构体数组指针，用于描述需要等待的事件，每个数组中包含一个文件描述符 nfds：fd 数组的大小，即需要等待的事件的数量 timeout：等待事件发生的时间，以毫秒为单位。如果为 -1，表示一直等待，直到有事件发生。如果为 0，表示不阻塞，立即返回。 返回值：如果有事件发生，返回值为正数，表示有多少个文件描述符发生了事件，超时则返回0，错误返回值为 -1。 struct pollfd的结构体： struct pollfd　int fd； // 文件描述符　short event；// 请求的事件　short revent；// 返回的事件 fd:要监视的文件描述符，如果fd无效的话那么events监视事件也无效，并且revents返回0. event:表示要监视的事件，可以监视的事件如下(不全)： 事件名 描述 POLLIN 输入数据可读 POLLOUT 输出缓冲区有空闲空间，可以写入数据 POLLHUP 有指定的文件描述符挂起 POLLPRI 输入数据有紧急数据可读（比如带外数据） POLLNVAL 无效的文件描述符 POLLRDNORM 同 POLLIN revents :返回的事件，由linux内核设置具体的返回事件 使用 poll 函数来等待标准输入（键盘输入）和一个文件描述符的变化 初始化 pollfd 结构体： fds[0] 用于标准输入（STDIN_FILENO），关心可读事件（POLLIN）。 fds[1] 用于打开的文件描述符，也关心可读事件（POLLIN）。 调用 poll 函数： 使用 while (1) 循环来持续调用 poll，以便持续监测文件描述符的状态。 poll(fds, 2, 5000) 表示等待 fds 数组中的两个文件描述符在 5000 毫秒内变得可读。 如果返回值为 -1，表示发生错误。 如果返回值为 0，表示超时。 如果返回值为正数，表示有文件描述符发生了事件。 处理事件： 检查 fds[0].revents 和 fds[1].revents，判断哪些文件描述符发生了事件。 如果文件描述符可读，读取数据并打印。 如果文件描述符对端关闭连接或发生错误，打印相应的信息。 完整代码#include stdio.h#include stdlib.h#include unistd.h#include poll.h#include fcntl.h#include string.h#include errno.hint main() struct pollfd fds[2]; int ret; char buffer[1024]; // 初始化 pollfd 结构体 fds[0].fd = STDIN_FILENO; // 标准输入 fds[0].events = POLLIN; // 关心可读事件 // 打开一个文件 fds[1].fd = open(example.txt, O_RDONLY); if (fds[1].fd == -1) perror(open); return -1; fds[1].events = POLLIN; // 关心可读事件 // 调用 poll 函数 while (1) ret = poll(fds, 2, 5000); // 等待 5000 毫秒 if (ret == -1) perror(poll); close(fds[1].fd); return -1; else if (ret == 0) printf(poll 超时 ); else // 当输入内容后，按下回车，就会有事件发生，并且输出标准输入的内容 if (fds[0].revents POLLIN) printf(标准输入可读 ); ssize_t bytes_read = read(STDIN_FILENO, buffer, sizeof(buffer) - 1); if (bytes_read 0) buffer[bytes_read] = \\0; // 确保字符串以 null 结尾 printf(读取到: %s , buffer); // 将文件描述符从可读改为不可读，当解开注释后，输入内容就会将文件描述符变为不可读 // fds[1].events = 0; // 不关心任何事件 if (fds[1].revents POLLIN) printf(文件描述符可读 ); //每次更新example.txt中的内容后才会输出example.txt的内容 ssize_t bytes_read = read(fds[1].fd, buffer, sizeof(buffer) - 1); if (bytes_read 0) buffer[bytes_read] = \\0; // 确保字符串以 null 结尾 printf(从文件读取到: %s , buffer); if (fds[0].revents POLLHUP) printf(标准输入对端关闭连接 ); if (fds[1].revents POLLHUP) printf(文件描述符对端关闭连接 ); if (fds[0].revents POLLERR) printf(标准输入发生错误 ); if (fds[1].revents POLLERR) printf(文件描述符发生错误 ); sleep(1); close(fds[1].fd); return 0;","tags":["poll"],"categories":["嵌入式"]},{"title":"poll笔记深入","path":"/2024/09/30/poll笔记深入/","content":"POLL笔记深入参考韦东山： poll函数执行流程poll函数执行流程： 函数执行流程如上图①～⑧所示，重点从③开始看。假设一开始无按键数据： ③ APP调用poll之后，进入内核态； ④ 导致驱动程序的drv_poll被调用： 注意，drv_poll要把自己这个线程挂入等待队列wq中；假设不放入队列里，那以后- 发生中断时，中断服务程序去哪里找到你嘛？ drv_poll还会判断一下：有没有数据啊？返回这个状态。 ⑤ 假设当前没有数据，则休眠一会； ⑥ 在休眠过程中，按下了按键，发生了中断： 在中断服务程序里记录了按键值，并且从wq中把线程唤醒了。 ⑦ 线程从休眠中被唤醒，继续执行for循环，再次调用drv_poll： drv_poll返回数据状态 ⑧ 哦，你有数据，那从内核态返回到应用态吧 ⑨ APP调用read函数读数据 如果一直没有数据，调用流程也是类似的，重点从③开始看，如下： ③ APP调用poll之后，进入内核态； ④ 导致驱动程序的drv_poll被调用： 注意，drv_poll要把自己这个线程挂入等待队列wq中；假设不放入队列里，那以后发生中断时，中断服务程序去哪里找到你嘛？ drv_poll还会判断一下：有没有数据啊？返回这个状态。 ⑤ 假设当前没有数据，则休眠一会； ⑥ 在休眠过程中，一直没有按下了按键，超时时间到：内核把这个线程唤醒； ⑦ 线程从休眠中被唤醒，继续执行for循环，再次调用drv_poll： drv_poll返回数据状态 ⑧ 哦，你还是没有数据，但是超时时间到了，那从内核态返回到应用态吧 ⑨ APP不能调用read函数读数据 注意几点： ① drv_poll要把线程挂入队列wq，但是并不是在drv_poll中进入休眠，而是在调用drv_poll之后休眠 ② drv_poll要返回数据状态 ③ APP调用一次poll，有可能会导致drv_poll被调用2次 ④ 线程被唤醒的原因有2：中断发生了去队列wq中把它唤醒，超时时间到了内核把它唤醒 ⑤ APP要判断poll返回的原因：有数据，还是超时。有数据时再去调用read函数。 驱动使用poll机制时，驱动程序的核心就是提供对应的drv_poll函数。 在drv_poll函数中要做2件事： ① 把当前线程挂入队列wq：poll_wait APP调用一次poll，可能导致drv_poll被调用2次，但是我们并不需要把当前线程挂入队列2次。可以使用内核的函数poll_wait把线程挂入队列，如果线程已经在队列里了，它就不会再次挂入。 ② 返回设备状态： APP调用poll函数时，有可能是查询“有没有数据可以读”：POLLIN，也有可能是查询“你有没有空间给我写数据”：POLLOUT。 所以drv_poll要返回自己的当前状态：(POLLIN | POLLRDNORM) 或 (POLLOUT | POLLWRNORM)。 POLLRDNORM等同于POLLIN，为了兼容某些APP把它们一起返回。 POLLWRNORM等同于POLLOUT ，为了兼容某些APP把它们一起返回。 完整代码 只需要看static unsigned int gpio_key_drv_poll(struct file *fp, poll_table * wait)这一部分即可 #include linux/module.h#include linux/poll.h#include linux/fs.h#include linux/errno.h#include linux/miscdevice.h#include linux/kernel.h#include linux/major.h#include linux/mutex.h#include linux/proc_fs.h#include linux/seq_file.h#include linux/stat.h#include linux/init.h#include linux/device.h#include linux/tty.h#include linux/kmod.h#include linux/gfp.h#include linux/gpio/consumer.h#include linux/platform_device.h#include linux/of_gpio.h#include linux/of_irq.h#include linux/interrupt.h#include linux/irq.h#include linux/slab.hstruct gpio_key\tint gpio;\tstruct gpio_desc *gpiod;\tint flag;\tint irq; ;static struct gpio_key *gpio_keys_100ask;/* 主设备号 */static int major = 0;static struct class *gpio_key_class;/* 环形缓冲区 */#define BUF_LEN 128static int g_keys[BUF_LEN];static int r, w;#define NEXT_POS(x) ((x+1) % BUF_LEN)static int is_key_buf_empty(void)\treturn (r == w);static int is_key_buf_full(void)\treturn (r == NEXT_POS(w));static void put_key(int key)\tif (!is_key_buf_full()) g_keys[w] = key; w = NEXT_POS(w);\tstatic int get_key(void)\tint key = 0;\tif (!is_key_buf_empty()) key = g_keys[r]; r = NEXT_POS(r); return key;static DECLARE_WAIT_QUEUE_HEAD(gpio_key_wait);/* 实现对应的open/read/write等函数，填入file_operations结构体 */static ssize_t gpio_key_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)\t//printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);\tint err;\tint key; wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());\tkey = get_key();\terr = copy_to_user(buf, key, 4); return 4;static unsigned int gpio_key_drv_poll(struct file *fp, poll_table * wait)\t//调用一次poll可能会调用两次drv_poll\tprintk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);\t//执行poll_wait并不会休眠\tpoll_wait(fp, gpio_key_wait, wait);\treturn is_key_buf_empty() ? 0 : POLLIN | POLLRDNORM;/* 定义自己的file_operations结构体 */static struct file_operations gpio_key_drv = .owner = THIS_MODULE,\t.read = gpio_key_drv_read,\t.poll = gpio_key_drv_poll,;static irqreturn_t gpio_key_isr(int irq, void *dev_id)\tstruct gpio_key *gpio_key = dev_id;\tint val;\tint key; val = gpiod_get_value(gpio_key-gpiod); printk(key %d %d , gpio_key-gpio, val);\tkey = (gpio_key-gpio 8) | val;\tput_key(key);\twake_up_interruptible(gpio_key_wait); return IRQ_HANDLED;/* 1. 从platform_device获得GPIO * 2. gpio=irq * 3. request_irq */static int gpio_key_probe(struct platform_device *pdev)\tint err;\tstruct device_node *node = pdev-dev.of_node;\tint count;\tint i;\tenum of_gpio_flags flag; printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);\tcount = of_gpio_count(node);\tif (!count) printk(%s %s line %d, there isnt any gpio available , __FILE__, __FUNCTION__, __LINE__); return -1; gpio_keys_100ask = kzalloc(sizeof(struct gpio_key) * count, GFP_KERNEL);\tfor (i = 0; i count; i++) gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, flag); if (gpio_keys_100ask[i].gpio 0) printk(%s %s line %d, of_get_gpio_flags fail , __FILE__, __FUNCTION__, __LINE__); return -1; gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio); gpio_keys_100ask[i].flag = flag OF_GPIO_ACTIVE_LOW; gpio_keys_100ask[i].irq = gpio_to_irq(gpio_keys_100ask[i].gpio); for (i = 0; i count; i++) err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, 100ask_gpio_key, gpio_keys_100ask[i]); /* 注册file_operations */\tmajor = register_chrdev(0, 100ask_gpio_key, gpio_key_drv); /* /dev/gpio_key */\tgpio_key_class = class_create(THIS_MODULE, 100ask_gpio_key_class);\tif (IS_ERR(gpio_key_class)) printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, 100ask_gpio_key); return PTR_ERR(gpio_key_class); device_create(gpio_key_class, NULL, MKDEV(major, 0), NULL, 100ask_gpio_key); /* /dev/100ask_gpio_key */ return 0; static int gpio_key_remove(struct platform_device *pdev)\t//int err;\tstruct device_node *node = pdev-dev.of_node;\tint count;\tint i;\tdevice_destroy(gpio_key_class, MKDEV(major, 0));\tclass_destroy(gpio_key_class);\tunregister_chrdev(major, 100ask_gpio_key);\tcount = of_gpio_count(node);\tfor (i = 0; i count; i++) free_irq(gpio_keys_100ask[i].irq, gpio_keys_100ask[i]); kfree(gpio_keys_100ask); return 0;static const struct of_device_id ask100_keys[] = .compatible = 100ask,gpio_key , ,;/* 1. 定义platform_driver */static struct platform_driver gpio_keys_driver = .probe = gpio_key_probe, .remove = gpio_key_remove, .driver = .name = 100ask_gpio_key, .of_match_table = ask100_keys, ,;/* 2. 在入口函数注册platform_driver */static int __init gpio_key_init(void) int err; printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__); err = platform_driver_register(gpio_keys_driver); return err;/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 * 卸载platform_driver */static void __exit gpio_key_exit(void)\tprintk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__); platform_driver_unregister(gpio_keys_driver);/* 7. 其他完善：提供设备信息，自动创建设备节点 */module_init(gpio_key_init);module_exit(gpio_key_exit);MODULE_LICENSE(GPL); 应用部分 在调用poll函数时，要指明： ① 你要监测哪一个文件：哪一个fd ② 你想监测这个文件的哪种事件：是POLLIN、还是POLLOUT ③ 在poll函数返回时，要判断状态。 完整代码 #include sys/types.h#include sys/stat.h#include fcntl.h#include unistd.h#include stdio.h#include string.h#include poll.h/* * ./button_test /dev/100ask_button0 * */int main(int argc, char **argv)\tint fd;\tint val;\tstruct pollfd fds[1];\tint timeout_ms = 5000;\tint ret; /* 1. 判断参数 */\tif (argc != 2) printf(Usage: %s dev , argv[0]); return -1; /* 2. 打开文件 */\tfd = open(argv[1], O_RDWR);\tif (fd == -1) printf(can not open file %s , argv[1]); return -1; fds[0].fd = fd;\tfds[0].events = POLLIN; while (1) /* 3. 读文件 */ //根据poll的返回值，判断是否有数据可读 ret = poll(fds, 1, timeout_ms); if ((ret == 1) (fds[0].revents POLLIN)) read(fd, val, 4); printf(get button : 0x%x , val); else printf(timeout ); close(fd); return 0; poll机制 从应用程序中的poll调用，最终会一步一步得调用到do_poll函数，具体流程； poll - drv_poll - sys_poll - do_sys_poll - do_poll do_poll ① 从这里开始，将会导致驱动程序的poll函数被第一次调用。 沿着②③④⑤，你可以看到：驱动程序里的poll_wait会调用__pollwait函数把线程放入某个队列。 当执行完①之后，在⑥或⑦处，pt-_qproc被设置为NULL，所以第二次调用驱动程序的poll时，不会再次把线程放入某个队列里。 ⑧ 如果驱动程序的poll返回有效值，则count非0，跳出循环； ⑨ 否则休眠一段时间；当休眠时间到，或是被中断唤醒时，会再次循环、再次调用驱动程序的poll。 回顾APP的代码，APP可以指定“想等待某些事件”，poll函数返回后，可以知道“发生了哪些事件”： 驱动程序里怎么体现呢？在上上一个图中，看②位置处，细说如下： 参考链接 http://blog.chinaunix.net/uid-30592332-id-5599907.html https://cloud.tencent.com/developer/article/1708996","tags":["poll"],"categories":["嵌入式"]},{"title":"小杜的重庆之行","path":"/2024/09/29/杂记/小杜的重庆之行/","content":"小杜的重庆之行 出发时间 抵达时间 2024年9月30日 15:06 2024年10月1日 15:43 Day1 地点 注意 门票 解放碑（抗战胜利的纪念碑） 注意拍摄角度 带墨镜 免费 山城书店（爱心书店 ） 注意拍摄角度图 免费 八一好吃街（特色美食） 吃什么 自费的， 罗汉寺 拍照打卡点 20元 day 2 地点 注意 门票 白象居 可以拍长江索道 湖广会馆 拍照出片 （25元） 长江索道 （提前预约） 25-30元 十八梯 出片 南滨路 （夜景） day3 地点 攻略 戴家巷 出片 来福士 大商场 朝天门 （两江交汇） 洪崖洞 夜景 千厮门大桥 （拍洪崖洞全景） day4 地点 注意 门票 开埠遗址公园 （重庆文化） 龙门浩老街 （爬坡，） 怀旧轮渡 （15元） 弹子石老街 （中式庭院） 南山一颗树 （美景） day5 地点 攻略 鹅岭二厂 （废弃共厂改造） 鹅岭公园 （文艺照片） 李子坝 （轻轨） 北仓文创院 （文艺片） 观音桥 （地标） day6 地点 攻略 磁器口 （古镇） 白公馆 渣滓洞 罗中立美术馆 马房湾七彩巷 day7 地点 注意 门票 重庆动物园 （，四喜丸子） 25元 钟书阁 （ 哈利波特书屋） 涂鸦一条街 交通茶馆 王源同款茶 10 黄桷娅老街 安逸喔~ 接下来是要去预约的景点~ 需要预约的景点 放票时间 票价 特色 长江索道 每天7；15放票 罗中立美术馆（四川美院美术馆） 有名额限制 重庆三峡博物馆 （重庆中国山峡博物馆） 预约成功（周三）周一闭馆 南山一棵树：“重庆南山植物馆” 门票30 湖广会馆 怀旧轮渡（重庆两江交运） 15 （ 大美重庆 ） 人民大礼堂 “重庆市人民大礼堂” 一下可预约两天 周一闭关 8元 接下来是一些好吃的！ 美食 特点 朝天门天桥滑肉 一只酸奶牛 （茶话弄） 歌乐山辣子鸡 看着特别辣，有百十块的 春红火锅 买券了150多 南山有烧烤 200多，贵在景色 都没听过呢~ 开始期待… 心情多云转晴了","tags":["旅行","重庆"],"categories":["杂记"]},{"title":"gcc的四个过程","path":"/2024/09/24/gcc的四个过程/","content":"gcc四个过程CC++通过gccg++编译器包括以下四个过程：预处理，编译，汇编，链接 预处理(preprocess)预处理可以理解为将#里边的内容展开，包括宏定义，头文件路径等等，然后直接插入到程序里边去。预处理通过预处理器将.c文件转换成.i文件。预处理阶段不会检查语法错误 编译(compile)编译是通过编译器(ccl)将.i文件转换为汇编代码文件，一般是.s文件。在编译阶段会进行语法分析等 汇编(assemble)汇编器(as)将.s文件翻译成二进制机器语言指令（二进制机器码），生成.o文件。 链接(link)链接器(ld)将上述产生的一堆文件还有各种库通过某种方式链接起来，生成.out(.exe)文件 以上都是自己理解","tags":["c++","笔记"],"categories":["C++"]},{"title":"rosAPI","path":"/2024/09/24/rosAPI/","content":"ROS API init 函数 //有3个重载，常用以下void ros::init(int argc, char **argv, const std::string name, uint32_t options = 0U) 作用： 初始化ROS系统，并创建一个节点，节点名称为name argc 参数个数 argv 参数数组，需要符合ros的特定格式 name 节点名称，默认为argv[0]，不允许重复 options ROS中同一个节点不能重复启动，此时可以通过options选项来设置是否允许重复启动,原理是在节点名称后加上生成随机数字尾缀。使用方法：ros::init_options::AnonymousName 使用细节 发布对象 //使用示例ros::Publisher pub = nh.advertisegeometry_msgs::Twist(/turtle1/cmd_vel,1000);//函数原型inline ros::Publisher ros::NodeHandle::advertisestd_msgs::String(const std::string topic, uint32_t queue_size, bool latch = false) 作用： 创建发布者对象 模板 被发布者的消息类型 topic 话题名称 queue_size 缓存消息个数，如果满了丢弃之前的 latch 如果为ture,会保存发布方的最后一条消息，并且当新的订阅者连接到发布方时，发布方会将这条信息发送给订阅者。应用场景：静态地图 使用细节 3. 回旋函数 有回调就伴随着回旋 void ros::spin()void ros::spinOnce() 作用： 处理回调函数 spin() 是进入了循环执行回调函数，进入循环后不会自己退出，在 ros::spin() 后的语句不会执行到 spinOnce() 只会执行一次回调函数(没有循环)，ros::spinOnce() 后的语句可以执行 时刻参考系1970年1月1日0时0分0秒 ros::Time::now()//now() 返回一个ros::Time对象，表示当前时间//ros::Time::now().toSec()//ros::Time::now().sec 定时器ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing,true);//只执行一次 https://support.3dsystems.com/s/article/OpenHaptics-for-Linux-Developer-Edition-v34?language=en_US","tags":["ros","笔记"],"categories":["ROS"]},{"title":"搭建博客参考过的链接","path":"/2024/09/22/搭建博客参考过的链接/","content":"https://yuanlichenai.cn/2020/02/02/chic/https://blog.csdn.net/QFREX/article/details/108798945https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.clickhttps://did321.gitee.io/","tags":["hexo","搭建博客","blog"],"categories":["搭建博客"]},{"title":"图床链接格式测试","path":"/2024/09/20/图床链接格式测试/","content":"本地文件名：【雪】2024-09-20 23_57_02.pnggithub文件名：https://github.com/dkyou/ImageHostingdku/blob/main/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png https://github.com/dkyou/ImageHostingdku/blob/main/img/【雪】2024-09-20%2023_57_02.png 复制markdown 复制HTML 复制URLhttps://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png 复制UBB[IMG]https://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png[/IMG] 复制customhttps://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/【雪】2024-09-20 23_57_02.png 自己常用格式：","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"搭建图床笔记","path":"/2024/09/20/搭建图床笔记/","content":"图床准备工作 github账号注册：必须，但省略 下载PicGo,链接如下：必须 ​\thttps://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/ typora软件：非必须，最好有。也可找其他mrakdown代替，比如我使用的vscode+Markdown All in One 图床是什么图床可以翻译为”image hosting”或者”image storage”，主要功能包括： 图片上传：用户可以将图片上传到图床平台。 图片存储：平台会存储用户的图片，并提供一定的管理和访问权限。 图片分享：用户可以获得图片的直接链接，并通过这些链接在其他网站、论坛、社交媒体等地方分享图片。 图片管理：用户可以在图床上管理自己的图片，包括查看、编辑、删除等操作。 国内常见的图床服务 七牛云 阿里云oss 又拍云 之前我一直将图片上传到七牛云，但是七牛云的免费域名只有30天，到期了有需要重新申请，解决方案是自己申请一个域名，便可以长期使用七牛云的免费空间额度进行图床搭建。个人实在不想折腾，于是选择了github的搭建方案，相比于其他国内的搭建方案，步骤可谓非常简单，而且不限制容量。 网上查了一些攻略说github搭建图床的缺点是访问速度慢，但是仔细一想，我的笔记写来是给自己看的，对速度没有要求。 使用github搭建图床思路：其实很简单，就是在github上建立一个public的仓库，然后使用该仓库作为图床服务器存储 1. 创建新仓库默认 仓库名随意，一定设置为public 2. 生成token令牌setting-Developer Settings-Personal access tokens-Tokens(classic)-Generate new token(classic) 然后创建tokens即可，这个步骤可能让你验证账号之类的，接下来就是一些token的设置如下： **note：**随便填写，没有影响 **expiration：**也可以随便填写，可以填永久，也可以按照自己的需求填写，我目前还不知道到期了有什么影响2024年10月14日更新：实测7天过期之后只需要重新生成即可，不需要进行任何多余的操作，十分简单。因此，不建议永久有效。 **select scopes:**勾选repo前边的选项 具体设置见下图： 其他设置全部默认，然后拉到最后点击蓝色的Generate Tokes等待生成即可 注意：生成的token记得复制备份，之后的PicGo设置需要用到 PicGo来实现图片上传PicGo是方便我们进行图片上传的，而且方便我们对图片进行管理。 下载地址：https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/ 1. PicGo设置：选择：图床设置-Github，然后进行核心配置 **设定仓库名：**格式为用户名/仓库名直接复制下方红框中的内容也可。 **设定分支名：**一般为main或者master，具体需要看自己的设置 设置token：就是github搭建图床生成的token 设定存储路径：img/可根据自己喜好填写即可 **自定义域名：**这个需要一个免费的加速域名，可以直接用https://cdn.jsdelivr.net/gh/,或者自己申请一个。 具体格式为：加速域名+账户名+仓库名/分支名，中间+号不用填写，举例： https://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku 以上便完成了PicGo的所有设置，详情见下图： 之后，可以返回上传区域，直接上传即可，也可以把github设置为默认图床 2. 使用PicGo上传图片到github仓库拖拽即可，非常简单 3. 引用PicGo的链接到typora中进行测试点击复制即可得到以下markdown格式的图片链接，插入到markdown中即可解析出图片 ![](https://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png)` 当然也可以选择HTML URL等等其他格式的链接，非常灵活 4. 测试结果 设置Typora实现插入到typora的图片自动上传到图床前提：开启代理 打开typora，依次点击：文件-偏好设置-图像。选择 上传服务，设置一下picgo和picgo路径。比较简单，就不贴图了。 这样之后插入到Typora的图片就会自动上传到github仓库里了 批量转移图床这里只是记录一下批量转移图床的思路，具体我还没有遇到过，但是我感觉我很有可能以后会遇到。 简单思路：使用vscode或者typora的批量替换功能可以实现图片关键信息链接的替换，vscode似乎可以替换多个文件。 参考链接 如何用github搭建图床（亲测有效）_github图床-CSDN博客 2024新版-使用GitHub搭建个人图床-CSDN博客","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"搭建博客","path":"/2024/09/20/网上一些主题推荐/","content":"Stellar 主题 https://xaoxuu.com/wiki/stellar/#startSolitude 主题 https://solitude.js.org/config/basic https://blog.everfu.cn/https://blog.lixiaomu.fun/posts/43857/ 16 款精美的 hexo 博客主题推荐 https://pengtech.net/hexo/hexo_theme_recommendation.html#5-Stellar-%E4%B8%BB%E9%A2%98 更新主题截止到2024年12月25日，我所使用的主题是 Stellar 稳定版 安装方法： 进入myblog目录，执行 npm i hexo-theme-stellar 在myblog_config.yml文件中修改为： theme: stellar 更新方法： 进入myblog目录，执行： npm i hexo-theme-stellar 以上内容更新时间为：2024年12月25日","tags":["hexo","搭建博客","主题"],"categories":["搭建博客"]},{"title":"LVGL","path":"/2024/09/20/LVGL/","content":"LVGL常用API对齐lv_obj_align和lv_obj_align_to区别 void lv_obj_align(lv_obj_t * obj, lv_align_t align, int32_t x_ofs, int32_t y_ofs) 功能：将对象obj对齐到其父对象参数：obj：要对齐的对象 align：对齐方式 x_ofs：x轴偏移 y_ofs：y轴偏移 void lv_obj_align_to(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, int32_t x_ofs, int32_t y_ofs)功能：将对象obj对齐到指定的基准对象base参数：obj：要对齐的对象 base：基准对象 align：对齐方式 x_ofs：x轴偏移 y_ofs：y轴偏移 区别：lv_obj_align 是将对象对齐到其父对象。lv_obj_align_to 是将对象对齐到指定的基准对象 base，灵活性更高","tags":["嵌入式","LVGL"],"categories":["LVGL"]},{"title":"hexo+github搭建博客笔记","path":"/2024/09/20/hexo+github搭建博客笔记/","content":"hexo+github搭建博客笔记1. 软件安装和使用1.Git 查看是否成功安装 git version 绑定git邮箱和git用户，命令如下： git config --global user.name dkyou #输入git不需要双引号git config --global user.email 2323@xx.com 2.安装NodeJS 2.1 NodeJS 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 IO 的模型，使其轻量又高效。 简单的说 Node.js 就是运行在服务端的 JavaScript，利用JavaScript在服务端进行编程。 关于NodeJS是什么可以参考：nodejs(第一篇)：nodejs是什么？ 2.2 安装并配置环境变量，可以参考：[Node.js安装及环境配置超详细教程](Node.js安装及环境配置超详细教程[Windows系统]_windows 安装nodejs-CSDN博客) 2025年11月1日补充参考链接，可优先参考：2024最新版Node.js下载安装及环境配置教程【保姆级】_nodejs下载-CSDN博客 2.3 同样的，使用命令查看是否安装成功 node -vnpm -v 3.Hexo安装和设置 3.1 hexo安装命令 npm install -g hexo-cli#用于全局安装 Hexo 的命令行工具 以下是上述命令的解释： 1.npmnpm 是 Node.js 包管理器（Node Package Manager）的缩写，用于管理和安装 Node.js 应用程序的依赖包。2.installinstall 是 npm 的一个子命令，用于安装指定的包。3. -g-g 表示全局安装（global）。这意味着包将被安装到系统的全局位置，而不是项目的本地 node_modules 目录中。全局安装的包可以在系统中的任何位置使用。hexo-cli4. hexo-cli 是 Hexo 的命令行接口工具。Hexo 是一个静态站点生成器，可以用来快速生成静态博客或网站。 3.2 新建一个文件夹，例如”D:\\myblog”，不需要进入该文件夹，直接鼠标右键—Git Bash Here，依次执行以下命令 初始化myblog,即从https://github.com/hexojs/hexo-starter.git克隆文件，并且安装依赖 hexo init myBlog 进入myblog文件夹，并且执行npm install命令 cd myBlognpm install 运行hexo s命令 hexo s 根据提示，可以直接在浏览器中输入http://localhost:4000/,回车即可看到效果 这是部署在本地的默认的一篇hello world博客，使用的是默认theme: landscape主题，此时和github还没有任何关系。 补充工作 Stellar 1.33.1版本的脚本依赖probe-image-size（可选） npm i probe-image-size --save hexo d依赖hexo-deployer-git工具 npm i hexo-deployer-git --save 否则出现以下报错 $ hexo dINFO Validating configINFO ------------------------------------------------INFO Welcome to Stellar 1.33.1DOCS https://xaoxuu.com/wiki/stellar/REPO https://github.com/xaoxuu/hexo-theme-stellar.gitINFO ------------------------------------------------ERROR Deployer not found: git 2. 主题安装可从主题官网下载自己喜欢的主题：Themes | Hexo 以hexo-theme-Chic为例设置自己的主题,链接：https://github.com/Siricee/hexo-theme-Chic.git 执行git clone https://github.com/Siricee/hexo-theme-Chic.git或者直接download zip将下载的主题文件解压放在D:\\myblog\\themes文件夹中。注意文件名为hexo-theme-Chic后边没有-master和其他信息。 在D:\\myblog中找到_config.yml，使用记事本或者vscode等打开，在第100行左右找到theme: landscape，改为theme: hexo-theme-Chic。 注意：这里的_config.yml是根目录下的，即”D:\\myblog\\_config.yml”，不是D:\\myblog\\themes\\hexo-theme-Chic下的_config.yml 依次执行以下命令 hexo ghexo s 根据提示，可以直接在浏览器中输入http://localhost:4000/,回车即可看到更换主题之后的效果 themes主题文件结构： .├── _config.yml├── languages├── layout├── scripts└── source 主题配置文件设置：D:\\myblog\\themes\\hexo-theme-Chic下的_config.yml #文件位置`D:\\myblog\\themes\\hexo-theme-Chic`下的`_config.yml`# Header navname: dkus Blog //对应左上角# 对应右上角 Posts Categories Tags About# navigatior itemsnav: Posts: /archives Categories: /category Tags: /tag About: /about# favicon 浏览器网址栏显示的图标，但是不知道为什么我默认的不是favicon.ico，而是我之前设置的神里凌华的图片，有点奇怪favicon: /favicon.ico# Profile 中间显示的名字nickname: Dku### this variable is MarkDown form.# 个人描述 显示在图像下边description: Lorem ipsum dolor sit amet, **consectetur adipiscing elit.** brFusce eget urna vitae velit *eleifend interdum at ac* nisi.# 个人头像图片avatar: /image/avatar.jpeg# main menu navigation## links key words should not be changed.## Complete url after key words.## Unused key can be commented out.#常用网站的个人链接，取消注释添加即可links: Blog: /archives # Category: # Tags: # Link: # Resume: # Publish: # Trophy: # Gallery: # RSS: # AliPay: ZhiHu: https://www.zhihu.com/people/sirice # LinkedIn: # FaceBook: # Twitter: # Skype: # CodeSandBox: # CodePen: # Sketch: # Gitlab: # Dribbble: Instagram: Reddit: # YouTube: # QQ: # Weibo: # WeChat: Github: https://github.com/Siricee# how links show: you have 2 choice--text or icon.# 图标或者文字显示常用网站的个人链接links_text_enable: falselinks_icon_enable: true# Post page## Post_metapost_meta_enable: truepost_author_enable: truepost_date_enable: truepost_category_enable: true## Post copyrightpost_copyright_enable: truepost_copyright_author_enable: truepost_copyright_permalink_enable: truepost_copyright_license_enable: truepost_copyright_license_text: Copyright (c) 2019 a href=http://creativecommons.org/licenses/by-nc/4.0/CC-BY-NC-4.0/a LICENSEpost_copyright_slogan_enable: truepost_copyright_slogan_text: Do you believe in strongDESTINY/strong?## tocpost_toc_enable: true# Pagepage_title_enable: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/#日期格式date_format: MMMM D, YYYYtime_format: H:mm:ss# stylesheets loaded in the headstylesheets: - /css/style.css# scripts loaded in the end of the bodyscripts: - /js/script.js - /js/tocbot.min.js # tscanlin/tocbot: Build a table of contents from headings in an HTML document. # https://github.com/tscanlin/tocbot# plugin functions## Mathjax: Math Formula Support## https://www.mathjax.orgmathjax: enable: true import: demand # global or demand ## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong. ## demand: Recommend option,if your post need fomula, you can declare mathjax: true in Front-matter 更改完D:\\myblog\\themes\\hexo-theme-Chic下的_config.yml配置文件之后，可以依次执行hexo g hexo s根据提示，在浏览器中输入http://localhost:4000/,回车即可看到设置主题之后的效果 可以设置的东西挺多，简单设置的效果 补充工作安装主题可以通过两种方式进行，以我现在使用的Stellar 1.33.1为例 通过npm方式安装 安装和更新均执行npm i hexo-theme-stellar 在 blog/_config.yml 文件中找到并修改 theme: stellar 源码方式安装 通过npm方式安装非常简单，但是对于通过在theme文件夹下新增源代码的方式，需要多做一步操作。 把 Stellar 主题仓库添加为博客仓库的子模块，这里我fork了作者的仓库 git submodule add https://github.com/dkyou/hexo-theme-stellar.git themes/stellar 复制themes\\hexo-theme-stellar\\_config.yml到根目录，并重命名为_config.stellar.yml 说明：两个配置文件应该都要设置，并且根目录下的_config.stellar.yml优先级大于主题文件夹下的配置文件 在 blog/_config.yml 文件中找到并修改： theme: hexo-theme-stellar 3.将hexo博客部署到github上以上，所有的设置和内容都只能显示在自己的电脑上，如何部署到github上？ 3.1 准备工作—新建仓库并设置ssh key 如果之前已经使用hexo搭建过博客，或者设置过以下内容，则无需再进行设置！如果想了解什么是ssh key及其原理，可以参考ssh_key简记，本文只讲如何操作。 新建一个github仓库，仓库名要按照：用户名.github.io设置 配置ssh key,使用git配置ssh key，命令如下 git config --global user.name dkyou #输入git不需要双引号git config --global user.email 2323@xx.comssh-keygen -t rsa -C 2323@xx.com 查看ssh cat ~/.ssh/id_rsa.pub 添加可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功。 ssh -T git@github.com 登陆 Github 上添加刚刚生成的SSH key，按如下步骤添加，右上角点击头像- settings - SSH and GPG keys，建立一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认建立，这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。 3.2 部署 在D:\\myblog中找到_config.yml，使用记事本或者vscode等打开，找到最后几行，改为 # 文件路径：D:\\myblog\\_config.ymldeploy: type: git repo: https://github.com/dkyou/dkyou.github.io branch: master 安装 hexo-deployer-git npm install hexo-deployer-git --save 执行命令上传 hexo g #生成hexo d #上传 有时候在执行hexo d会报错，再执行一次就可以 成功的截图 接下来使用用户名.github.io即可访问部署到github上的博客 成功部署到github效果演示 4.更新文章可以使用hexo new 文章标题命令来创建一个文章标题.md文件，也可以按照格式直接将自己的.md 文件复制到D:\\myblog\\source\\_posts\\文件夹中，同时按照以下格式添加一些命令 使用hexo new 文章标题命令来创建一个文章标题.md文件 hexo new 文章标题 博客语法结构: ---title: Hello World #文章标题date: 2024-09-20 20:13:20tags: [tag1,tag2,...]categories: --- 将新文章部署到github上 hexo g # 生成，必须hexo s # 本地渲染，非必要hexo d # 部署到Github 上，必须 注意：一个主题可能有以下文件结构 .├── _config.yml├── languages├── layout├── scripts└── source 涉及到hexo d的文件 Source 文件夹。 将您的素材（如 CSS 和 JavaScript 文件）放在这里。 文件或文件夹开头名称为 _（下划线）或隐藏的文件会被忽略。 Hexo 将处理所有可渲染的文件，并将它们保存到 public 文件夹下。 不可渲染的文件将直接复制到 public 文件夹。 hexo d也会把D:\\myblog\\source_posts中的md文件上传到 public 文件夹下，如果_post的md文件被删除或者增加，则会完全覆盖github中的md文件，所以不要轻易删除_post文件夹下的md文件。 5.博客备份为了方便换电脑的时候移植笔记，我将笔记通过 GitHub 托管源代码。同时将主题作为仓库子模块。 克隆项目： git clone git@github.com:dkyou/blog-source.gitcd blog-sourcegit submodule update --init --recursive 安装 Hexo 环境： npm install hexo-cli -gnpm install 安装deployer npm i hexo-deployer-git --save 确认 _config.yml 里部署设置（SSH 模式） 测试： hexo g hexo s 打开 http://localhost:4000 看是否正常 部署： hexo d 之后对主题的修改都在 themes/hexo-theme-stellar 里做： cd themes/hexo-theme-stellar# 修改文件...git add .git commit -m xxxgit push -u origin maincd -# 回到主仓库，提交“子模块指针”的变更git add themes/hexo-theme-stellargit commit -m xxxgit push 6.拉取原仓库问题描述：在fork完原 https://github.com/xaoxuu/hexo-theme-stellar.git仓库为自身仓库it@github.com:dkyou/hexo-theme-stellar.git之后，修改并推送了_config.yml文件。现在想要新建main-dky分支用于保存自己的修改，main分支用于跟踪原仓库更新，再合并变基进main-dky。注意以后不要在main分支上写代码。 upstream → 原作者的仓库（xaoxuu/hexo-theme-stellar） origin → 自己的 fork（dkyou/hexo-theme-stellar） 本地有两个分支： main：只用来同步上游，不做改动； main-dky：你自己的开发分支，用来改配置文件、主题样式等。 整理历史添加 upstream（只需一次） git remote add upstream https://github.com/xaoxuu/hexo-theme-stellar.gitgit fetch upstream 把当前 main 上的个人改动“搬家”到新分支，做个备份 git checkout -b main-dkygit push -u origin main-dky # 备份到你的 fork 把 main 重置为上游（保持 main 干净镜像 upstream） git checkout main# 如果不确定上游默认分支名，先看一下（通常是 main）：git remote show upstream # 会显示 HEAD branch: maingit reset --hard upstream/main 覆盖 fork 的 main（需要强推） git push -f origin main 同步和更新同步上游 → main git checkout main# --ff-only (fast-forward)参数快进方式更新本地maingit pull --ff-only upstream main# 本地更新后的 main 推送回自己在 GitHub 上的 fork（origin）git push origin main 把上游更新带到自己开发分支 git checkout main-dky# 把刚才同步到 main 的上游更新合并进 main-dkygit merge main # 或：git rebase main（更线性）# 更新后的 main-dky 推回你的远程仓库（origin/main-dky）git push origin main-dky 增加一个关于我[about]页 新建source/about/index.md文件添加以下内容: ---title: Aboutlayout: pagecomments: false---## 嗨，我是 👋- 研究方向：- 正在做的事：**联系我**- GitHub：[xxx](https://github.com/xxx)- 邮箱：you@example.com 其他地方无需更改，编译，生成，上传即可。但是不知道前两天为什么不行，今天突然就可以了。 增加一个friends和explore页对于新增explore来说，只需要新建source/explore/index.md文件，然后添加内容即可。 对于friends来说，除了要新建source/explore/index.md文件外，如果要使用静态友链，需要新建source\\_data\\links\\friends-developer.yml文件，并添加内容。添加内容可以是： # 每条就是一个友链- title: xxx url: https:// cover: icon: description: - title: xaoxuu url: https://xaoxuu.com/ avatar: description: Stellar 主题作者 · 创意前端开发者 在source/explore/index.md或任意md文档中引用方式如下： % friends friends-developer % 完结！","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"ssh_key简记","path":"/2024/09/20/ssh_key/","content":"摘要：本文是上篇《hexo+github搭建博客笔记》的一些补充。翻阅博客的时候，对本地博客怎么部署到github上，以及如何配置SSH密钥，以及如何将公钥添加到远程服务器上的原理有一些不清楚，于是作了一个笔记，记录下来。 SSH 密钥生成SSH密钥SSH 密钥用于安全地连接到远程服务器，通常用于无密码登录和身份验证。以下是如何生成和使用 SSH 密钥的步骤： 生成 SSH 密钥打开终端： 在 Linux ，打开终端。在 Windows 上，使用 Git Bash。生成 SSH 密钥对： ssh-keygen -t rsa -b 4096 -C your_email@example.com -t rsa 指定密钥类型为 RSA。 -b 4096 指定密钥长度为 4096 位。 -C “your_email@example.com“ 添加一个标签，通常是你的电子邮件地址。 保存密钥：按回车键接受默认文件位置（通常是 ~.sshid_rsa）。输入一个密码（可选）以增加安全性。查看生成的密钥生成的密钥对将保存在 ~.ssh 目录下： 私钥：id_rsa 公钥：id_rsa.pub 公钥： 加密：用于加密数据，只有对应的私钥才能解密。 签名验证：用于验证使用私钥签名的数据的正确性和完整性。 保密性：可以公开共享，通常用于添加到远程服务器的 ~.sshauthorized_keys 文件中，以便进行无密码登录。 私钥： 解密：用于解密使用公钥加密的数据。 签名：用于对数据进行签名，以证明数据的来源和完整性。 保密性：必须严格保密，不能公开。如果私钥泄露，攻击者可以冒充你进行身份验证或解密数据。 总结两者之间的关系： 公钥：添加到 GitHub 账户中，用于验证你的身份。 私钥：保存在你的本地机器上，用于解密 GitHub 发送的挑战。 将公钥添加到GitHub上 登录到你的 GitHub 账户。 进入 Settings SSH and GPG keys。 点击 New SSH key。 在 Title 中输入一个描述性的名称，例如 “My Laptop”。 在 Key 中粘贴你之前复制的公钥内容。 点击 Add SSH key。 测试 SSH 连接： ssh -T git@github.com% -T 选项：禁用伪终端分配。这使得命令的输出更简洁，更适合脚本和自动化任务。% git@github.com：指定你要连接的 GitHub 服务器和用户（git 用户）。 命令解释：简单回答：ssh -T git@github.com 是一个用于测试 SSH 连接到 GitHub 的命令。这个命令可以帮助你验证你的 SSH 密钥是否已经正确地添加到 GitHub 账户中，并且可以成功地进行身份验证。详细回答： 身份验证：当你运行 ssh -T git@github.com 时，GitHub 服务器会使用你提供的公钥来验证你的身份。具体来说，GitHub 会使用你的公钥来解密一个挑战（challenge），如果你的私钥能够成功解密这个挑战，GitHub 会认为你是合法用户。 公钥和私钥的关系：公钥和私钥是一对，公钥用于加密，私钥用于解密。当你在 GitHub 上添加公钥后，GitHub 会使用这个公钥来验证你提供的私钥是否匹配。 通过 ssh -T git@github.com 命令，你可以验证你的公钥是否已经正确添加到 GitHub 账户中，并且你的私钥是否能够成功进行身份验证 预期输出首次连接： 如果这是你第一次连接到 GitHub，系统会提示你确认 GitHub 的主机密钥指纹： The authenticity of host github.com (IP_ADDRESS) cant be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入 yes 继续连接。成功连接： 如果你的 SSH 密钥已正确添加到 GitHub 账户中，你会看到以下消息： Hi username! Youve successfully authenticated, but GitHub does not provide shell access. 其中 username 是你的 GitHub 用户名。 将公钥添加到远程服务器复制公钥： cat ~/.ssh/id_rsa.pub 复制输出的内容。将公钥添加到远程服务器：登录到远程服务器： ssh user@remote_host 创建 .ssh 目录（如果不存在）： mkdir -p ~/.ssh 将公钥添加到 authorized_keys 文件： echo your_public_key ~/.ssh/authorized_keys 设置正确的权限： chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 测试 SSH 连接退出远程服务器： exit 尝试无密码登录： ssh user@remote_host 如果一切配置正确，你应该能够无密码登录到远程服务器。 常见问题 权限问题：确保 .ssh 目录和 authorized_keys 文件的权限设置正确。 密钥密码：如果你在生成密钥时设置了密码，每次使用 SSH 连接时都需要输入该密码。可以使用 ssh-agent 来管理密钥密码： eval $(ssh-agent -s)ssh-add ~/.ssh/id_rsa 完","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"友链","path":"/2024/09/20/友链/","content":"友链创建多个友链组数据文件在 D:myblogsource_datalinks 目录下创建多个 YAML 文件，每个文件对应一个友链组。 示例文件结构 myblog/├── source/│ ├── _data/│ │ └── links/│ │ ├── ios_developer.yml│ │ ├── web_developer.yml│ │ └── design.yml 示例数据文件内容ios_developer.yml - title: 某某某 url: https://example1.com cover: https://example1.com/cover.jpg icon: https://example1.com/icon.png description: 这是一个 iOS 开发者的友链。 web_developer.yml - title: 某某某 url: https://example2.com cover: https://example2.com/cover.jpg icon: https://example2.com/icon.png description: 这是一个 Web 开发者的友链。 design.yml - title: 某某某 url: https://example3.com cover: https://example3.com/cover.jpg icon: https://example3.com/icon.png description: 这是一个设计师的友链。 在页面中插入不同的友链组在需要显示不同友链组的位置，使用相应的 Liquid 标签。 示例页面文件假设你在 myblog/source/_posts/2023-10-01-my-post.md 文件中插入多个友链组，编辑后的markdown文件可能如下所示： ---title: 友链date: 2024-09-20 20:13:20tags: [hexo,搭建博客]categories: 搭建博客---# 文章标题这是我的文章内容。## iOS 开发者友链% friends ios_developer %## Web 开发者友链% friends web_developer %## 设计师友链% friends design %## 友链组% friends ios_developer %## 其他内容其他文章内容。 效果展示备注：由于换主题，不能插入友链，因此暂时注释掉","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"双指针法合并顺序表","path":"/2024/09/20/双指针法合并顺序表/","content":"双指针法合并顺序表题目：有2个顺序表table1和table2，合并成一个新的顺序表 解法1思路： 双指针方法 复杂度： 时间复杂度： 空间复杂度： 代码： std::vectorint test::solution(std::vectorint table1, std::vectorint table2) std::vectorint result; int slow = 0,fast = 0; while (slowtable1.size()fasttable2.size()) if (table1[slow]table2[fast]) result.push_back(table1[slow]); slow++; else result.push_back(table2[fast]); fast++; while (slowtable1.size()) result.push_back(table1[slow]); slow++; while (fasttable2.size()) result.push_back(table2[fast]); fast++; return result;","tags":["c++","刷题"],"categories":["C++刷题笔记"]},{"title":"字母异位词","path":"/2024/09/20/leetcode刷题/每日一刷day31/","content":"字母异位词题目：给定两个字符串s和t，编写一个函数来判断 t 是否是 s 的字母异位词。 解法-哈希表思路：本能暴力循环，学习哈希表解决 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class Solution public: //aee //eae bool isAnagram(string s, string t) int record[26] = 0; //设定一个表，对应位置++ for (int i = 0; i s.size(); i++) record[s[i] - a]++; //然后再在对应位置-- for (int i = 0; i t.size(); i++) record[t[i] - a]--; for (int i = 0; i 26; i++) if (record[i] != 0) return false; return true; ;","tags":["c++","字母异位词"],"categories":["C++刷题笔记"]},{"title":"Linux嵌入式学习粗略笔记","path":"/2024/09/18/Linux嵌入式/","content":"🐧🐧🐧🐧🐧🐧🐧🐧🐧🐧🐧 一些缩写.elf 文件：Executable and Linkable Format，可执行连接格式编译(compilation)指令：gcc -S hello.c -o hello.s汇编(assembly)指令：gcc -c hello.s -o hello.o信号量：semaphoremisc:文件位于drivers\\char\\misc.c msic意思是杂项。因此 MISC 驱动也叫做杂项驱动，也就是当我们板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。 MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动，所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号， MISC 设备驱动就用于解决此问题。 MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。IOMUX是“InputOutput Multiplexer and Unifier”的缩写，中文可以翻译为“输入输出多路复用器和统一器”。它是一种电子设备或电路，用于在多个信号源和目标之间进行选择和转换。在具体应用中，IOMUX通常用于处理电子设备中的信号输入和输出。它可以将多个信号源（如不同的传感器或数据源）与多个目标（如不同的处理器或输出设备）进行连接和分配，从而实现信号的复用和转换。关键词解释： InputOutput（输入输出）：指设备或系统接收和发送数据的接口。 Multiplexer（多路复用器）：一种设备或技术，可以将多个信号或数据流合并为一个信号流进行传输或处理。 Unifier（统一器）：用于将不同来源或格式的数据、信号等统一处理或输出的设备或技术。IOMUX在许多电子设备和系统中都有应用，如嵌入式系统、微控制器、FPGA等，它可以帮助提高系统的效率和性能，同时减少硬件的复杂性和成本。 一些C语法c语言中将int变量转换为void *指针或int *指针在C语言中，将一个整型变量强制转换为void *指针类型通常是为了将整数值作为一个通用指针传递给函数，或者在特定的上下文中使用这个整数的值作为内存地址。进行这样的转换可以用类型转换运算符 (void *)。以下是一个简单的示例： int integerValue = 12345;void *pointerValue = (void *)(intptr_t)integerValue; 在这个例子中，整型变量integerValue的值被转换为一个intptr_t类型，然后再转换为void *类型。intptr_t是一种整数类型，它的大小足够存放指针，这保证了转换过程中不会丢失信息。这种转换方法是可移植性较好的，因为它考虑到了不同平台上指针和整数大小可能不一致的情况。 需要注意的是，这样的转换并不意味着整数真的变成了一个有效的内存地址。如果你打算通过这样的指针去访问内存，必须非常小心，确保这个整数值确实对应于一个合法且可访问的内存地址，否则会导致未定义行为，比如程序崩溃或者数据损坏。在多线程和异步编程中，将整数简单地作为数据通过指针传递给线程函数是一种常见且安全的用途。于是想到是否解引用pointerValue的值，发现是不可以的。目前暂时不知道将int 变量转换为void指针的目的是什么 #includestdio.hint main() int integerValue = 12345; int * pointerValue = (int *)integerValue;\t//int * pointerValue = (int *)(long)integerValue; printf(* pointerValue2 = %d,*pointerValue);\treturn 0; 这一部分问题在于： 将一个整数直接转换为指针并解引用该指针，这通常会导致未定义行为（undefined behavior）。因为在现代操作系统中，这样的指针几乎不可能指向合法的内存位置，因此解引用它的结果是不可预测的，可能会导致程序崩溃、数据损坏或安全漏洞。正确的做法是确保指针总是指向有效的、已分配的内存位置。对于测试的目的，我们应该构造一个安全的环境来模拟和验证逻辑，而不是直接执行可能导致未定义行为的操作。 一些有用的命令查看工具链中头文件和库文件的路径echo main(){}| arm-linux-gnueabihf-gcc -E -v -搜索某一个字符grep prefix * -nwr MakefileMakefile的引入及规则使用keil, mdk,avr等工具开发程序时点击鼠标就可以编译了，它的内部机制是什么？它怎么组织管理程序？怎么决定编译哪一个文件？ 答：实际上windows工具管理程序的内部机制，也是Makefile，我们在linux下来开发裸板程序的时候，使用Makefile组织管理这些程序，本节我们来讲解Makefile最基本的规则。Makefile要做什么事情呢？组织管理程序，组织管理文件，我们写一个程序来实验一下： 文件a.c 02\t#include stdio.h0304\tint main()05\t06\tfunc_b();07\treturn 0;08 文件b.c 2\t#include stdio.h34\tvoid func_b()5\t6 printf(This is B );7 编译： gcc -o test a.c b.c 运行： ./test 结果： This is B gcc -o test a.c b.c 这条命令虽然简单，但是它完成的功能不简单。 我们来看看它做了哪些事情， 我们知道.c程序 》 得到可执行程序它们之间要经过四个步骤： 1.预处理 2.编译 3.汇编 4.链接 我们经常把前三个步骤统称为编译了。我们具体分析：gcc -o test a.c b.c这条命令它们要经过下面几个步骤： 1）对于a.c：执行：预处理 编译 汇编 的过程，a.c xxx.s xxx.o 文件。 2）对于b.c：执行：预处理 编译 汇编 的过程，b.c yyy.s yyy.o 文件。 3）最后：xxx.o和yyy.o链接在一起得到一个test应用程序。 提示：gcc -o test a.c b.c -v ：加上一个**‘-v’**选项可以看到它们的处理过程， 第一次编译 a.c 得到 xxx.o 文件，这是很合乎情理的， 执行完第一次之后，如果修改 a.c 又再次执行：gcc -o test a.c b.c，对于 a.c 应该重新生成 xxx.o，但是对于 b.c 又会重新编译一次，这完全没有必要，b.c 根本没有修改，直接使用第一次生成的 yyy.o 文件就可以了。 缺点：对所有的文件都会再处理一次，即使 b.c 没有经过修改，b.c 也会重新编译一次，当文件比较少时，这没有没有什么问题，当文件非常多的时候，就会带来非常多的效率问题如果文件非常多的时候，我们，只是修改了一个文件，所用的文件就会重新处理一次，编译的时候就会等待很长时间。 对于这些源文件，我们应该分别处理，执行：预处理 编译 汇编，先分别编译它们，最后再把它们链接在一次，比如： 编译： gcc -o a.o a.cgcc -o b.o b.c 链接： gcc -o test a.o b.o 比如：上面的例子，当我们修改a.c之后,a.c会重现编译然后再把它们链接在一起就可以了。b.c就不需要重新编译。 那么问题又来了，怎么知道哪些文件被更新了被修改了？ 比较时间：比较 a.o 和 a.c 的时间，如果a.c的时间比 a.o 的时间更加新的话，就表明 a.c 被修改了，同理b.o和b.c也会进行同样的比较。比较test和 a.o,b.o 的时间，如果a.o或者b.o的时间比test更加新的话，就表明应该重新生成test。Makefile就是这样做的。我们现在来写出一个简单的Makefile: makefie最基本的语法是规则，规则： 目标 : 依赖1 依赖2 ...[TAB]命令 当“依赖”比“目标”新，执行它们下面的命令。我们要把上面三个命令写成makefile规则，如下： test ：a.o b.o //test是目标，它依赖于a.o b.o文件，一旦a.o或者b.o比test新的时候，就需要执行下面的命令，重新生成test可执行程序。gcc -o test a.o b.oa.o : a.c //a.o依赖于a.c，当a.c更加新的话，执行下面的命令来生成a.ogcc -c -o a.o a.cb.o : b.c //b.o依赖于b.c,当b.c更加新的话，执行下面的命令，来生成b.ogcc -c -o b.o b.c 我们来作一下实验： 在改目录下我们写一个Makefile文件： 文件：Makefile 1\ttest:a.o b.o2 gcc -o test a.o b.o3\t4\ta.o : a.c5 gcc -c -o a.o a.c7\tb.o : b.c8 gcc -c -o b.o b.c 上面是makefile中的三条规则。makefile,就是名字为“makefile”的文件。当我们想编译程序时，直接执行make命令就可以了，一执行make命令它想生成第一个目标test可执行程序,如果发现a.o 或者b.o没有，就要先生成a.o或者b.o，发现a.o依赖a.c，有a.c但是没有a.o,他就会认为a.c比a.o新，就会执行它们下面的命令来生成a.o，同理b.o和b.c的处理关系也是这样的。 如果修改a.c ，我们再次执行make，它的本意是想生成第一个目标test应用程序,它需要先生成a.o,发现a.o依赖a.c(执行我们修改了a.c)发现a.c比a.o更加新，就会执行gcc -c -o a.oa.c命令来生成a.o文件。b.o依赖b.c，发现b.c并没有修改，就不会执行gcc -c -o b.ob.c来重新生成b.o文件。现在a.o b.o都有了，其中的a.o比test更加新，就会执行 gcc -otest a.ob.o来重新链接得到test可执行程序。所以当执行make命令时候就会执行下面两条执行： gcc -c -o a.o a.cgcc -o test a.o b.o 我们第一次执行make的时候，会执行下面三条命令(三条命令都执行)： gcc -c -o a.o a.cgcc -c -o b.o b.cgcc -o test a.o b.o 再次执行make 就会显示下面的提示： make: `test is up to date. 我们再次执行make就会判断Makefile文件中的依赖，发现依赖没有更新，所以目标文件就不会重现生成，就会有上面的提示。当我们修改a.c后，重新执行make, 就会执行下面两条指令： gcc -c -o a.o a.cgcc -o test a.o b.o 我们同时修改a.c b.c，执行make就会执行下面三条指令。 gcc -c -o a.o a.cgcc -c -o b.o b.cgcc -o test a.o b.o a.c文件修改了，重新编译生成a.o, b.c修改了重新编译生成b.o，a.o,b.o都更新了重新链接生成test可执行程序，makefile的规则其实还是比较简单的。规则是Makefie的核心， 执行make命令的时候，就会在当前目录下面找到名字为：Makefile的文件，根据里面的内容来执行里面的判断命令。 shell pwd 和PWD的区别pwd:是一条命令，可以在makefile文件中引用(shel pwd)来获取当前目录PWD:是一个变量，可以直接echo $PWD来获取当前目录经过测试echo pwd和echo $PWD结果是一样的，推测可以在makefile文件中替换使用pwd $PWD $(shell pwd)一个shell pwd的例子，这样的例子很常见 INCDIR := $(shell pwd) //将shell pwd作为变量，通过 $(shell pwd)形式引用这个变量// C预处理器的flag，flag就是编译器可选的选项CPPFLAGS := -nostdlib -nostdinc -I$(INCDIR)/include //-nostdlib表示不使用标准库 //-nostdinc表示不使用标准头文件//-I是用来指定相对路径的，这里表示我们需要预处理的文件所在的路径是相对路径下的include文件夹 文件IO标准io和系统io的区别在于标准io引入了一个用户buffer，系统io没有。 系统io文件句柄：fd 0 1 2 3文件句柄如何和具体文件挂钩？ 0 - devpts0 代表标准输入 1 - devpts0 代表标准输出 2 - devpts0 代表标准错误 3 - homebook01_all_series_quickstart04_嵌入式Linux应用开发基础知识source06_fileio01_open1.txt 代表自己打开的文件 open 函数errno: 错误码，可以配合strerror(errno)来打印错误信息，效果同perrorperror(“open error”)用来打印错误信息 O_RDONLY: 以只读方式打开文件。O_WRONLY: 以只写方式打开文件。O_RDWR: 以读写方式打开文件。O_CREAT: 如果文件不存在，则创建之。以默认权限创建，最终的权限由mode和umask决定。O_EXCL: 当与O_CREAT一起使用时，如果文件已存在则打开失败。O_TRUNC: 打开文件后将其长度截断为0。O_APPEND: 写入时，数据将被追加到文件末尾。 int open(const char *pathname, int flags); 1)使用open创建一个不存在的文件 fd =open(argv[1],O_CREAT|O_RDWR)ssize_t write(int fd, const void *buf, size_t count);ssize_t read(int fd, void *buf, size_t count); 交叉编译 freetype1.编译程序时去哪找头文件 1）系统目录：交叉编译工具链的某个include 目录 2）自行指定：使用 -I dir 来指定2.链接时去哪找库文件 1）系统目录：交叉编译工具链的某个lib 目录 2）自行指定：使用 -L dir 来指定3.运行时去哪找库文件 1）系统目录：板子上的lib usrlib 目录 2）自行指定：使用 LD_LIBRARY_PATH 来指定4.运行时不需要头文件 homebook100ask_imx6ull-sdkToolChainarm-buildroot-linux-gnueabihf_sdk-buildrootarm-buildroot-linux-gnueabihfsysrootusrinclude LIBRARY_PATHhomebook100ask_imx6ull-sdkToolChainarm-buildroot-linux-gnueabihf_sdk-buildrootarm-buildroot-linux-gnueabihfsysrootusrlib 输入设备内核中使用input_dev结构体来描述一个输入设备。 //D:\\Linux-4.9.88\\include\\linux\\input.hstruct input_dev const char *name;\tconst char *phys;\tconst char *uniq;\tstruct input_id id;\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)];\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)];\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)];\tunsigned int hint_events_per_packet;\tunsigned int keycodemax;\tunsigned int keycodesize;\tvoid *keycode;\tint (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode);\tint (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke);\tstruct ff_device *ff;\tunsigned int repeat_key;\tstruct timer_list timer;\tint rep[REP_CNT];\tstruct input_mt *mt;\tstruct input_absinfo *absinfo;\tunsigned long key[BITS_TO_LONGS(KEY_CNT)];\tunsigned long led[BITS_TO_LONGS(LED_CNT)];\tunsigned long snd[BITS_TO_LONGS(SND_CNT)];\tunsigned long sw[BITS_TO_LONGS(SW_CNT)];\tint (*open)(struct input_dev *dev);\tvoid (*close)(struct input_dev *dev);\tint (*flush)(struct input_dev *dev, struct file *file);\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\tstruct input_handle __rcu *grab;\tspinlock_t event_lock;\tstruct mutex mutex;\tunsigned int users;\tbool going_away;\tstruct device dev;\tstruct list_head\th_list;\tstruct list_head\tnode;\tunsigned int num_vals;\tunsigned int max_vals;\tstruct input_value *vals;\tbool devres_managed;;设备ID结构体为```C struct input_id __u16 bustype;\t__u16 vendor;\t__u16 product;\t__u16 version;;__u16 bustype;//枚举类型，如usb,pci等等取值为：#define BUS_PCI 0x01#define BUS_ISAPNP 0x02#define BUS_USB 0x03#define BUS_HIL 0x04#define BUS_BLUETOOTH 0x05#define BUS_VIRTUAL 0x06#define BUS_ISA 0x10#define BUS_I8042 0x11#define BUS_XTKBD 0x12#define BUS_RS232 0x13#define BUS_GAMEPORT 0x14#define BUS_PARPORT 0x15#define BUS_AMIGA 0x16#define BUS_ADB 0x17#define BUS_I2C 0x18#define BUS_HOST 0x19#define BUS_GSC 0x1A#define BUS_ATARI 0x1B#define BUS_SPI 0x1C#define BUS_RMI 0x1D#define BUS_CEC 0x1E#define BUS_INTEL_ISHTP 0x1F__u16 vendor;__u16 product;__u16 version;厂商号，产品号，版本号 内核使用input_event结构体来描述“输入事件” //include\\uapi\\linux\\input.hstruct input_event struct timeval time;\t__u16 type;\t__u16 code;\t__s32 value;;struct timeval\tlong tv_sec;\tlong tv_usec;;struct timeval time;记录了input_event时间发生的时间，这个包括秒和微秒，时间起点是系统启动的时刻。__u16 type;记录了哪一类事件在include\\uapi\\linux\\input-event-codes.h中，详细定义了事件类型 /* * Event types */#define EV_SYN 0x00//表示设备支持所有的事件?#define EV_KEY 0x01//键盘或者按键#define EV_REL 0x02//relative,鼠标或者相对坐标位置#define EV_ABS 0x03//absolute，手写板的值，绝对整数值#define EV_MSC 0x04//其他类型事件#define EV_SW 0x05#define EV_LED 0x11//LED设备事件#define EV_SND 0x12//蜂鸣器事件#define EV_REP 0x14//重复按键类型事件#define EV_FF 0x15#define EV_PWR 0x16//电源管理事件#define EV_FF_STATUS 0x17#define EV_MAX 0x1f#define EV_CNT (EV_MAX+1)__u16 code;记录了哪一个事件code 根据type的不同而有不同的含义例如：type = EV_KEY//按键事件，code表示键盘code或鼠标button值#define REL_X 0x00#define REL_Y 0x01#define REL_Z 0x02#define REL_RX 0x03#define REL_RY 0x04#define REL_RZ 0x05#define ...#define KEY_MAX 0x2ff#define KEY_CNT (KEY_MAX+1)例如：\ttype = EV_REL时，code表示操作的是哪个坐标轴，如REL_X,REL_Y /* * Relative axes */#define REL_X 0x00#define REL_Y 0x01#define REL_Z 0x02#define REL_RX 0x03#define REL_RY 0x04#define REL_RZ 0x05#define REL_HWHEEL 0x06#define REL_DIAL 0x07#define REL_WHEEL 0x08#define REL_MISC 0x09#define REL_MAX 0x0f#define REL_CNT (REL_MAX+1)例如：type = EV_ABS时，code表示绝对坐标轴的值 /* * Absolute axes */#define ABS_X 0x00#define ABS_Y 0x01#define ABS_Z 0x02#define ABS_RX 0x03#define ABS_RY 0x04#define ABS_RZ 0x05#define ...//表示正在修改的多点触控槽位，用于跟踪多个接触点。#define ABS_MT_SLOT 0x2f\t/* MT slot being modified *///触摸椭圆的主要轴长，表示接触区域的最大尺寸。#define ABS_MT_TOUCH_MAJOR\t0x30\t/* Major axis of touching ellipse *///触摸椭圆的次要轴长，如果接触区域是圆形，则忽略此值#define ABS_MT_TOUCH_MINOR\t0x31\t/* Minor axis (omit if circular) *///接近椭圆的主要轴长，可能比实际接触区域更大。#define ABS_MT_WIDTH_MAJOR\t0x32\t/* Major axis of approaching ellipse *///接近椭圆的次要轴长，如果接近区域是圆形，则忽略此值#define ABS_MT_WIDTH_MINOR\t0x33\t/* Minor axis (omit if circular) *///椭圆的方向，用于描述接触点的倾斜角度。#define ABS_MT_ORIENTATION\t0x34\t/* Ellipse orientation */// 触摸中心的X坐标位置。#define ABS_MT_POSITION_X\t0x35\t/* Center X touch position */#define ABS_MT_POSITION_Y\t0x36\t/* Center Y touch position *///触摸设备的类型，如手指、笔等。#define ABS_MT_TOOL_TYPE\t0x37\t/* Type of touching device *///将一组数据包分组为一个“blob”（数据块），用于关联相关的触摸事件。#define ABS_MT_BLOB_ID 0x38\t/* Group a set of packets as a blob *///跟踪接触的唯一ID，用于识别特定的触摸接触。或许应该翻译成初始触摸点唯一id？#define ABS_MT_TRACKING_ID\t0x39\t/* Unique ID of initiated contact *///在接触区域上的压力大小。#define ABS_MT_PRESSURE 0x3a\t/* Pressure on contact area *///接触点悬停时的距离，用于检测未实际接触但靠近传感器的情况。#define ABS_MT_DISTANCE 0x3b\t/* Contact hover distance *///工具中心的X坐标位置，可能与ABS_MT_POSITION_X不同，例如对于笔或其他工具。#define ABS_MT_TOOL_X 0x3c\t/* Center X tool position */#define ABS_MT_TOOL_Y 0x3d\t/* Center Y tool position */#define ABS_MAX 0x3f#define ABS_CNT (ABS_MAX+1)__s32 value;记录了事件的值同样的value也会根据type的值不同而有不同的含义例如：type = EV_KEY时，value表示按键的值，0表示按键没有按下，1表示按键按下//这里没有找到定义，网上查的type = EV_REL时，value表示移动的值和方向（正负）type = EV_ABS时，value表示移动的绝对坐标 当一个事件上传完之后，会上报一个“同步事件”，表示数据上传完毕。同步事件也是一个input_event结构体，type EV_SYN，code SYN_REPORT，value 0.即0 0 0 查看有哪些输入设备： ls /dev/input/* -lcrw-rw---- 1 root input 13, 64 Jan 1 00:00 /dev/input/event0crw-rw---- 1 root input 13, 65 Jan 1 00:00 /dev/input/event1crw-rw---- 1 root input 13, 66 Jan 1 00:00 /dev/input/event2crw-rw---- 1 root input 13, 63 Jan 1 00:00 /dev/input/mice//鼠标/dev/input/by-path:total 0lrwxrwxrwx 1 root root 9 Jan 1 00:00 platform-20cc000.snvs:snvs-powerkey-event - ../event0lrwxrwxrwx 1 root root 9 Jan 1 00:00 platform-gpio-keys-event - ../event2获取与 event 对应的相关设备信息 cat /proc/bus/input/devicesI: Bus=0019 Vendor=0000 Product=0000 Version=0000//I 设备IDN: Name=20cc000.snvs:snvs-powerkey//Name P: Phys=snvs-pwrkey/input0//物理路径S: Sysfs=/devices/soc0/soc/2000000.aips-bus/20cc000.snvs/20cc000.snvs:snvs-powerkey/input/input0//位于 sys 文件系统的路径U: Uniq=//唯一标识符H: Handlers=kbd event0 evbug//输入句柄HandlerB: PROP=0//B位图B: EV=3B: KEY=100000 0 0 0 //与04_嵌入式Linux应用开发基础知识\\source\\11_input\\01_app_demo\\01_get_input_info.c结果相同I: Bus=0018 Vendor=dead Product=beef Version=28bbN: Name=goodix-ts//触摸屏即#define BUS_I2C 0x18P: Phys=input/tsS: Sysfs=/devices/virtual/input/input1U: Uniq=H: Handlers=event1 evbugB: PROP=2B: EV=bB: KEY=1c00 0 0 0 0 0 0 0 0 0 0B: ABS=6e18000 0I: Bus=0019 Vendor=0001 Product=0001 Version=0100N: Name=gpio-keysP: Phys=gpio-keys/input0S: Sysfs=/devices/soc0/gpio-keys/input/input2U: Uniq=H: Handlers=kbd event2 evbugB: PROP=0B: EV=3B: KEY=c 获取设备信息使用hexdump命令hexdump /dev/input/event1来获取设备信息 //下表中与值相对应的事件类型type#define EV_ABS 0x03//绝对坐标事件#define EV_KEY 0x01//键盘或者按键事件#define EV_SYN 0x00//下表中与值相对应的事件code#define BTN_TOUCH 0x14a 下表为使用一个手指点击触摸屏返回的数据 序号 秒 微秒 type code value type code value数值代表的详细信息 0000000 7180 0000 57bc 0006 0003 0039 0014 0000 EV_ABS ABS_MT_TRACKING_ID 14 0000010 7180 0000 57bc 0006 0003 0035 006f 0000 EV_ABS ABS_MT_POSITION_X 0000020 7180 0000 57bc 0006 0003 0036 013a 0000 EV_ABS ABS_MT_POSITION_Y 0000030 7180 0000 57bc 0006 0003 0030 001e 0000 EV_ABS ABS_MT_TOUCH_MAJOR 0000040 7180 0000 57bc 0006 0003 003a 001e 0000 EV_ABS ABS_MT_PRESSURE 0000050 7180 0000 57bc 0006 0001 014a 0001 0000 EV_KEY BTN_TOUCH 0000060 7180 0000 57bc 0006 0000 0000 0000 0000 EV_SYN 0000070 7180 0000 27c5 0007 0003 0039 ffff ffff ABS_MT_TRACKING_ID -1 0000080 7180 0000 27c5 0007 0001 014a 0000 0000 EV_KEY BTN_TOUCH 0000090 7180 0000 27c5 0007 0000 0000 0000 0000 EV_SYN 对于多点触摸会上传ABS_MT_SLOT,数据更加复杂一些，但是原理是差不多的，会看信息表即可 获取设备信息int ioctl(int fd, unsigned long request, ...)//输入格式request要求：//include\\uapi\\asm-generic\\ioctl.h#define _IOC(dir,type,nr,size) \\\t(((dir) _IOC_DIRSHIFT) | \\ ((type) _IOC_TYPESHIFT) | \\ ((nr) _IOC_NRSHIFT) | \\ ((size) _IOC_SIZESHIFT))dir:_IOC_READ 读数据 _IOC_WRITE 写数据size:ioctl传输的字节数type:nr: _IOC_NR _IOC_TYPE _IOC_SIZE _IOC_DIR可以参考这篇博客 requret可以取以下值： //include\\uapi\\linux\\input.h#define EVIOCGVERSION _IOR(E, 0x01, int) /* get driver version */#define EVIOCGID _IOR(E, 0x02, struct input_id)\t/* get device ID */#define EVIOCGREP _IOR(E, 0x03, unsigned int[2])\t/* get repeat settings */#define EVIOCSREP _IOW(E, 0x03, unsigned int[2])\t/* set repeat settings */#define EVIOCGKEYCODE _IOR(E, 0x04, unsigned int[2]) /* get keycode */#define EVIOCGKEYCODE_V2\t_IOR(E, 0x04, struct input_keymap_entry)#define EVIOCSKEYCODE _IOW(E, 0x04, unsigned int[2]) /* set keycode */#define EVIOCSKEYCODE_V2\t_IOW(E, 0x04, struct input_keymap_entry)#define EVIOCGNAME(len) _IOC(_IOC_READ, E, 0x06, len) /* get device name */#define EVIOCGPHYS(len) _IOC(_IOC_READ, E, 0x07, len) /* get physical location */#define EVIOCGUNIQ(len) _IOC(_IOC_READ, E, 0x08, len) /* get unique identifier */#define EVIOCGPROP(len) _IOC(_IOC_READ, E, 0x09, len) /* get device properties */#define EVIOCGBIT(ev,len)\t_IOC(_IOC_READ, E, 0x20 + (ev), len)\t/* get event bits */#define EVIOCGABS(abs) _IOR(E, 0x40 + (abs), struct input_absinfo)\t/* get abs value/limits */#define EVIOCSABS(abs) _IOW(E, 0xc0 + (abs), struct input_absinfo)\t/* set abs value/limits */#define ... 软件访问硬件的几种方式1.查询方式示例：软件调用open函数，传入非阻塞参数O_NONBLOCK,如果驱动程序中有数据则立刻返回数据，否则返回错误 2.休眠唤醒方式示例：软件调用open函数，不传入非阻塞参数O_NONBLOCK，如果驱动程序中有数据，则返回数据；否则驱动程序休眠，直到有数据唤醒。 3.pollselect方式在pollselect中传入超时参数，比如ret poll(fds, nfds, 5000);，则在有数据可读或者有空间可写时，返回数据；否则等到超时时间5s后，返回错误。pollselect可以检测多个文件，多个事件；pollselect的缺点： 4.异步通知方式暂时没写 多线程编程基本概念使用top命令查看系统占用的资源，查看线程数，查看进程数。线程：thread进程：process调度是以线程为单位的，即系统调度的最小单位是线程。进程是线程的集合，资源分配以进程为基本单位。 互斥量：mutex共享资源：在进程中出现的全局变量，线程都可以访问唯一标识：进程号：PID 线程号：TID,pthread_t类型编译时候需要指明库 gcc xxx.c -lpthread 常用函数 查看线程id：pthread_t pthread_self(void);返回值为pthread_t，一个长整型 创建线程：int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)重要参数解释： pthread_t *thread：如果成功创建线程，则返回线程标识符，保存在thread中 const pthread_attr_t *attr：线程属性（栈大小，优先级等），默认为NULL void *(*start_routine)(void *):c函数指针，声明了一个名为start_routine的函数指针，该函数指针具有以下特性： 函数接收一个参数，且参数为void * 函数返回一个void *指针 函数名为start_routine,start_routine可以被替换为任意字符 void *arg:传递给start_routine的参数，可以设置为NULL。一般情况下，需要指向arg指向一个全局堆变量 返回值：成功返回0，失败返回错误码 线程退出 start_routine函数执行return 线程调用prhread_exit(void retval)函数 pthread_exit 函数为线程退出函数，在退出时候可以传递一个 void类型的数据带给主线程，若选择不传出数据，可将参数填充为 NULL。函数原型为void pthread_exit(void *retval); 调用pthread_cancel(pthread_t thread)函数函数原型为：int pthread_cancel(pthread_t thread);传入一个tid，则会强制退出该tid对应的线程。成功返回0 需要注意：如果进程中任意线程调用exit(),_exit(),_Exit()函数，则进程退出，所有线程退出。 回收线程 int pthread_join(pthread_t thread, void **retval);阻塞状态，直到成功回收线程后才返回，第一个参数为要回收线程的 tid 号，第二个参数为线程回收后接受线程传出的数据。 int pthread_tryjoin_np(pthread_t thread, void **retval);非阻塞模式回收函数，通过返回值判断是否回收掉线程，成功回收则返回 0，其余参数与 pthread_join 一致 线程控制-互斥锁 互斥锁解决临界资源访问冲突问题。通过对临界资源加锁来保护资源只被单个线程操作，待操作结束后解锁，其余线程才可获得操作权。例如：对某个全局变量进行访问时，通过互斥锁保证同一时间只能被一个线程访问互斥锁实现的过程可以如下： 创建互斥锁函数原型为：int pthread_mutex_init(phtread_mutex_t *mutex,const pthread_mutexattr_t *restrict attr);其中：mutex (pthread_mutex_t *): 互斥量指针。指向未初始化的互斥锁对象的指针。成功初始化后，这个互斥锁可用于线程间的同步。 参数：attr (const pthread_mutexattr_t *restrict): 指向互斥锁属性对象的指针，该对象指定了互斥锁的特性。如果设为NULL，则使用默认属性。restrict关键字表明在函数执行期间，attr指针不与其他访问的内存别名，这允许编译器进行潜在的优化。返回值 0: 成功，表示互斥锁已成功初始化。errno (错误码): 失败时，返回一个错误编号以指示遇到的错误类型（例如，如果内存不足无法初始化互斥锁，则返回ENOMEM）。函数应在互斥锁首次使用前被调用.一旦初始化，线程可以使用如pthread_mutex_lock、pthread_mutex_trylock和pthread_mutex_unlock等函数来管理对共享资源的访问 加锁去锁(阻塞) 当某一个线程获得了执行权后，执行 lock 函数，一旦加锁成功后，其余线程遇到 lock 函数时候会发生阻塞，直至获取资源的线程执行 unlock 函数后。unlock 函数会唤醒其他正在等待互斥量的线程。 加锁函数原型为：int pthread_mutex_lock(pthread_mutex_t *mutex);成功后会返回 0 去锁函数原型为：int pthread_mutex_unlock(pthread_mutex_t *mutex); 特别注意的是，当获取 lock 之后，必须在逻辑处理结束后执行 unlock，否则会发生死锁现象！导致其余线程一直处于阻塞状态，无法执行下去。在使用互斥量的时候，尤其要注意使用 pthread_cancel 函数，防止发生死锁现象！ 加锁(非阻塞模式)函数原型：int pthread_mutex_trylock(pthread_mutex_t *mutex);该函数是非阻塞模式通过返回值来判断是否加锁成功，用法与上述阻塞加锁函数一致 销毁互斥量(非阻塞)函数原型：int pthread_mutex_destory(pthread_mutex_t *mutex);，传入互斥量的指针，就可以完成互斥量的销毁，成功返回 0。 线程控制-信号量互斥量：防止多个线程同时访问同一个临界资源冲突问题信号量：通知 创建信号量int sem_init(sem_t *sem,int pshared,unsigned int value); sem_t *sem：指向信号量结构体的指针，这个结构体需要在调用sem_init前由用户分配空间。函数会初始化这个信号量。 int pshared：指定信号量是否可以在进程间共享。 如果pshared为0，表示信号量仅在当前进程中有效，不能被其他进程访问。 如果pshared为非0值（通常为1），则信号量可以在多个进程间共享，要求sem位于共享内存中。 unsigned int value：初始化信号量的值，即信号量计数器的初始值。表示最初可以同时访问共享资源的线程或进程的数量。 信号量操作 int sem_wait(sem_t *sem);int sem_post(sem_t *sem);int sem_trywait(sem_t *sem); sem_wait:函数作用为检测指定信号量是否有资源可用，若无资源可用会阻塞等待，若有资源可用会自动的执行“sem-1”的操作。所谓的“sem-1”是与上述初始化函数中第三个参数值一致，成功执行会返回 0。 sem_post： 函数会释放指定信号量的资源，执行“sem+1”操作。 sem_trywait：非阻塞方式 信号量销毁int sem_destory(sem_t *sem); Linux串口数据成员ermios 函数族提供了一个常规的终端接口，用于控制非同步通信端口。 这个结构包含了至少下列成员： struct termios\tunsigned short c_iflag; /* 输入模式标志*/\tunsigned short c_oflag; /* 输出模式标志*/\tunsigned short c_cflag; /* 控制模式标志*/\tunsigned short c_lflag; /*区域模式标志或本地模式标志或局部模式*/\tunsigned char c_line; /*行控制line discipline */\tunsigned char c_cc[NCC]; /* 控制字符特性*/; 常用函数tc:terminao control cd control flag 函数名 描述 int tcgetattr(int fd, struct termios *termios_p); 获取终端属性 int tcsetattr(int fd, int optional_actions, const struct termios *termios_p); 设置终端属性 int tcflush(int fd, int queue_selector); 清除终端缓冲区 int tcflow(int fd, int action); 控制终端的输入输出流 int tcdrain(int fd); 等待输出缓冲区中的所有字符被发送 int tcsendbreak(int fd, int duration); 发送一个持续duration的BREAK信号 int cfsetospeed(struct termios *termios_p, speed_t speed); 设置输出波特率 int cfsetispeed(struct termios *termios_p, speed_t speed); 设置输入波特率 speed_t cfgetospeed(const struct termios *termios_p); 获取输出波特率 speed_t cfgetispeed(const struct termios *termios_p); 获取输入波特率 int cfsetspeed(struct termios *termios_p, speed_t speed); 设置波特率 驱动 准备工作编译驱动程序之前需要先编译内核，内核的配置文件在arch/arm/configs/目录下，内核编译过程为: make mrpropermake 100_ask_imx6ull_defconfigmake zImage -j4make dtbs 生成arch/arm/boot/zImage和arch/arm/boot/dts/100ask_imx6ull-14x14.dtb文件,将这两个文件复制到homebooknfs_rootfs目录下备用 cp arch/arm/boot/zImage ~/nfs_rootfscp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs 进入内核源码目录，编译内核模块 cd /home/book/100ask_imx6ull-sdk/Linux-4.9.88/make modules 安装内核模块到/home/book/nfs_rootfs make ARCH=arm INSTALL_MOD_PATH=/home/book/nfs_rootfs modules_install 安装内核和模块到开发板上，先执行挂在命令，再执行以下命令 cp /mnt/zImage /bootcp /mnt/100ask_imx6ull-14x14.dtb /bootcp /mnt/lib/modules /lib -rfdsync 完成以上配置驱动程序流程： 确定主设备号，也可以让内核分配 定义自己的file_operations结构体 实现对应的drv_opendrv_readdrv_wtire等函数，填入file_operations结构体 把file_operations结构体注册到内核中:register_chrdev(主设备号，设备名，file_operations结构体指针)? 入口函数：安装驱动程序时，就会调用此入口函数 出口函数：卸载驱动程序，出口函数调用unregister_chrdev(主设备号，设备名)? 提供设备信息，自动创建设备节点：class_create,device_create 重要的类class解释参考博客：Linux内核中的 struct class 简介代码中出现的 class 指的是 设备类（device classes），是对于设备的高级抽象。但 实际上 class 也是一个结构体，只不过 class 结构体在声明时是按照类的思想来组织其成员的。运用 class，可以让用户空间的程序根据自己要处理的事情来调用设备，而不是根据设备被接入到系统的方式或设备的工作原理来调用。 //include\\linux\\device.hstruct class const char *name; // 类名称 struct module *owner; // 类所属的模块，比如 usb模块、led模块等 struct class_attribute *class_attrs; // 类所添加的属性 const struct attribute_group **dev_groups; // 类所包含的设备所添加的属性 struct kobject *dev_kobj; // 用于标识 类所包含的设备属于块设备还是字符设备 int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); // 用于在设备发出 uevent 消息时添加环境变量 char *(*devnode)(struct device *dev, umode_t *mode); // 设备节点的相对路径名 void (*class_release)(struct class *class); // 类被释放时调用的函数 void (*dev_release)(struct device *dev); // 设备被释放时调用的函数 int (*suspend)(struct device *dev, pm_message_t state); // 设备休眠时调用的函数 int (*resume)(struct device *dev); // 设备被唤醒时调用的函数 const struct kobj_ns_type_operations *ns_type; const void *(*namespace)(struct device *dev); const struct dev_pm_ops *pm; // 用于电源管理的函数 struct subsys_private *p; // 指向 class_private 结构的指针; 重要的类file_operations结构体，参考博客：Linux 字符设备驱动结构（四）—— file_operations 结构体知识解析 //include\\linux\\fs.hstruct file_operations struct module *owner;//拥有该结构的模块的指针，一般为THIS_MODULES loff_t (*llseek) (struct file *, loff_t, int);//用来修改文件当前的读写位置 ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//从设备中同步读取数据 ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//向设备发送数据 ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);//初始化一个异步的读取操作 ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);//初始化一个异步的写入操作 int (*readdir) (struct file *, void *, filldir_t);//仅用于读取目录，对于设备文件，该字段为NULL unsigned int (*poll) (struct file *, struct poll_table_struct *); //轮询函数，判断目前是否可以进行非阻塞的读写或写入 int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); //执行设备I/O控制命令 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); //不使用BLK文件系统，将使用此种函数指针代替ioctl long (*compat_ioctl) (struct file *, unsigned int, unsigned long); //在64位系统上，32位的ioctl调用将使用此函数指针代替 int (*mmap) (struct file *, struct vm_area_struct *); //用于请求将设备内存映射到进程地址空间 int (*open) (struct inode *, struct file *); //打开 int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); //关闭 int (*fsync) (struct file *, struct dentry *, int datasync); //刷新待处理的数据 int (*aio_fsync) (struct kiocb *, int datasync); //异步刷新待处理的数据 int (*fasync) (int, struct file *, int); //通知设备FASYNC标志发生变化 int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **); ; 常用函数 函数名 描述 unsigned long copy_to_user(void *to, const void *from, unsigned long n); 这个函数的作用是将内核空间的数据复制到用户空间 to：目标地址（用户空间） from：源地址（内核空间） n：将要拷贝数据的字节数 返回：成功返回0，失败返回没有拷贝成功的数据字节数 unsigned long copy_from_user(void *to, const void *from, unsigned long n); 这个函数的作用是将用户空间的数据复制到内核空间 to：目标地址（内核空间）from：源地址（用户空间）n：将要拷贝数据的字节数返回：成功返回0，失败返回没有拷贝成功的数据字节数 led驱动static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)","tags":["嵌入式","linux","imx6ull"],"categories":["LINUX"]},{"title":"ros常用命令","path":"/2024/09/18/ros常用命令/","content":"ROS文件系统 WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 package.xml该文件定义有关软件包的属性，例如软件包名称，版本号，作者，维护者以及对其他catkin软件包的依赖性。请注意，该概念类似于旧版 rosbuild 构建系统中使用的manifest.xml文件。 CMakeLists.txt文件CMakeLists.txt是CMake构建系统的输入，用于构建软件包。任何兼容CMake的软件包都包含一个或多个CMakeLists.txt文件，这些文件描述了如何构建代码以及将代码安装到何处。 ros文件系统相关命令 增 删 改 查 启停 ros常用命令参考网址：ros命令 rosnode ：操作节点 rostopic ：操作话题 rosservicea : 操作服务 rosmsg : 操作msg消息 rossrv : 操作srv服务 rosparam : 操作参数 新生成一个乌龟 rosservice call /spawn x: 0.0y: 0.0theta: 0.0name: 常用API","tags":["ros","笔记"],"categories":["ROS"]},{"title":"环形缓冲区","path":"/2024/09/18/环形缓冲区/","content":"环形缓冲区 位置： 起始位置 缓冲区长度 读位置 写位置 状态： 空 满 非空非满","tags":["嵌入式","linux","环形缓冲区"],"categories":["LINUX"]},{"title":"fileZilla连接虚拟机，同样适用MobaXterm","path":"/2024/09/15/fileZilla连接虚拟机/","content":"fileZilla连接虚拟机，同样适用MobaXterm主要分为fileZilla设置和虚拟机设置，虚拟机主要是设置ip地址和用户名 一图查看 虚拟机设置 设置网络适配器为NAT模式(不知道是不是必须NAT，因为现在使用的是NAT模式) 使用ifconfig查看ip 使用whoami查看用户名，得到用户名book 注意这里不是：hostname,也不是管理员权限下的whoami 在设置中查看Detail-About也不对 至此，就完成了虚拟机相关的设置，主要是注意使用用户名 book用于登录到远程服务器，不是root，也不是主机名100ask FileZilla设置 按照虚拟机设置，依次设置即可 主机：即ifconfig查看的远程主机的ip地址 用户名：即book 密码：即乌班图开机密码 端口：默认22 MobaXterm连接虚拟机MobaXterm和fileZilla设置如出一辙，按照下图设置即可： Remote host ：即NAT网卡ip地址 username :即whoami用户名 port : 默认值22即可 需要注意的是MobaXterm也可以使用桥接网卡的ip但是我没有测试，原理应该是一样的","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"解决unbuntu 20.04 主机没有声音的问题","path":"/2024/09/15/ubuntu没有声音/","content":"解决ubuntu 20.04 主机没有声音的问题安装pavucontrol：输入安装命令：sudo apt install pavucontrol 终端启动：pavucontrol配置： 配置-HDA NVidia 选项关 配置-内置音频 选择模拟立体声输出 输出设备-内置音频 模拟立体声-模拟耳机备注：只能插在主机上，插在显示器上还是没有声音","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"解决ubuntu 20.04 GRUB启动项顺序的问题","path":"/2024/09/15/ubuntu+GRUB启动项/","content":"解决ubuntu 20.04 GRUB启动项顺序的问题命令： 输入命令：sudo gedit etcdefaultgrub 更改配置： GRUB_DEFAULT=2//指定默认启动的菜单项。数字 2 表示启动菜单中的第 三 个条目（索引从 0 开始）。 //注意：此处设置需要根据启动菜单的显示顺序来确定。GRUB_TIMEOUT_STYLE=hidden//设置 GRUB 菜单的显示样式。hidden 表示在超时之前不显示菜单，除非用户按下某个键。menu显示 GRUB 菜单。countdown：显示倒计时。GRUB_TIMEOUT=10//设置 GRUB 菜单的超时时间（以秒为单位）。在 10 秒后，GRUB 将自动启动默认的菜单项。GRUB_DISTRIBUTOR=`lsb_release -i -s 2 /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=quiet splashGRUB_CMDLINE_LINUX= 执行命令：sudo update-grub 重启","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"ubuntu搭建开发环境以及开发板ubuntu互ping","path":"/2024/09/15/ubuntu搭建开发环境以及开发板ubuntu互ping/","content":"ubuntu搭建开发环境以及开发板ubuntu互ping在ubuntu下配置IMX6ULL的配置环境 目标：实现ubuntu与开发板互ping 1.开发板设置静态IP 临时设置 ifconfig eth0** **192.168.5.9 修改配置文件永久设置 vi /etc/network/interfaces 使用vi编辑器将interfaces里内容修改为： auto loiface lo inet loopbackauto eth0iface eth0 inet static\taddress 192.168.5.9\tnetmask 255.255.255.0\tgateway 192.168.5.1 vi切换为命令行模式，使用wq强制保存并退出，再执行/etc/init.d/S40network restart重启网络服务 使用ifconfig查看ip，在eth0中出现设置的192.168.5.9便说明成功了。eth1是连接外网的，此时不用管 2. 设置虚拟机打开虚拟机–可移动设备 可以看到有以下两个移动设备： Qingfeng USB Single Serial Realtek USB 10100 LAN 分别是串口和网卡，这里都需要连接到Ubuntu上，确保这两个连接的都是虚拟机而不是主机。 2.1 NAT网卡Ubuntu通过NAT网卡上网，我们提供的Ubuntu默认已经支持了NAT网卡。 打开虚拟机时，点击”编辑虚拟机”，确保网卡是NAT网卡： 注意这里是：这里是在ubuntu下进行嵌入式开发，不涉及到windows，因此只需要一个网络适配器，并且设置为NAT模式即可，另一个网络适配器2是不需要的 2.2 USB网卡2.1 连接网卡在日常开发中，开发板和Ubuntu之间通过网络传输数据： 2 设置静态IP在Ubuntu中设置USB网卡的IP位静态IP 设置-网络-USB Ethernet,点击小齿轮 选择手动分配，即Manual，设置为： Address 192.168.5.11 Netmask 255.255.255.0 Gateway 192.168.5.1 3. 验证以上2个步骤全部做完就可以互ping了 在开发板pingUbuntu： ping 192.168.5.11 在Ubuntu上ping开发板： ping 192.168.5.19 因为是纯untuntu下配置，没有使用到windows因此不需要ping windows，如果设置了网络适配器2，理论上可以ping通windows","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"区间和--前缀和数组","path":"/2024/09/03/leetcode刷题/每日一刷day4/","content":"区间和题目：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。 解法-通过前缀和数组思路：由于暴力求解时间复杂度较大，因此采用前缀和的方法 引入前缀和数组：presum[i]表示前i个元素的和 如果要计算的区间为[begin,end]，则计算presum[end]-presum[begin-1] 这里的begin 和 end 都是从0开始 复杂度： 时间复杂度： 空间复杂度： 代码： int solution(vectorintnums,int begin,int end) int sum = 0; int result = 0; vectorint presum(nums.size(),0); for (int i = 0; i nums.size(); i++) sum += nums[i]; presum[i]=sum; coutpresum[i] = presum[i]endl; result = presum[end]-presum[begin-1]; return result;","tags":["c++","前缀和"],"categories":["C++刷题笔记"]},{"title":"平方新数组","path":"/2024/09/02/leetcode刷题/每日一刷day3/","content":"平方组成的新数组题目：给你一个按非递减顺序排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。示例 1：输入：nums [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]示例 2：输入：nums [-7,-3,2,3,11]输出：[4,9,9,49,121] 解法1思路：每个数平方之后，排个序 过于简单 复杂度： 时间复杂度：O(n+nlogn) 空间复杂度： 代码： std::vectorint test::solution(std::vectorint nums) std::vectorint result(nums.size()); for (int i = 0; i nums.size(); i++) result[i] = nums[i]*nums[i]; sort(result.begin(),result.end()); return result; 解法2–双指针法思路：本来就是有序的数组，由于负数平方之后可能会改变数组的顺序，所以重点关注负数数组平方的最大值出现在数组的两端，左或者右，不可能是中间。所以可以考虑双指针法，left和right 定义新数组，用来存储结果，注意初始化大小，否则容易出现溢出错误 判断nums[left]*nums[left]和nums[right]*nums[right]大小，以便赋值给result[i] 如果nums[left]*nums[left] nums[right]*nums[right] 那么 result[i] = nums[left]*nums[left] 如果nums[left]*nums[left] nums[right]*nums[right] 那么 result[i] = nums[right]*nums[right] 初始值i = nums.size()-1,方便从后往前填充 复杂度： 时间复杂度：o(n) 空间复杂度： 代码： std::vectorint test::solution(std::vectorint nums) std::vectorint result(nums.size()); int left = 0,right = nums.size()-1; //从后往前填充 //i=0 for(int i = nums.size()-1;i=0;i--) if(nums[left]*nums[left] nums[right]*nums[right]) result[i] = nums[left]*nums[left]; left++; else result[i] = nums[right]*nums[right]; right--; return result;","tags":["c++","平方新数组"],"categories":["C++刷题笔记"]},{"title":"matlab非线性方程求解fsolve","path":"/2024/09/01/matlab非线性方程求解fsolve/","content":"matlab非线性方程求解fsolve懒得上传图片了…以后也不不一定用得到这个fsolve - 对非线性方程组求解 - MATLAB - MathWorks 中国 匿名函数f=@(x)acos(x)，f为函数句柄，@是定义句柄的运算符。f=@(x)acos(x)相当于建立了一个函数文件，%f.m function y=f(x) y=acos(x) 此示例返回迭代输出，展示了一个包含两个方程和两个未知数的方程组的求解过程 以 F(x)0 形式重写方程： 从 x0 = [-5 -5] 开始搜索解。 首先，编写一个函数用来计算 F（方程在 x 处的值）。 F = @(x) [2*x(1) - x(2) - exp(-x(1)); -x(1) + 2*x(2) - exp(-x(2))]; 这个匿名函数接受一个向量x作为输入参数。向量x在这里被假定为包含两个元素，分别用x(1)和x(2)表示。 匿名函数返回一个包含两个元素的向量。向量中的第一个元素是表达式2*x(1) - x(2) - exp(-x(1))的值，其中exp(-x(1))表示自然指数函数e的-x(1)次方。 向量中的第二个元素是表达式-x(1) + 2*x(2) - exp(-x(2))的值，同样exp(-x(2))表示自然指数函数e的-x(2)次方。 这个匿名函数通常可能用于求解方程组或者在其他数值计算方法中作为一个函数表达式来使用。例如，可以使用数值求解器（如fsolve等）来找到使得这个函数返回值为零的向量x的值，从而求解一个非线性方程组。 创建初始点 x0。 x0 = [-5;-5]; 设置选项以返回迭代输出。 options = optimoptions(fsolve,Display,iter); 求解方程。 [x,fval] = fsolve(F,x0,options)","tags":["c++","matlab"],"categories":["C++笔记"]},{"title":"移除元素","path":"/2024/08/20/leetcode刷题/每日一刷day2/","content":"移除元素题目：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1: 给定 nums [3,2,2,3], val 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums [0,1,2,2,3,0,4,2], val 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。你不需要考虑数组中超出新长度后面的元素。 解法1思路： 两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组 复杂度： 时间复杂度：O(n^2) 空间复杂度： 代码： // 时间复杂度：O(n^2)// 空间复杂度：O(1)class Solution public: int removeElement(vectorint nums, int val) int size = nums.size(); for (int i = 0; i size; i++) if (nums[i] == val) // 发现需要移除的元素，就将数组集体向前移动一位 for (int j = i + 1; j size; j++) nums[j - 1] = nums[j]; i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位 size--; // 此时数组的大小-1 return size; ; 解法2–双指针法思路：双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class pdeleteArrayprivate: /* data */public: pdeleteArray(/* args */); ~pdeleteArray(); int solution(std::vectorintnums,int val) int slow = 0; for (int fast = 0; fast nums.size(); fast++) if (nums[fast] != val) nums[slow] = nums[fast]; slow++; return slow; ;","tags":["c++","移除元素"],"categories":["C++刷题笔记"]},{"title":"二分查找","path":"/2024/08/20/leetcode刷题/每日一刷day1/","content":"二分查找题目：给定一个整型有序数组nums和一个目标之target,写一个搜索函数搜索target,如果存在则返回target在数组中的下下标，如果target不存在，返回-1。 代码思路： 采取闭区间[left,right]写法 while (left right) 要使用 ，因为left right是有意义的，所以使用 if (nums[middle] target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 复杂度： 时间复杂度：O(log n) 空间复杂度：O(1) int search::solution(vectorintnums,int target) int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left = right) // 当left==right，区间[left, right]依然有效，所以用 = int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] target) right = middle - 1; // target 在左区间，所以[left, middle - 1] else if (nums[middle] target) left = middle + 1; // target 在右区间，所以[middle + 1, right] else // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 // 未找到目标值 return -1;","tags":["c++","刷题day1"],"categories":["C++刷题笔记"]},{"title":"短横杠-的含义","path":"/2024/07/20/短横杠-的含义/","content":"短横杠-的含义猛地看到it - vec.begin()竟看不懂这是什么，还以为是和.或者-一样新的运算符。故而总结： 减法运算符 取负运算符 指针加减运算符可以计算两个指针之间的距离int arr[] = 1, 2, 3, 4, 5; int *ptr1 = arr[0]; int *ptr2 = arr[2]; int distance = ptr2 - ptr1; // 结果为 2 迭代器之间的差值std::vectorint vec = 1, 2, 3, 4, 5;auto it1 = vec.begin();auto it2 = vec.begin() + 2;int distance = it2 - it1; // 结果为 2 类似于指针的距离，因为vec.begin()可以认为是一个指针，指向第0元素的位置，即*vec.begin()1.vec.end()指向第5个元素的位置，即*(vec.end()-1)6 可以重载自定义","tags":["c++"],"categories":["C++笔记"]},{"title":"虚函数","path":"/2024/07/20/虚函数/","content":"虚函数 虚函数是在基类中声明的成员函数，前面加上virtual关键字 允许在派生类中重写这个函数，并且可以通过基类指针或者引用调用时，自动选择正确的函数版本如果在派生类中不打算重写基类的虚函数，可以在声明时使用final防止重写用处： 需要通过继承来扩展功能并保持代码的可维护性和灵活性 纯虚函数 是一种特殊的虚函数 在基类中声明，但是没有实现 纯虚函数使用0来声明，表示该函数必须在派生类中被重写 抽象类： 包含纯虚函数的类叫做抽象类 抽象类不能实例化对象，只能作为其他类的基类举例： //定义抽象类Baseclass Base public: vitrual int doSomething() = 0;//纯虚函数，为抽象类;class Derived: public Base public: int doSomething()override/*具体实现*/return 0;;int main() Base* pbase = new Base();//错误 Base* pderived = new Derived();//正确 举例class Shape public: virtual double area() const = 0; // 纯虚函数;class Circle : public Shape public: double radius; Circle(double r) : radius(r) double area() const override return 3.14 * radius * radius; ;class Rectangle : public Shape public: double width, height; Rectangle(double w, double h) : width(w), height(h) double area() const override return width * height; ;int main() Shape* shapes[] = new Circle(5), new Rectangle(4, 6); for (auto shape : shapes) std::cout Area: shape-area() std::endl; for (auto shape : shapes) delete shape; // 释放内存 return 0;","tags":["c++"],"categories":["C++笔记"]},{"title":"车类残局定式","path":"/2024/05/20/ChessLearning/","content":"实用残局术语车类单车必胜士相不全单车例胜单缺士总体思路：车要在双相的对立侧，可以利用帅破掉单士，形成单车例胜双相的局面 单车例胜双相总体思路：帅回中，车分边，入底，抢将位，高捉相 破相定式 黑方双相不能相连，这种局面比较少见 利用帅在中，将军后底相被吃 利用将军上帅堵住相眼，从而破相，此局面不要求帅在中 借助帅力，从而破相 抢占将位（底中线）只要能够抢占住底中线，通过高捉相（占中之后，高捉相之前有可能会等一着），黑方三步以内必丢相，如何抢占底中线，大致有以下两种思路。 第一种比较简单。如果将不在中线，即可进底将军，然后平中占住中线 如果将在中线，可以先占住底线（可能顺势将军），再捉相，迫使将离开将位，然后车占将位至此，高捉相即可取胜 单车例胜马双士单车例和马单缺士兵类单兵难胜单士黑方求和手段关键在于将占住一条线如果黑将没有占住一条线，红方形成左帅右兵的图形，则红胜。红方的思路：帅占住一条线一兵胜孤将，底兵不胜，黑有士难胜。 高兵单士巧胜单士如果黑将率先占据肋道，则和棋。所以红方的思路是利用自己的士顺利将帅移到对侧，从而形成左兵右帅的局面，方可取胜 高兵单相巧胜单士思路与高兵单士巧胜单士一样，黑方将占住一条线，红方利用相将帅移到对侧，形成左兵右帅的局面，方可取胜 高兵巧合炮单士高兵尽量靠近黑将，不让黑方撑起士，黑方没有炮架则和棋 高低兵例胜双士高低兵可以稳胜双士。高兵不要盲目急进，应待机而动。 高底兵例胜双士主帅助攻，以牵制黑将，底兵亦能建功 双低兵例和双士","tags":["chess","车类残局","残局定式"],"categories":["CHESS"]},{"title":"const和指针","path":"/2023/09/20/const和指针/","content":"const和指针const位于数据类型的前面根据有无const应用于变量和指针，两两组合可以有4种情况，分别： 常规变量的地址赋值给常规指针 常规变量的地址赋值给指向const的指针 const变量的地址赋值给指向const的指针 const变量的地址赋值给常规指针（不被允许） 常规变量的地址赋值给常规指针最常用的一种形式，没有const作用 常规变量的地址赋值给指向const的指针 int age =39;const int* pt = age; 上述声明指出，pt指向一个const int类型的值(age39)，*pt的值为const，不能修改，即不能使用pt来修改age。 *pt += 1;//invalid,因为pt指向一个const int 但是pt的声明并不意味着pt指向的值是一个常量，只是意味着对于pt来说这个值是常量。例如，pt指向age,而age并不是const,因此可以直接通过age变量来修改age的值，然而却不能使用pt指针来修改age. *pt = 20;//invalid,因为pt指向一个const intage = 20;//valid,因为age并不是const 多说一点：上述声明中，const只能防止修改pt指向的值（正如上述演示的一样），而不能防止修改pt本身的值，也就是说可以讲一个新地址赋值给pt int sage = 80;pt = sage;//invalid 但是仍然不能通过pt来修改他新指向的值（即sage的值80）。 这就好像是pt通过媒人age 爱上了39这个数。pt以为39是恒定不变的，却不知道媒人age可以让39变成任何数。对pt来说，很明显39对自己不感兴趣，既然改变不了39,那就改变自己。于是他又通过新媒人sage，介绍了个新对象80，可是pt仍然以为80是恒定不变的，殊不知sage可以让80变成任何数。 const变量的地址赋值给指向const的指针 const float g_earth = 9.80;const float* pe = g_earth; 上述声明，g_earth是一个const float类型的变量，pe是指向const float的，因此不能使用pe修改这个值，也不能使用g_eatth修改这个值 const变量的地址赋值给常规指针（不被允许）注意：这是不被允许的，下面给出一个解释 const float g_earth = 9.80;float* pe = g_earth;//invalid 如果可以通过pe的值修改g_earth的话，那么之前把g_earth声明为const float则显得没必要了，因此c++禁止这种做法 const位于数据类型的后面与上述不同的是，关键字const的位置位于数据类型的后面，而且看着比较别扭 例子1 int sloth = 3;const int* ps = sloth;//ps 指向 const intint* const finger = sloth;//const figer 指向 int 上述声明中，figer只能指向sloth,但是允许使用finger来修改sloth的值。不允许ps修改sloth的值，但是允许ps指向另一个位置。 简而言之：finger和*ps 为const,而*figer和ps不是.细细体会！ 例子2–声明指向const对象的const指针 double troble = 2.00;const double* const stick = troble; 上述声名中，stick不能修改trouble的值，且stick只能指向troule。前者由前一个const作用，后者由后一个const作用 通过const将指针与引用联系起来引用更接近与const指针，一旦与某个变量关联起来，就一直效忠于它 例子 int rats;int rodents = rats;int* const pr rats; 实际上上面代码是下面的伪装，引用rodents扮演的角色和*pr相同","tags":["c++","const","指针"],"categories":["C++"]},{"title":"C++函数形参为引用类型时，传入的参数类型为什么用引用对象的类型和引用类型都可以？","path":"/2023/05/20/C++函数形参为引用类型时，传入的参数类型为什么用引用对象的类型和引用类型都可以？/","content":"C++函数形参为引用类型时，传入的参数类型为什么用引用对象的类型和引用类型都可以？代码如下： void refer1(int );void refer2(int *);int main()\tint a = 5;\tint b = a;\tint *c = a;\trefer1(a);\trefer1(b);\treturn 0; 这里的refer1的形参是一个int类型的引用，但是我传a(int类型)进去可以，我传b(int引用类型)进去也可以，对比refer2的形参，要求传int指针类型，也就是可以传c进去，如果我传a(c指向的类型)进去则报错。 按照常理说应该是类型匹配才对，int 匹配传进来的int，int *匹配传进来的int *,为什么形参是引用int ，既可以是int 又可以是int呢？如果说形参是引用int ，传 int 进去是为了绑定到实参上，那传一个已经绑定的int 进去是绑定什么呢？ 解答：使用指针或者引用作为形参是为了解决按值传递可能导致的问题。 所以这里再次讲一下使用指针，引用和值作为形参所导致的结果。 C++教科书都会用一个交换两个变量的值的函数来举例： void swap(int a, int b); //使用指针和引用的情况下形参类型分别为int*和int int temp; //使用指针为形参的情况下需要将以下的a和b分别替换为*a和*b temp = a; a = b; b = temp; 结果是怎么样的题主应该清楚：按值传递无法完成这一行为，而传递指针或者引用是可行的。 那么原因是什么？ 在按值传递的情况下： int x = 4, y = 5;swap(x, y);//...........................main函数其它部分..........................void swap(int a, int b) int temp; temp = a; a = b; b = temp; 第一步：编译器会在内存开辟两个能存放int型变量的区域（假设分别为0xAAAAAAAA和0xBBBBBBBB），用于保存x和y的值。第二步：swap函数接收x和y的值，编译器会另外开辟两个存放int型变量的区域（假设分别为0xCCCCCCCC和0xDDDDDDDD），将4和5分别赋给形参a和b。第三步：swap函数完成交换，此时形参a5, b4，但是实参x和y的值并没有发生变化。因为swap函数只交换了0xCCCCCCCC和0xDDDDDDDD两块区域储存的值，并没有影响到0xAAAAAAAA和0xBBBBBBBB。所以x和y本身没有受到swap函数的影响，交换失败。 形参为指针的情况下： int x = 4, y = 5;int *px = x, *py = y;swap(px, py);//...........................main函数其它部分..........................void swap(int* a, int* b) int temp; temp = *a; *a = *b; *b = temp; 第一步：编译器会在内存开辟两个能存放int型变量的区域（假设分别为0xAAAAAAAA和0xBBBBBBBB），用于保存x和y的值。 第二步：编译器会在内存开辟两个能存放int型指针的区域（假设分别为0xCCCCCCCC和0xDDDDDDDD），两块区域分别存储x和y的地址（即0xAAAAAAAA和0xBBBBBBBB） 第三步：swap函数接收px和py的值，编译器会另外开辟两个存放int型指针的区域（假设分别为0xEEEEEEEE和0xFFFFFFFF），将0xAAAAAAAA和0xBBBBBBBB分别赋给形参a和b。 第四步：swap函数创造一个int型变量temp，假设地址为0xGGGGGGGG。 -—————————————————————————————————————————————– 第五步： temp = *a; *a的值就是x的值（即4），temp获得4这个值。 -—————————————————————————————————————————————– 第六步： *a = *b; 形参a的值是0xAAAAAAAA，所以这一句将0xAAAAAAAA这一块内存所存储的值由4修改为5，而0xAAAAAAAA正是x的地址。也就是说x本身的值被改成了5。 -—————————————————————————————————————————————– 第七步： *b = temp; 同理，形参b的值是0xBBBBBBBB，这一句将0xBBBBBBBB这一块内存所存储的值由5修改为4，而0xBBBBBBBB正是y的地址。也就是说y本身的值被改成了4。 swap函数执行完毕后x和y的值分别为5和4，交换成功。 在这种情况下，如果传入两个int型变量而不是int型指针，则编译不会通过。因为int型变量并不是地址，在a为int型变量的情况下，a并不是符号的合法用途。 -—————————————————————————————————————————————– 形参为引用的情况下： int x = 4, y = 5;swap(x, y);//...........................main函数其它部分..........................void swap(int a, int b) int temp; temp = a; a = b; b = temp; 第一步：编译器会在内存开辟两个能存放int型变量的区域（假设分别为0xAAAAAAAA和0xBBBBBBBB），用于保存x和y的值。 第二步：两个int型参数传入swap函数，函数将形参a和b分别声明为x和y的引用。此时a的地址和x一样是0xAAAAAAAA，b的地址和y一样是0xBBBBBBBB。 第三步：此时swap函数交换a和b的值，由于a和b的地址分别与x和y的地址相同（即0xAAAAAAAA和0xBBBBBBBB），该函数完成了对x和y的值的交换。交换后0xAAAAAAAA存储的值为5，0xBBBBBBBB存储的值为4。 当形参类型为引用时，实参和形参共享一个地址，对形参的修改也就是对实参的修改。 可以看到，使用指针和引用分别实现交换变量值的机制是不同的。尽管两种方法都直接对x和y的地址储存的值进行了修改，但是当形参是指针时，a和b的值并未发生变化（依然分别是x和y的地址）；而当形参是引用时，a和b的值发生了变化。 -—————————————————————————————————————————————– 最后回到问题本身： 为什么形参是引用int ，既可以是int 又可以是int呢？ 举个例子： #include iostreamusing namespace std;int main() int a = 1, b = 2; //声明并初始化两个int型变量 int *pa = a, *pb = b; //pa和pb分别为指向a和b的int型指针 int ra = a, rb = b; //ra和rb分别为指向a和b的int型引用 cout a*b= a*b endl; //合法，输出为2 cout pa*pb= pa*pb endl; //非法，编译报错 cout ra*rb= ra*rb endl; //合法，输出同样为2 return 0; 在这个例子中，rarb的结果和ab完全一致，尽管ra和rb是指向int型变量的引用，但是ra和rb在被声明为引用以后也可以被当作int型变量进行处理。而pa和pb是指向int型变量的指针，它们存储的是a和b的地址而不是a和b的值，所以对pa和pb进行int型变量的运算是非法的。 -—————————————————————————————————————————————– 如果说形参是引用int ，传int进去是为了绑定到实参上，那传一个已经绑定的int 进去是绑定什么呢？ 修改一下上面的例子： #include iostreamusing namespace std;int main() int a = 1, b = 2; //声明并初始化两个int型变量 int ra = a, rb = b; //ra和rb分别为指向a和b的int型引用 int rra = ra, rrb = rb; //rra和rrb分别为指向ra和rb的int型引用 cout a*b= a*b endl; //合法，输出为2 cout ra*rb= ra*rb endl; //合法，输出同样为2 cout rra*rrb= rra*rrb endl; //合法，输出依然为2 return 0; 在这个例子中，rra为指向【指向int型变量的引用】的引用，国内的C++教科书在讲到引用也会提一下指向引用的引用是合法的。在这种情况下，ra被引用是会被当作普通的int型变量处理。 当一个int参数传入swap函数的时候，同样地，该int参数会被当作一个int型变量，然后形参就是这个变量的引用。所以在这种情况下传入int或int的输出都是一样的。","tags":["c++","引用"],"categories":["C++笔记"]},{"title":"c++primer第十章练习题","path":"/2023/05/20/c++primer第十章练习题/","content":"什么是类 类是用户定义的一新的种数据类型，它包括数据的表示和操作数据的方法（接口函数）。 类如何实现抽象，封装和数据隐藏？ 抽象： 封装：只需要知道类里边的成员函数怎么用行了，并不需要知道其实现的细节。 数据隐藏：类定义包括私有部分（private）和公共部分（public）。只能通过类的成员函数才能访问类中的数据，叫做数据隐藏。 对象和类之间的关系是什么？ 类和对象的关系就好比于数据类型和变量的关系，比如Int i。int类比于类，i类比于对象。 类是抽象的，对象也可以看作是类的实例化。 除了是函数之外，类函数成员和类数据成员之间的区别是什么？ 每个对象都有属于自己的数据成员，但是所有的对象共享一组成员函数。数据成员一般私有，函数成员一般共有。通过共有的成员函数访问私有的数据成员。 未完….","tags":["c++"],"categories":["C++笔记"]},{"title":"ofstrem和istream的区别","path":"/2023/05/20/ofstrem和istream的区别/","content":"ofstrem和istream的区别ofstrem和istream的区别 ofstream文件写操作，是从内存到硬盘 ios::out 写文件 ifstream文件读操作，是从硬盘到内存 ios::in 读文件 fstream读写操作，对打开的文件进行读写操作 如果想要以输入方式打开，就用Ifstream 如果想要以输出方式打开，就用ofstream 如果想以输入输出方式打开，就用fstream 泛型编程STL函数模板 类模板 For循环内部定义的变量，每次循环都被重新定义 函数需要传入的参数是 引用 ，调用函数时传入地址（a）或者传入指针变量都会报错。只能传入变量本身的名字 函数需要传入的参数是 指针 ，调用函数时传入地址（a）或者传入指针变量都是正确的。 当形参类型为引用时，实参和形参共享一个地址，对形参的修改也就是对实参的修改。 void test01(int n)\tn = 10;void test02(int *pn)\t*pn = 10;int main()\tint a = 100;\tint b = 1000;\tint* pa = b;\ttest01(a); //test01(pa);//无法将参数从int *转换为 int //test01(a);//无法将参数从int *转换为 int test02(pa);\ttest02(a);\treturn 0; 当一个int参数传入swap函数的时候，同样地，该int参数会被当作一个int型变量，然后形参就是这个变量的引用。所以在这种情况下传入int或int的输出都是一样的 不要将函数定义（内联函数除外）或者变量申明放在头文件中，否则头文件包含一个函数定义，然后在其他两个文件中包含该头文件，同一个程序中将包含同一个函数的两个定义，将会出错。 将结构放在头文件中是可以的。因为它们不创建的对象，知识在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量 int main()\tint a = 10;//作用域为整个main()函数 int b = 10;//作用域为内部 cout b endl;//正确 cout a endl;\t//cout b endl;//未定义\tint b = 100;//正确，上一个int b的作用域只在上一个代码块中，可以再定义一个b\treturn 0;","tags":["c++","stl"],"categories":["C++笔记"]},{"title":"引用","path":"/2023/05/20/引用/","content":"引用前面加上const 时，当类型不匹配时，会产生临时变量const 成员函数：在函数后边加上const,说明函数调用不会修改对象，一般要遵守这个规则，另外只有成员函数才可以用const，一般的函数不可以这样写this指针永远指向调用成员函数的对象举例 Stock1.top_val(stock2)，this 指向stock1对象的地址 直接成员运算符.间接成员运算符-作用域解析运算符：：类作用域 class scope限定名 qualified name 在类的声明中 不能直接const int a0;声明常量，因为他不会创建这个内存可以使用枚举或者加上static 静态的成员变量的特点 所有对象共享同一数据 编译阶段就分配内存 类内声明 类外初始化静态成员函数 只能访问静态数据 多态的使用条件父类指针或者引用指向子类对象一个接口多个状态 一级指针存放普通变量的地址二级指针存放一级指针的地址int main(void){\tint a10;\tint *p\tint **pp\tprintf(“%d,%d,%d ”,p,p,*p);\tprintf(“%d,%d,%d,%d”,pp,pp,*pp,**pp);\treturn 0;}","tags":["c++","引用"],"categories":["C++笔记"]},{"title":"myblogtemplate","path":"/2023/01/01/myblogtemplate/","content":"我是摘要… xxx题目：解法-思路： 1. 2. 3. 复杂度： 时间复杂度： 空间复杂度： 代码： 语法小计 该题没有语法小计 *","tags":["c++","xxx"],"categories":["C++刷题笔记"]},{"title":"友链","path":"/friends/index.html","content":"倪鹏飞xaoxuuBilibiliabcde 交换友链欢迎留言或来信添加友链，请按以下格式提供信息： 站点名称：又是摸鱼的一天 站点地址：https://dkyou.github.io/ 头像地址：https://cdn.jsdelivr.net/gh/……/avatar.png 简介：今天又是摸鱼的一天！可不摸鱼又干什么呢？ 也可以直接发 PR 到我的 source/_data/friends.yml。"},{"title":"About Me","path":"/about/index.html","content":"嗨，我是摸鱼大王 👋☕ 关于我 🔭 正在研究：语言服务、应急语言体系、RAG 检索增强、机器人控制 🌱 最近在学习：MoveIt 规划、ROS 遥操作 🧩 兴趣领域：LINUX 驱动开发 AI 语言服务 机器人 教育科技 🗺 梦想①：自己“实现”一台计算机，从零开始写 CPU、操作系统、编译器… 🎯 梦想②：在摸鱼中成为全栈学者 🧠 🎯 梦想③：躺平… 🏷 我的标签 以下是我在不同坑位的折腾记录 👇（点击即前往分类） 🤖 Linux 🌐 驱动开发 📊 刷题笔记 ☁️ 旅行杂记 💻 前端开发 🏠 搭建博客 PS：博客功能还待完善… 💼 工作 学习经历 🎓 USTB (2023.09 – 2026.07) 工作岗位：滥竽充数 工作内容：摆烂 工作技能：Ctrl + C → Ctrl + V 联系我 GitHub：dkyou 邮箱：dkyou@163.com有可能联系不到😎 Your browser does not support the video tag."},{"title":"explore","path":"/explore/index.html","content":".x-cards{ display:grid; grid-template-columns:repeat(auto-fill,minmax(240px,1fr)); gap:18px; margin:1rem 0 2rem; grid-auto-flow: row; /* 关键：只按行排布 */ grid-auto-rows: 1fr; /* 每一行的自动高度一致 */ } .x-card { display:flex; align-items:center; gap:12px; padding:14px 18px; border-radius:16px; text-decoration:none; position:relative; box-shadow:0 4px 14px rgba(0,0,0,.06); transition:transform .2s ease, box-shadow .2s ease, filter .2s ease; min-height:72px; /* 统一高度感 */ border:1px solid transparent; /* 渐变版会覆写，纯色版可自定义 */ /* height:100%; /* 让卡片充满该行高度 */ transition:transform .2s, box-shadow .2s, filter .2s; box-shadow:0 4px 14px rgba(0,0,0,.06); */ } .x-card:focus-visible { outline: 2px solid var(--theme, hsl(192 98% 55%)); outline-offset: 2px; } .x-card:hover { transform: translateY(-4px); box-shadow:0 10px 24px rgba(0,0,0,.12); filter:saturate(1.05); } /* 触屏优化：不做上移，做轻微缩放 */ @media (hover:none) { .x-card:hover { transform:none; box-shadow:0 6px 16px rgba(0,0,0,.1); } .x-card:active { transform:scale(.98); } } .x-card .x-icon { width:32px; height:32px; border-radius:9px; flex:0 0 32px; object-fit:cover; } .x-card .x-text { display:flex; flex-direction:column; } .x-card .x-title { font-weight:700; line-height:1.15; font-size:1rem; margin:0; } .x-card .x-sub { color: var(--text-p2); font-size:.9rem; margin-top:.2rem; } /* 渐变主题：使用你的 theme & accent（来自 _config.stellar.yml） */ .grad-theme { color:#fff; background-image:linear-gradient(135deg,hsl(192 98% 55%) 0%, hsl(14 100% 57%) 100%); border-color:hsl(192 98% 55% / .25); } .grad-blue { color:#fff; background-image:linear-gradient(135deg,hsl(192 98% 55%) 0%, hsl(195 95% 60%) 100%); border-color:hsl(192 98% 55% / .25); } .grad-orange { color:#fff; background-image:linear-gradient(135deg,hsl(14 100% 57%) 0%, hsl(28 100% 60%) 100%); border-color:hsl(14 100% 57% / .25); } .grad-theme .x-sub, .grad-blue .x-sub, .grad-orange .x-sub { color: rgba(255,255,255,.85); } @media (prefers-color-scheme: dark) { .grad-theme, .grad-blue, .grad-orange { filter: brightness(.95); } } 常用站点 GitHub 全球最大的代码托管平台 Hexo 快速简洁的静态博客框架 Stellar 当前主题文档 · 技巧与进阶 Bilibili 这是我的B站 欢迎访问啊😎 站内导航 归档 按时间浏览所有文章 分类 按主题聚合内容 标签 快速定位相关话题 RSS 订阅本站更新 友链 社交 Bilibili 摸鱼日常视频日志 Email 欢迎交流或交换友链"}]