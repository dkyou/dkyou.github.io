[{"path":"/2025/11/02/typedef总结/","content":"title: typedef总结date: 2024-10-18 10:00:00tags: [linux,typedef]categories: c typedef总结CC++ typedef用法详解（真的很详细）-CSDN博客 以下是3中常见的通过typedef定义重命名结构体的形式： 匿名方式定义结构体 typedef struct int a; char b; mystruct;//使用mystruct s1; 命名方式定义结构体(用的最多) typedef struct mystruct int a; char b; T_mystruct;//使用T_mystruct s1; T_mystruct为struct mystruct 定义了一个类型别名 定义了一个结构体：mystruct.可以通过struct mystruct xxx;来定义结构体 更推荐的规范做法(实际上感觉用的很少)： struct mystruct int a; int b;;typedef struct mystruct T_mystruct;//typedef struct mystruct pT_mystruct; 这里定义了一个名为 mystruct 的结构体，包含两个整数成员 a 和 b。 使用 typedef 为 struct mystruct 定义了一个别名 T_mystruct T_mystruct 可以用来声明 mystruct 类型的变量"},{"title":"Hello World","path":"/2025/11/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"编译Buildroot_2020.02时遇到IndexError:list index out of range问题解决","path":"/2025/11/01/编译Buildroot_2020.02时遇到IndexErrorlist index out of range问题解决/","content":"编译Buildroot_2020.02时遇到IndexError:list index out of range问题解决具体报错File /home/book/Desktop/workspace_reload_linux_os/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/host/lib/python3.8/site-packages/mesonbuild/dependencies/base.py, line 1204, in _get_cmake_info cmake_root: temp_parser.get_cmake_var(MESON_CMAKE_ROOT)[0], IndexError: list index out of range package/pkg-generic.mk:254: recipe for target /home/book/Desktop/workspace_reload_linux_os/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/build/host-libglib2-2.62.5/.stamp_configured failed make[1]: [/home/book/Desktop/workspace_reload_linux_os/100ask_imx6ull-sdk/Buildroot_2020.02.x/output/build/host-libglib2-2.62.5/.stamp_configured] Error 2 Makefile:84: recipe for target _all failed make: [_all] Error 2 原因Meson 与 CMake版本来源不匹配，导致Meson 在配置host-libglib2时读取 CMake 信息失败。 查看本地cmake版本为3.25而构建这个build root所需版本为3.15。 解决方法1) 强制使用 Buildroot 自带的 host 工具（避免系统 cmakemeson）在 Buildroot 顶层目录执行： export PATH=$(pwd)/output/host/bin:$PATHexport LC_ALL=C 设置PATH优先使用 Buildroot 自己编译的工具（如 cmake、meson、ninja、pkgconf 等），而不是系统里 /usr/bin/ 的版本，避免版本不兼容的系统工具干扰 Buildroot 的编译 LC_ALL是为了避免中文编码问题 先确保这些工具存在可用： output/host/bin/cmake --version || trueoutput/host/bin/meson --version || trueoutput/host/bin/ninja --version || true 如果缺少，就让 Buildroot 构建它们： make host-cmake host-ninja host-meson host-pkgconf 可能会疑惑，明明在我的makefile中并没有host-cmake host-ninja host-meson host-pkgconf这些目标啊，为什么可以make生成呢？ 之所以可以这样做是因为在当前makefile中已经包含package下的子makefile文件，代码如下： include $(sort $(wildcard package/*/*.mk)) 而对应的子makefile，如Buildroot_2020.02.x/package/cmake/cmake.mk中会通过$(eval $(cmake-package))等命令去构造host-cmake等编译目标。 2) 清理失败的包后重建make host-libglib2-dircleanmake all -j4 3) 构建过程中保持 PATH 干净构建全程都保持： export PATH=$(pwd)/output/host/bin:$PATHexport LC_ALL=C 避免系统的 /usr/bin/cmake 抢在前面被调用。","tags":["linux","Cmake","uboot"],"categories":["UBOOT"]},{"title":"LVGL移植到IMX6ULL笔记","path":"/2024/12/20/LVGL移植到IMX6ULL/","content":"LVGL移植到IMX6ULL笔记所需库文件及版本问题所需库文件及版本如下： 库文件 版本 仓库地址 描述 lv_port_linux_frame_buffer releasev8.2 https://github.com/lvgl/lv_port_linux.git 适配有frame buffer的linux系统的接口 lv_drivers releasev8.2(49c4b17) https://github.com/lvgl/lv_drivers.git 包含了驱动LVGL图形界面的驱动接口源代码 lvgl releasev8.2.0(0b5a1d4) https://github.com/lvgl/lvgl.git LVGL图形库源代码,包含所需demo 注意一定要版本对应，不然会出现各种稀奇古怪的问题，可以使用下面的方法下载特定版本： 选择对应版本后，选择Download ZIP 使用git命令克隆特定版本 先git整个仓库 git clone https://github.com/lvgl/lvgl.git 然后切换到对应版本 git checkout v8.2.0 移植文件将上述下载到的lv_drivers lvgl 和 lv_port_linux_frame_buffer中 main.c和 Makefile文件的 放在同一目录下，比如我放在了新建的lvgl_demo目录下。将lvgl_demolvgllv_conf_template.h复制到lvgl_demo下并且改名位lvgl_demolv_conf.h将lvgl_demolv_driverslv_drv_conf_template.h复制到lvgl_demo下并且改名位lvgl_demolv_drv_conf.h此时查看 book@100ask:~/Desktop/lvgl_demo2$ lslv_conf.h lv_drivers lv_drv_conf.h lvgl main.c Makefile 此时目录结构为： lvgl_demo├── lvgl├── lv_drivers├── lv_conf.h├── lv_drv_conf.h├── main.c└── Makefile 二级目录使用tree -L 2查看我的lvgl_demo目录结构如下： lvgl_demo├── lv_conf.h├── lv_drivers│ ├── CMakeLists.txt│ ├── display│ ├── docs│ ├── gtkdrv│ ├── indev│ ├── library.json│ ├── LICENSE│ ├── lv_drivers.mk│ ├── lv_drv_conf_template.h│ ├── README.md│ ├── sdl│ ├── wayland│ ├── win32drv│ ├── win_drv.c│ ├── win_drv.h│ └── win_drv.o├── lv_drv_conf.h├── lvgl│ ├── CMakeLists.txt│ ├── component.mk│ ├── demos│ ├── docs│ ├── env_support│ ├── examples│ ├── idf_component.yml│ ├── Kconfig│ ├── library.json│ ├── library.properties│ ├── LICENCE.txt│ ├── lv_conf_template.h│ ├── lvgl.h│ ├── lvgl.mk│ ├── README.md│ ├── README_zh.md│ ├── SConscript│ ├── scripts│ ├── src│ └── tests├── main.c└── Makefile 修改配置文件修改lv_drv_conf.h 使能驱动将#if 1 /*Set it to 1 to enable the content*/改为#if 1 /*Set it to 1 to enable the content*/ 使能frame buffer设备，将USE_FBDEV的值改为1/*----------------------------------------- * Linux frame buffer device (/dev/fbx) *-----------------------------------------*/#ifndef USE_FBDEV# define USE_FBDEV 1#endif#if USE_FBDEV# define FBDEV_PATH /dev/fb0#endif 使能USE_EVDEV，将devinputevent0改为devinputevent1,这里是使触摸设备生效 /*-------------------------------------------------* Mouse or touchpad as evdev interface (for Linux based systems)*------------------------------------------------*/#ifndef USE_EVDEV# define USE_EVDEV 1#endif#ifndef USE_BSD_EVDEV# define USE_BSD_EVDEV 0#endif#if USE_EVDEV || USE_BSD_EVDEV# define EVDEV_NAME /dev/input/event1 /*You can use the evtest Linux tool to get the list of devices and test them*/# define EVDEV_SWAP_AXES 0 /*Swap the x and y axes of the touchscreen*/# define EVDEV_CALIBRATE 0 /*Scale and offset the touchscreen coordinates by using maximum and minimum values for each axis*/ 修改lv_conf.h 使能，这里和上述步骤相同将#if 1 /*Set it to 1 to enable the content*/改为#if 1 /*Set it to 1 to enable the content*/ 修改显存大小可以使能LV_MEM_CUSTOM自己分配也可以自动分配，我选择的是自己分配显存：/*1: use custom malloc/free, 0: use the built-in `lv_mem_alloc()` and `lv_mem_free()`*/#define LV_MEM_CUSTOM 1#if LV_MEM_CUSTOM == 0 /*Size of the memory available for `lv_mem_alloc()` in bytes (= 2kB)*/ #define LV_MEM_SIZE (48U * 1024U) /*[bytes]*/ /*Set an address for the memory pool instead of allocating it as a normal array. Can be in external SRAM too.*/ #define LV_MEM_ADR 0 /*0: unused*/ /*Instead of an address give a memory allocator that will be called to get a memory pool for LVGL. E.g. my_malloc*/ #if LV_MEM_ADR == 0 //#define LV_MEM_POOL_INCLUDE your_alloc_library /* Uncomment if using an external allocator*/ //#define LV_MEM_POOL_ALLOC your_alloc /* Uncomment if using an external allocator*/ #endif #else /*LV_MEM_CUSTOM*/ #define LV_MEM_CUSTOM_INCLUDE stdlib.h /*Header for the dynamic memory function*/ #define LV_MEM_CUSTOM_ALLOC malloc #define LV_MEM_CUSTOM_FREE free #define LV_MEM_CUSTOM_REALLOC realloc#endif /*LV_MEM_CUSTOM*/ 刷新时间可修改可以不修改，记录说明这里可以按需修改/*====================HAL SETTINGS*====================*/ /*Default display refresh period. LVG will redraw changed areas with this period time*/#define LV_DISP_DEF_REFR_PERIOD 10 /*[ms]*/ /*Input device read period in milliseconds*/#define LV_INDEV_DEF_READ_PERIOD 10 /*[ms]*/ TICK的配置这里选择自己定义一个Tick定时器配置函数,更改后的配置如下：/*Use a custom tick source that tells the elapsed time in milliseconds.*It removes the need to manually update the tick with `lv_tick_inc()`)*/uint32_t custom_tick_get(void);#define LV_TICK_CUSTOM 1#if LV_TICK_CUSTOM#define LV_TICK_CUSTOM_INCLUDE stdint.h /*Header for the system time function*/#define LV_TICK_CUSTOM_SYS_TIME_EXPR (custom_tick_get()) /*Expression evaluating to current system time in ms*/#endif /*LV_TICK_CUSTOM*/ LV_COLOR_DEPTH设置/*====================COLOR SETTINGS*====================*/ /*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/#define LV_COLOR_DEPTH 32 /*Swap the 2 bytes of RGB565 color. Useful if the display has an 8-bit interface (e.g. SPI)*/#define LV_COLOR_16_SWAP 0 颜色深度设置为32位，容易遗忘的设置，否则lvgl颜色显示不正常 使能相应的demo模板这里使用的是LV_USE_DEMO_WIDGETS /*=================== * DEMO USAGE ====================*//*Show some widget. It might be required to increase `LV_MEM_SIZE` */#define LV_USE_DEMO_WIDGETS 1#if LV_USE_DEMO_WIDGETS#define LV_DEMO_WIDGETS_SLIDESHOW 0#endif 修改main.c 修改显示器分辨率disp_drv.hor_res = 1024;disp_drv.ver_res = 600; 注释鼠标输入/*Set a cursor for the mouse*/ // LV_IMG_DECLARE(mouse_cursor_icon) // lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */ // lv_img_set_src(cursor_obj, mouse_cursor_icon); /*Set the image source*/ // lv_indev_set_cursor(mouse_indev, cursor_obj); /*Connect the image object to the driver*/ 注释其他不需要的地方，防止编译不通过，比如：// #include lvgl/demos/lv_demos.h 到这里main函数就修改完了，注意到main.c中就有custom_tick_get实现，其他可以按需修改完整的main.c代码如下： #include lvgl/lvgl.h// #include lvgl/demos/lv_demos.h#include lv_drivers/display/fbdev.h#include lv_drivers/indev/evdev.h#include unistd.h#include pthread.h#include time.h#include sys/time.h// #define DISP_BUF_SIZE (128 * 1024)#define DISP_BUF_SIZE (1024 * 600)int main(void) /*LittlevGL init*/ lv_init(); /*Linux frame buffer device init*/ fbdev_init(); /*A small buffer for LittlevGL to draw the screens content*/ static lv_color_t buf[DISP_BUF_SIZE]; /*Initialize a descriptor for the buffer*/ static lv_disp_draw_buf_t disp_buf; lv_disp_draw_buf_init(disp_buf, buf, NULL, DISP_BUF_SIZE); /*Initialize and register a display driver*/ static lv_disp_drv_t disp_drv; lv_disp_drv_init(disp_drv); disp_drv.draw_buf = disp_buf; disp_drv.flush_cb = fbdev_flush; disp_drv.hor_res = 1024; disp_drv.ver_res = 600; lv_disp_drv_register(disp_drv); evdev_init(); // static lv_indev_drv_t indev_drv_1; // lv_indev_drv_init(indev_drv_1); /*Basic initialization*/ // indev_drv_1.type = LV_INDEV_TYPE_POINTER; // /*This function will be called periodically (by the library) to get the mouse position and state*/ // indev_drv_1.read_cb = evdev_read; // lv_indev_t *mouse_indev = lv_indev_drv_register(indev_drv_1); /* Initialize and register a display input driver */ lv_indev_drv_t indev_drv; lv_indev_drv_init(indev_drv); /*Basic initialization*/ indev_drv.type = LV_INDEV_TYPE_POINTER; indev_drv.read_cb = evdev_read; lv_indev_t * my_indev = lv_indev_drv_register(indev_drv); /*Set a cursor for the mouse*/ // LV_IMG_DECLARE(mouse_cursor_icon) // lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */ // lv_img_set_src(cursor_obj, mouse_cursor_icon); /*Set the image source*/ // lv_indev_set_cursor(mouse_indev, cursor_obj); /*Connect the image object to the driver*/ /*Create a Demo*/ // lv_demo_widgets(); lv_demo_music(); /*Handle LitlevGL tasks (tickless mode)*/ while(1) lv_timer_handler(); usleep(5000); return 0;/*Set in lv_conf.h as `LV_TICK_CUSTOM_SYS_TIME_EXPR`*/uint32_t custom_tick_get(void) static uint64_t start_ms = 0; if(start_ms == 0) struct timeval tv_start; gettimeofday(tv_start, NULL); start_ms = (tv_start.tv_sec * 1000000 + tv_start.tv_usec) / 1000; struct timeval tv_now; gettimeofday(tv_now, NULL); uint64_t now_ms; now_ms = (tv_now.tv_sec * 1000000 + tv_now.tv_usec) / 1000; uint32_t time_ms = now_ms - start_ms; return time_ms; Makefile配置 修改了交叉编译工具链为：CC := arm-buildroot-linux-gnueabihf-gcc. 使用echo $CROSS_COMPILE可以查看交叉编译链是什么 将鼠标样式的连接源文件注释掉# CSRCS +=$(LVGL_DIR)/mouse_cursor_icon.c 完整的Makefile如下： ## Makefile## CC ?= gccCC := arm-buildroot-linux-gnueabihf-gccLVGL_DIR_NAME ?= lvglLVGL_DIR ?= $shell pwdCFLAGS ?= -O3 -g0 -I$(LVGL_DIR)/ -Wall -Wshadow -Wundef -Wmissing-prototypes -Wno-discarded-qualifiers -Wall -Wextra -Wno-unused-function -Wno-error=strict-prototypes -Wpointer-arith -fno-strict-aliasing -Wno-error=cpp -Wuninitialized -Wmaybe-uninitialized -Wno-unused-parameter -Wno-missing-field-initializers -Wtype-limits -Wsizeof-pointer-memaccess -Wno-format-nonliteral -Wno-cast-qual -Wunreachable-code -Wno-switch-default -Wreturn-type -Wmultichar -Wformat-security -Wno-ignored-qualifiers -Wno-error=pedantic -Wno-sign-compare -Wno-error=missing-prototypes -Wdouble-promotion -Wclobbered -Wdeprecated -Wempty-body -Wtype-limits -Wshift-negative-value -Wstack-usage=2048 -Wno-unused-value -Wno-unused-parameter -Wno-missing-field-initializers -Wuninitialized -Wmaybe-uninitialized -Wall -Wextra -Wno-unused-parameter -Wno-missing-field-initializers -Wtype-limits -Wsizeof-pointer-memaccess -Wno-format-nonliteral -Wpointer-arith -Wno-cast-qual -Wmissing-prototypes -Wunreachable-code -Wno-switch-default -Wreturn-type -Wmultichar -Wno-discarded-qualifiers -Wformat-security -Wno-ignored-qualifiers -Wno-sign-compareLDFLAGS ?= -lmBIN = demo#Collect the files to compileMAINSRC = ./main.cinclude $(LVGL_DIR)/lvgl/lvgl.mkinclude $(LVGL_DIR)/lv_drivers/lv_drivers.mk# include $(LVGL_DIR)/lv_demos/lv_demos.mk# CSRCS +=$(LVGL_DIR)/mouse_cursor_icon.c OBJEXT ?= .oAOBJS = $(ASRCS:.S=$(OBJEXT))COBJS = $(CSRCS:.c=$(OBJEXT))MAINOBJ = $(MAINSRC:.c=$(OBJEXT))SRCS = $(ASRCS) $(CSRCS) $(MAINSRC)OBJS = $(AOBJS) $(COBJS)## MAINOBJ - OBJFILESall: default%.o: %.c\t@$(CC) $(CFLAGS) -c $ -o $@\t@echo CC $ default: $(AOBJS) $(COBJS) $(MAINOBJ)\t$(CC) -o $(BIN) $(MAINOBJ) $(AOBJS) $(COBJS) $(LDFLAGS)\tmkdir -p $(LVGL_DIR)/obj $(LVGL_DIR)/bin\tmv *.o $(LVGL_DIR)/obj/\tmv $(BIN) $(LVGL_DIR)/bin/clean: rm -f $(BIN) $(AOBJS) $(COBJS) $(MAINOBJ) ./bin/* ./obj/* 运行和结果 使用make编译后，将生成demo可执行文件。然后通过mount挂载，将编译好的demo放到开发板的mnt目录下 开发板上切换到mnt目录，执行.demo运行 结果 注意事项1.注意版本一致，不然容易出现各种各样稀奇古怪的问题，有可能无法编译。我甚至遇到过编译成功之后出来的可执行文件是64位的，而开发板是32位的，导致无法运行。2.修改配置或者源码之后，如果不是预期的效果，可以试试先make clean，然后再make。 参考链接【嵌入式Linux应用开发】1. 移植LVGL到Linux开发板","tags":["嵌入式","LVGL"],"categories":["LVGL"]},{"title":"IMX6ULL移除及恢复原有UI","path":"/2024/12/15/移除及恢复原有UI/","content":"IMX6ULL移除及恢复原有UI有时候需要移除掉IMX6ULL原本的UI，恢复成默认的界面，方便我们做一些LVGL的测试或者运行其他的图形界面。 进入/etc/init.d/目录 进入/etc/init.d/目录下，可以看到有以下文件：其中S99myirhmi2就是我们的目标文件 移除S99myirhmi2移动S99myirhmi2的启动脚本到/root目录下，防止开机时自动启动，使用命令： mv /etc/init.d/S99myirhmi2 /root/sync 移除成功后，重启设备。 reboot 这样就不会进入myirhmi2了,如下，会卡在这个界面： 恢复原有 UI 如果想恢复原有 UI，则执行以下命令即可： mv /root/S99myirhmi2 /etc/init.d/sync 再reboot重启即可恢复 关闭自动黑屏注意：以下命令重启后均失效执行： echo -e \\033[9;0] /dev/tty0 重新启用自动黑屏： echo -e \\033[9;1] /dev/tty0 打开光标 echo -e \\033[?25h /dev/tty1 关闭光标 echo -e “\\033[?25l” /dev/tty1","tags":["ubuntu","UI"],"categories":["UBUNTU"]},{"title":"catkin_make 编译出错","path":"/2024/10/31/catkin_make编译出错/","content":"catkin_make 编译出错报错：usrbinld: 找不到 -lncurses原因：找不到相应的libncurses.so动态库，库文件没有导入到ld检索目录 解决方法：1.使用locate定位libncurses.so locate libncurses.so 输出： /snap/core/17200/lib/x86_64-linux-gnu/libncurses.so.5/snap/core/17200/lib/x86_64-linux-gnu/libncurses.so.5.9/snap/core20/2379/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core20/2379/usr/lib/x86_64-linux-gnu/libncurses.so.6.2/snap/core20/2434/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core20/2434/usr/lib/x86_64-linux-gnu/libncurses.so.6.2/snap/core22/1621/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core22/1621/usr/lib/x86_64-linux-gnu/libncurses.so.6.3/snap/core22/1663/usr/lib/x86_64-linux-gnu/libncurses.so.6/snap/core22/1663/usr/lib/x86_64-linux-gnu/libncurses.so.6.3/usr/lib/x86_64-linux-gnu/libncurses.so.6/usr/lib/x86_64-linux-gnu/libncurses.so.6.2 随便找一个进行软链接 sudo ln -s /usr/lib/x86_64-linux-gnu/libncurses.so.6 /usr/lib/libncurses.so 更新库缓存 sudo ldconfig 重新catkin_make编译参考链接：https://blog.csdn.net/qq_34761779/article/details/126665354","tags":["ros","笔记"],"categories":["ROS"]},{"title":"roslaunch 出错","path":"/2024/10/31/roslaunch出错/","content":"roslaunch 出错报错：homedkutouch_wsdevellibomni_commonomni_state: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory 原因：缺少libncurses.so.5共享库 解决方法：1.安装libncurses.so.5共享库 sudo apt-get updatesudo apt-get install libncurses5 重新运行roslaunch omni_common omni.launch参考链接：https://blog.csdn.net/qq_38236680/article/details/142253345 接着遇到：Failed to initialize haptic device报错具体报错信息：[ERROR] [1730784892.557095854]: Failed to initialize haptic device[omni_state-1] process has died [pid 13774, exit code 255, cmd homedkutouch_wsdevellibomni_commonomni_state __name:omni_state __log:homedku.roslog6a3020f8-9b2e-11ef-82db-71f799b1505aomni_state-1.log].log file: homedku.roslog6a3020f8-9b2e-11ef-82db-71f799b1505aomni_state-1*.log解决方法：把touch驱动程序关了….这点很坑","tags":["ros","笔记"],"categories":["ROS"]},{"title":"vscode中找不到ros中的一些头文件","path":"/2024/10/31/vscode中找不到ros中的一些头文件/","content":"vscode中找不到ros中的一些头文件一个小问题在VSCode中，我们通常使用ROS的C++开发，但是ROS的C++开发需要使用ROS的API，但是ROS的API在VSCode中找不到，头文件也找不到，但是编译是可以成功的，说明只是vscode的配置问题。最最重要的是，vscode找不到头文件，在写代码的时候就没有代码提示，就无法知道变量下还有哪些值，这就导致根本就无法写代码。例如在头文件中找不到#include sensor_msgs/JointState.h头文件，解决方法如下：经过查找，JointState.h位于/opt/ros/noetic/include/sensor_msgs/JointState.h 在c_cpp_properties.json中添加如下配置： includePath: [ $workspaceFolder/**, /opt/ros/noetic/include], 接着source devel/setup.bash,就会发现头文件下的波浪线消失了，也可以正常打开JointState.h文件。PS:在一开始的解决方案里，在CMakeLists.txt中添加了include_directories(${Boost_INCLUDE_DIR} ${catkin_INCLUDE_DIRS} /opt/ros/noetic/include)，但是cmake是编译的时候才去查找头文件，所以还是需要添加到c_cpp_properties.json中，可以不用管CMakeLists.txt.","tags":["vscode配置"],"categories":["C++笔记"]},{"title":"运算符重载小知识点","path":"/2024/10/31/运算符重载小知识点/","content":"运算符重载小知识点在 C++ 中，运算符重载可以通过成员函数或友元函数来实现。对于成员函数形式的运算符重载，输入参数的数量确实看起来只有一个，但实际上有两个参数： 隐式参数：即调用该运算符的对象本身。在成员函数中，这个对象可以通过 this 指针访问。显式参数：即传递给成员函数的参数 Complex c1(3.5, 2.0);Complex c2(1.0, 4.0);Complex sum = c1 + c2; 在这个例子中，c1 + c2 实际上被编译器解释为 c1.operator+(c2)。这里： c1 是隐式参数，对应 this 指针。c2 是显式参数，传递给 operator+ 函数。因此，虽然 operator+ 函数的定义中只有一个参数，但在实际调用时，c1 和 c2 都参与了运算。 ## 完整代码#include iostreamclass Complex private: double real; double imag;public: // 构造函数 Complex(double r = 0, double i = 0) : real(r), imag(i) // 加法运算符重载 Complex operator+(const Complex other) const Complex result; result.real = this-real + other.real; result.imag = this-imag + other.imag; return result; // 减法运算符重载 Complex operator-(const Complex other) const return Complex(real - other.real, imag - other.imag); // 输出运算符重载 friend std::ostream operator(std::ostream os, const Complex c) os c.real + c.imag i; return os; ;int main() Complex c1(3.5, 2.0); Complex c2(1.0, 4.0); Complex sum = c1 + c2; Complex diff = c1 - c2; std::cout c1: c1 std::endl; std::cout c2: c2 std::endl; std::cout c1 + c2: sum std::endl; std::cout c1 - c2: diff std::endl; return 0; 完","tags":["c++","运算符重载"],"categories":["C++笔记"]},{"title":"Cmake构建自动化编译环境","path":"/2024/10/30/Cmake构建自动化编译环境/","content":"Cmake构建自动化编译环境完整项目文件结构：一个完整的项目应该包括如下文件结构： ProjectName/├── CMakeLists.txt├── src/│ ├── main.cpp│ ├── xxx.cpp│ └── yyy.cpp├── include/│ ├── xxx.h│ └── yyy.h│── build/│── lib/└── test/example/├── thridparty/├── README.md└── autobuild.sh bin:生成的可执行文件 lib：生成的中间库文件 include: src: build:编译过程中产生的临时文件 testexample:示意文件 thridparty:第三方库文件 CMakeLists.txs: autobuild.sh:一键编译，其实就是执行的cmake文件 license: readme: ChatServer文件结构ChatServer/├── .vscode/├── src/│ ├── server│ │ ├── chat_server.cpp│ │ └── CmakeLists.txt│ ││ └── client│ ├── chat_client.cpp│ └── CmakeLists.txt├── include/│ ├── chat_server.h│ ├── chat_client.h│ └── otherfile.h├── build/Makefile├── bin/│ └── 生成的可执行文件├── thridparty/ │ └── json.hpp├── test/├── CMakeLists.txt├── README.md└── autobuild.sh CMakeLists.txt文件解释从顶层开始，每一个子目录下都有自己的CMakeLists.txt文件.下面是每一层的CMakeLists.txt文件,非常不完善，正在补充中… 顶层CMakeLists，路径：chatserverCMakeLists.txt cmake_minimum_required(VERSION 3.0)project(chat)# 配置编译选项set(CMAKE_CXX_FLAGS $CMAKE_CXX_FLAGS -g)# 添加子目录#配置最终的可执行文件的输出路径,PROJECT_SOURCE_DIR表示当前项目的根目录set(EXECUTABLE_OUTPUT_PATH $PROJECT_SOURCE_DIR/bin)#配置头文件的搜索路径include_directories($PROJECT_SOURCE_DIR/include)include_directories($PROJECT_SOURCE_DIR/include/server)#加载子目录,子目录下也需要有CMakeLists.txt文件，子目录都写在src文件下add_subdirectory(src) src中CMakeLists，路径：chatserversrcCMakeLists.txt #添加子目录，在server目录下也有一个CMakeLists.txt文件add_subdirectory(server) srcserver中CMakeLists，路径：chatserversrcserverCMakeLists.txt #定义了一个SRC_LIST变量，包含当前目录下所有的源文件aux_source_directory(. SRC_LIST)#由所有源码生成可执行文件,指定生成可执行文件的名称为ChatServeradd_executable(ChatServer $SRC_LIST)#指定可执行文件需要链接时所依赖的库，muduo_net muduo_base pthreadtarget_link_libraries(ChatServer muduo_net muduo_base pthread) srcclient中CMakeLists，路径：chatserversrcclientCMakeLists.txt # 定义了一个SRC_LIST变量，包含了该目录下所有的源文件aux_source_directory(. SRC_LIST)# 指定生成可执行文件add_executable(ChatClient $SRC_LIST)# 指定可执行文件链接时需要依赖的库文件target_link_libraries(ChatClient pthread) 执行命令：cmake . 或者 cmake ..在哪里执行cmake，就会在哪里生成中间文件和可执行文件因此可以进入build目录执行cmake ..命令，这样生成的文件就在build目录下 未完待续…","tags":["linux","Cmake","c++"],"categories":["LINUX"]},{"title":"Makefile总结及通用模板使用","path":"/2024/10/18/Makefile总结及通用模板使用/","content":"Makefile总结及通用模板使用项目结构./├── a│ ├── Makefile│ ├── sub2.c│ └── sub3.c├── include│ ├── sub2.h│ ├── sub3.h│ └── sub.h├── main.c├── Makefile├── Makefile.build└── sub.c 示例C代码C代码只是作为示例，为了不影响阅读见附录 makefile文件顶层目录下的MakefileCROSS_COMPILE = AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nmSTRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMPCFLAGS := -Wall -O2 -gCFLAGS += -I $(shell pwd)/includeLDFLAGS := export CFLAGS LDFLAGSTOPDIR := $(shell pwd)export TOPDIRTARGET := testobj-y += main.oobj-y += sub.oobj-y += a/# print:# @echo $(TARGET)# @echo $(shell find -name *.o)# @echo obj-y=$(obj-y)# @echo TOPDIR=$(TOPDIR)# TOPDIR=/home/book/Documents/makefile_learn/general_Makefile/example# 执行make 会执行第一个 all 目标。all 分成两个依赖 start_recursive_build 和 $(TARGET)all : start_recursive_build $(TARGET)\t@echo $(TARGET) has been built!start_recursive_build:\t@echo ------------------start_recursive_build begin---------------------\tmake -C ./ -f $(TOPDIR)/Makefile.build\t@echo ------------------start_recursive_build end------------------------$(TARGET) : start_recursive_build\t@echo -------------------------test begin---------------------------------\t$(CC) -o $(TARGET) built-in.o $(LDFLAGS)\t@echo -------------------------test end-----------------------------------clean:\trm -f $(shell find -name *.o)\trm -f $(TARGET)distclean:\trm -f $(shell find -name *.o)\trm -f $(shell find -name *.d)\trm -f $(TARGET) 顶层目录下的Makefile.buildPHONY := __build__build:# 先清空obj-y :=subdir-y :=EXTRA_CFLAGS :=# 再包含 Makefileinclude Makefile# obj-y := a.o b.o c/ d/# $(filter %/, $(obj-y)) : c/ d/# __subdir-y : c d# subdir-y : c d__subdir-y\t:= $(patsubst %/,%,$(filter %/, $(obj-y)))subdir-y\t+= $(__subdir-y)# c/built-in.o d/built-in.osubdir_objs := $(foreach f,$(subdir-y),$(f)/built-in.o)# a.o b.ocur_objs := $(filter-out %/, $(obj-y))dep_files := $(foreach f,$(cur_objs),.$(f).d)dep_files := $(wildcard $(dep_files))ifneq ($(dep_files),) include $(dep_files)endifPHONY += $(subdir-y)# 依赖于子目录a 依赖于built-in.o__build : $(subdir-y) built-in.o# 先去处理子目录a# make -C 进入子目录a,使用顶层的makefile.build来处理这个子目录,即就是这个makefile.build。#子目录中的makefile会对标志位，文件啥的进行赋值，然后执行%.o : %.c下面的规则。$(subdir-y):\t@echo --------------------subdir-y begin---------------------------\t@echo subdir-y=$(subdir-y)\t@echo @=$@\t@echo TOPDIR=$(TOPDIR)\tmake -C $@ -f $(TOPDIR)/Makefile.build\t@echo --------------------subdir-y end---------------------------#这一部分递归了好几次，第一次递归：在子目录a下生成a/built-in.o# 这里subdir-y subdir_objs都为空 cur_objs=sub2.o sub3.o,即ld -r -o built-in.o sub2.o sub3.o obj-y= sub2.o sub3.o# 第二次递归：ld -r -o built-in.o main.o sub.o a/built-in.obuilt-in.o : $(subdir-y) $(cur_objs)\t@echo --------------------built-in.o begin---------------------------\t@echo subdir-y=$(subdir-y)\t@echo @=$@\t@echo cur_objs=$(cur_objs)\t@echo subdir_objs=$(subdir_objs)\t@echo obj-y=$(obj-y)\t@echo CFLAGS_sub3.o=$(CFLAGS_sub3.o)\t$(LD) -r -o $@ $(cur_objs) $(subdir_objs)\t@echo --------------------built-in.o end---------------------------dep_file = .$@.d%.o : %.c\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$@) -Wp,-MD,$(dep_file) -c -o $@ $\t.PHONY : $(PHONY) 子目录下的Makefile目录：a/Makefile # -D 即define 相当于在头文件中定义了宏：DEBUGEXTRA_CFLAGS := -D DEBUG# 单独给sub3.c 定义了宏：DEBUG_SUB3 只适用于sub3.o 并不适用sub2.oCFLAGS_sub3.o := -D DEBUG_SUB3obj-y += sub2.o obj-y += sub3.o make输出结果make -C ./ -f /home/book/Makefile_example/Makefile.buildmake[1]: Entering directory /home/book/Makefile_example--------------------subdir-y begin---------------------------subdir-y= a@=aTOPDIR=/home/book/Makefile_examplemake -C a -f /home/book/Makefile_example/Makefile.buildmake[2]: Entering directory /home/book/Makefile_example/agcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -Wp,-MD,.sub2.o.d -c -o sub2.o sub2.cgcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -D DEBUG_SUB3 -Wp,-MD,.sub3.o.d -c -o sub3.o sub3.c--------------------built-in.o begin---------------------------subdir-y=@=built-in.ocur_objs=sub2.o sub3.osubdir_objs=obj-y= sub2.o sub3.oCFLAGS_sub3.o=-D DEBUG_SUB3ld -r -o built-in.o sub2.o sub3.o --------------------built-in.o end---------------------------make[2]: Leaving directory /home/book/Makefile_example/a--------------------subdir-y end---------------------------gcc -Wall -O2 -g -I /home/book/Makefile_example/include -Wp,-MD,.main.o.d -c -o main.o main.cgcc -Wall -O2 -g -I /home/book/Makefile_example/include -Wp,-MD,.sub.o.d -c -o sub.o sub.c--------------------built-in.o begin---------------------------subdir-y= a@=built-in.ocur_objs=main.o sub.osubdir_objs=a/built-in.oobj-y= main.o sub.o a/CFLAGS_sub3.o=ld -r -o built-in.o main.o sub.o a/built-in.o--------------------built-in.o end---------------------------make[1]: Leaving directory /home/book/Makefile_example------------------start_recursive_build end-------------------------------------------------test begin---------------------------------gcc -o test built-in.o -------------------------test end-----------------------------------test has been built! 分析过程1.顶层目录执行make之后，先会执行第一个目标all ，all依赖于start_recursive_build和$(TARGET),$(TARGET)即最终生成的test。所以先会执行start_recursive_build这个目标下的规则来生成built-in.o，接着执行test这个目标下的规则，将生成的built-in.o文件链接生成test最终文件 2.最重要的是start_recursive_build begin这个目标如何在各个源代码目录下生成各自的built-in.o. 2.1执行make -C ./ -f $(TOPDIR)/Makefile.build命令，进入当前目录（还是当前目录，没变），使用顶层目录（还是当前目录）下的Makefile.build作为make执行的makefile文件。 2.1在Makefile.build文件中，首先是obj-y ,subdir-y，EXTRA_CFLAGS这些变量的清楚，然后再重新赋值。不再详细分析。主要看__build : $(subdir-y) built-in.o，在当前情况下subdir-y就是a，执行$(subdir-y):下的规则make -C $@ -f $(TOPDIR)/Makefile.build，进入a目录，使用顶层目录下的Makefile.build对a目录下的文件进行处理。因为a目录下的makefile做了一些变量的赋值操作，所以此时的obj-y= sub2.o sub3.o CFLAGS_sub3.o=-D DEBUG_SUB3。所以此时的%.o : %.c规则就展开成了这个样子 %.o : %.c\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(CF 展开为： gcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -Wp,-MD,.sub2.o.d -c -o sub2.o sub2.cgcc -Wall -O2 -g -I /home/book/Makefile_example/include -D DEBUG -D DEBUG_SUB3 -Wp,-MD,.sub3.o.d -c -o sub3.o sub3.c 这样就生成了sub2.o和sub3.o.但是此时还没完，因为我们的目标是在子目录下生成a/built-in.o 2.2在子目录a中当然也会执行到built-in.o : $(subdir-y) $(cur_objs),此时subdir-y为空，因为a下面没有子目录了。而cur_objs=sub2.o sub3.o。此时通过规则$(LD) -r -o $@ $(cur_objs) $(subdir_objs)来将sub2.o sub3.o链接成a/built-in.o。这个命令展开实际为： ld -r -o built-in.o sub2.o sub3.o 此时就完成了我们的任务：生成:a/built-in.o. 所以我们也可看到make输出：离开a文件夹 make[2]: Leaving directory /home/book/Makefile_example/a 3.回到主目录之后，继续使用makefile.build来处理顶层文件夹的源文件。比如将main.c sub.c文件转换成.o.d文件（当然在a目录下也做了这个工作）。接下来的工作就是生成顶层目录下的built-in.o文件。注意此时make已经切换到了顶层目录。此时subdir-y=a,cur_objs=main.o sub.o subdir_objs=a/built-in.o。此时通过规则$(LD) -r -o $@ $(cur_objs) $(subdir_objs)来将main.o sub.o a/built-in.o链接成顶层目录下的built-in.o 这个命令展开实际为 ld -r -o built-in.o main.o sub.o a/built-in.o 3.1至此，built-in.o的生成工作就大功告成了，此时可以看到make离开文件夹（不知道离开了没，我感觉没有），start_recursive_build endend. make[1]: Leaving directory /home/book/Makefile_example 4.现在顶层目录的built-in.o已经有了，顶层目录下的built-in.o汇聚了所有子目录的.o信息以及main.o的信息。只需要通过gcc -o test built-in.o 即可生成我们的最终目标test 5.最终start_recursive_build和$(TARGET)都有了，打印输出： test has been built! Makefile零碎知识点目标冒号后面没有依赖项的情况对于只有目标而没有依赖项的情况，说明该目标不依赖任何文件或者目标，直接执行后面的命令。这种情况一般用于伪目标。 常见的伪目标有：clean install help 清理操作 clean:\trm -f *.o 安装操作 install: modules_install\t$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@\tmodules_install:\t$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@ install 目标依赖于 modules_install，但这里我们关注的是 modules_install 自身。modules_install 没有依赖项，直接执行命令进入内核源码目录并安装模块 其执行逻辑大概就是make判断当前目标是否比依赖新，结果没有发现目标文件，当然不可能比依赖新，就执行后面的语句。但是当Makefile目录下如果有clean文件时候，再执行make时候就会提示make: clean is up to date.。如果想避免这种情况，就需要使用 .PHONY : clean告诉make clean是个伪目标，不管有没有clean这个文件。 为什么使用无依赖项的目标？ 伪目标：用于触发特定操作而非生成文件。例如，clean、install、help 等目标通常不生成实际文件，而是执行清理、安装或显示帮助信息等操作。 简化逻辑：某些操作不需要依赖其他文件或目标，直接执行命令即可。例如，清理操作只需要删除特定文件，而不需要等待其他文件生成。 灵活性：允许开发者定义任意数量的伪目标，方便扩展和维护 Makefile。 多个目标共享同一组命令modules modules_install help clean:\t$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@ 当调用这些目标中的任何一个时，都会执行相同的命令，即进入内核源码目录并根据目标名称执行相应的操作。 默认执行第一个目标如果有多个伪目标，默认情况下使用make命令指挥执行第一个目标。例如一个完整的Makefile内容如下(测试用例)，默认是执行第一个目标help，可以使用make clean执行clean目标。 help:\t@echo Available targets:\t@echo all - Build the module\t@echo install - Install the module\t@echo clean - Clean up build filesclean:\trm -f *.o make -C directory [target] -C directory：表示进入指定的目录 directory，然后在该目录中执行Make命令 [target]：可选参数，表示要执行的目标。如果没有指定目标，则默认执行Makefile中的第一个目标。 操作示例1：执行命令make -C test，输出为。这个案例的Makefile内容就是上文只包含help和clean的那个。 book@100ask:~/Documents/makefile_learn$ make -C testmake: Entering directory /home/book/Documents/makefile_learn/testAvailable targets: all - Build the module install - Install the module clean - Clean up build filesmake: Leaving directory /home/book/Documents/makefile_learn/test 操作示例2：执行命令make -C test clean book@100ask:~/Documents/makefile_learn$ make -C test clean make: Entering directory /home/book/Documents/makefile_learn/testrm -f *.omake: Leaving directory /home/book/Documents/makefile_learn/test make -C directory -f makefile -C directory：表示进入指定的目录 directory，然后在该目录中执行Make命令。 -f makefile：指定要使用的Makefile文件为 makefile。默认情况下，make 会查找名为 Makefile 或 makefile 的文件，但使用 -f 可以明确指定其他文件。 make -C ./ -f $(TOPDIR)/Makefile.build -C ./：表示进入当前目录（. 表示当前目录）。这通常用于确保在特定的工作目录中执行Make操作。 -f $(TOPDIR)/Makefile.build：指定使用位于 $(TOPDIR) 目录下的 Makefile.build 文件作为Makefile。$(TOPDIR) 是一个变量，通常定义为项目的顶层目录路径。 附录：示例C代码main.c#include stdio.hextern void sub_fun(void);extern void sub2_fun(void);void sub3_fun(void);int main(int argc, char* argv[]) printf(Main fun! ); sub_fun(); sub2_fun(); sub3_fun(); return 0; sub.c#include stdio.h#include sub.hvoid sub_fun(void) printf(Sub fun, A = %d! , A); asub2.c#include stdio.h#include sub2.hvoid sub2_fun(void) printf(Sub2 fun, B = %d! , B); #ifdef DEBUG\tprintf(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);#endif asub3.c#include stdio.h#include sub3.hvoid sub3_fun(void) printf(Sub3 fun, C = %d! , C);\t#ifdef DEBUG printf(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);#endif#ifdef DEBUG_SUB3 printf(It is only debug info for sub3. );#endif includesub.h#define A 1void sub_fun(void); includesub2.h#define B 2void sub2_fun(void); includesub3.h#define B 2void sub2_fun(void); Makefile模板顶层Makefile# 如果给pc机编译则不需要设置，如果给arm板编译则需要设置# arm-buildroot-linux-gnueabihf-CROSS_COMPILE = AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nmSTRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMPCFLAGS := -Wall -O2 -g# 以后所有的.c文件都会去 当前目录下的include目录下查找头文件，给所有的.c文件都要用到这个属性CFLAGS += -I $(shell pwd)/include# 链接选项 可以指定库在哪里，需要链接哪些库 LDFLAGS := -L dir -l libnameLDFLAGS := export CFLAGS LDFLAGSTOPDIR := $(shell pwd)export TOPDIRTARGET := testobj-y += main.oobj-y += sub.oobj-y += a/all : start_recursive_build $(TARGET)\t@echo $(TARGET) has been built!start_recursive_build:\tmake -C ./ -f $(TOPDIR)/Makefile.build$(TARGET) : start_recursive_build\t$(CC) -o $(TARGET) built-in.o $(LDFLAGS)clean:\trm -f $(shell find -name *.o)\trm -f $(TARGET)distclean:\trm -f $(shell find -name *.o)\trm -f $(shell find -name *.d)\trm -f $(TARGET) 顶层目录Makefile.buildPHONY := __build__build:obj-y :=subdir-y :=EXTRA_CFLAGS :=include Makefile# obj-y := a.o b.o c/ d/# $(filter %/, $(obj-y)) : c/ d/# __subdir-y : c d# subdir-y : c d__subdir-y\t:= $(patsubst %/,%,$(filter %/, $(obj-y)))subdir-y\t+= $(__subdir-y)# c/built-in.o d/built-in.osubdir_objs := $(foreach f,$(subdir-y),$(f)/built-in.o)# a.o b.ocur_objs := $(filter-out %/, $(obj-y))dep_files := $(foreach f,$(cur_objs),.$(f).d)dep_files := $(wildcard $(dep_files))ifneq ($(dep_files),) include $(dep_files)endifPHONY += $(subdir-y)__build : $(subdir-y) built-in.o$(subdir-y):\tmake -C $@ -f $(TOPDIR)/Makefile.buildbuilt-in.o : $(subdir-y) $(cur_objs)\t$(LD) -r -o $@ $(cur_objs) $(subdir_objs)dep_file = .$@.d%.o : %.c\t$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$@) -Wp,-MD,$(dep_file) -c -o $@ $\t.PHONY : $(PHONY) 子目录Makefile一般是指定源文件和编译选项 # EXTRA_CFLAGS := -D DEBUG# CFLAGS_sub3.o := -D DEBUG_SUB3obj-y += sub2.o obj-y += sub3.o 使用说明本程序的Makefile分为3类:1. 顶层目录的Makefile2. 顶层目录的Makefile.build3. 各级子目录的Makefile一、各级子目录的Makefile： 它最简单，形式如下：EXTRA_CFLAGS := CFLAGS_file.o := obj-y += file.oobj-y += subdir/ obj-y += file.o 表示把当前目录下的file.c编进程序里， obj-y += subdir/ 表示要进入subdir这个子目录下去寻找文件来编进程序里，是哪些文件由subdir目录下的Makefile决定。 EXTRA_CFLAGS, 它给当前目录下的所有文件(不含其下的子目录)设置额外的编译选项, 可以不设置 CFLAGS_xxx.o, 它给当前目录下的xxx.c设置它自己的编译选项, 可以不设置注意: 1. subdir/中的斜杠/不可省略2. 顶层Makefile中的CFLAGS在编译任意一个.c文件时都会使用3. CFLAGS EXTRA_CFLAGS CFLAGS_xxx.o 三者组成xxx.c的编译选项二、顶层目录的Makefile： 它除了定义obj-y来指定根目录下要编进程序去的文件、子目录外， 主要是定义工具链前缀CROSS_COMPILE, 定义编译参数CFLAGS, 定义链接参数LDFLAGS, 这些参数就是文件中用export导出的各变量。三、顶层目录的Makefile.build： 这是最复杂的部分，它的功能就是把某个目录及它的所有子目录中、需要编进程序去的文件都编译出来，打包为built-in.o 详细的讲解请看视频。四、怎么使用这套Makefile：1．把顶层Makefile, Makefile.build放入程序的顶层目录 在各自子目录创建一个空白的Makefile2．确定编译哪些源文件 修改顶层目录和各自子目录Makefile的obj-y : obj-y += xxx.o\tobj-y += yyy/\t这表示要编译当前目录下的xxx.c, 要编译当前目录下的yyy子目录\t3. 确定编译选项、链接选项 修改顶层目录Makefile的CFLAGS，这是编译所有.c文件时都要用的编译选项; 修改顶层目录Makefile的LDFLAGS，这是链接最后的应用程序时的链接选项; 修改各自子目录下的Makefile： EXTRA_CFLAGS, 它给当前目录下的所有文件(不含其下的子目录)设置额外的编译选项, 可以不设置 CFLAGS_xxx.o, 它给当前目录下的xxx.c设置它自己的编译选项, 可以不设置 4. 使用哪个编译器？ 修改顶层目录Makefile的CROSS_COMPILE, 用来指定工具链的前缀(比如arm-linux-) 5. 确定应用程序的名字： 修改顶层目录Makefile的TARGET, 这是用来指定编译出来的程序的名字6. 执行make来编译，执行make clean来清除，执行make distclean来彻底清除 参考韦东山《通用Makefile的使用》","tags":["linux","makefile"],"categories":["c"]},{"title":"三数之和","path":"/2024/10/15/每日一刷day37(梦破碎的地方)/","content":"梦破碎的地方，真是太难了.-_-… 三数之和：梦破碎的地方题目：三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c 0 ？请你找出所有满足条件且不重复的三元组。注意： 答案中不可以包含重复的三元组。示例：给定数组 nums [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解法-双指针法思路： 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码：（成功提交但是有逻辑错误和注释理解错误） #include vector#include algorithm#include iostreamusing namespace std;class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint result; //计算nums[i] + nums[left] + nums[right] = 0; //先对nums[]进行一次排序，方便判断 sort(nums.begin(),nums.end()); for(int i = 0;i nums.size();i++) cout nums[i] ; cout endl; //遍历数组 for(int i = 0;i nums.size();i++) //a去重，判断首位元素是否大于0，如果大于0，则三个正数相加不为0 if(nums[i] 0)return result; //b去重 if(i 0 nums[i] == nums[i-1]) continue; int left = i+1; int right = nums.size()-1; //开始收缩 while(leftright) //说明right偏右了 if(nums[i] + nums[left] + nums[right] 0) right--; else if(nums[i] + nums[left] + nums[right] 0) //说明left偏左了 left++; else if(nums[i] + nums[left] + nums[right]==0) result.push_back(vectorintnums[i],nums[left],nums[right]); //去重，如果有的话 while(i0nums[left] == nums[left+1]) left++; while(i0nums[right] == nums[right-1]) right--; left++;right--; //if(nums[i] + nums[left] + nums[right]==0) // result.push_back(nums[i],nums[left],nums[right]); // //去重，如果有的话 // while(i0nums[left] == nums[left+1]) left++; // while(i0nums[right] == nums[right-1]) right--; // left++;right--; // return result; ;int main() Solution solution; vectorint nums1 = -1,0,1,2,-1,-4; //vectorvectorint expected1 = -1, -1, 2, -1, 0, 1; vectorvectorint result1 = solution.threeSum(nums1); //遍历二维数组 for (int i = 0; i result1.size(); i++) for (int j = 0; j result1[i].size(); j++) cout result1[i][j] ; cout endl; return 0; 错误描述： if(nums[i] 0){return result;}这句话不是对a去重，而是判断首位元素是否大于0，如果大于0，则三个正数相加不为0.下一句if(i 0 nums[i] == nums[i-1])才是对a去重 while(i0nums[left] == nums[left+1]) left++;逻辑错误，应该改为while(leftright nums[left] == nums[left+1]) left++;,i0的条件应该不对，虽然通过LeetCode了 代码(更正后) class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint result; //计算nums[i] + nums[left] + nums[right] = 0; //先对nums[]进行一次排序，方便判断 sort(nums.begin(),nums.end()); for(int i = 0;i nums.size();i++) cout nums[i] ; cout endl; //遍历数组 for(int i = 0;i nums.size();i++) //判断首位元素是否大于0，如果大于0，则三个正数相加不为0 if(nums[i] 0)return result; //a去重,如果可以包含重复的三元组，则把这个if语句注释掉,虽然也不太能保留所有重复的三元组 if(i 0 nums[i] == nums[i-1]) continue; int left = i+1; int right = nums.size()-1; //开始收缩 while(leftright) //说明right偏右了 if(nums[i] + nums[left] + nums[right] 0) right--; else if(nums[i] + nums[left] + nums[right] 0) //说明left偏左了 left++; else if(nums[i] + nums[left] + nums[right]==0) result.push_back(vectorintnums[i],nums[left],nums[right]); //去重，如果有的话 //while目的是为了：且不重复的三元组。 //如果可以有重复的三元组，则把这两个while注释掉。 //实际测试虽然也不太能保留所有重复的三元组，不过应该是left++;right--;同时收缩的缘故 while(leftright nums[left] == nums[left+1]) left++; cout left = left endl; while(leftright nums[right] == nums[right-1]) right--; cout right = right endl; left++;right--; return result; ; 语法小计 该题没有语法小计 *","tags":["c++","三数之和"],"categories":["C++刷题笔记"]},{"title":"四数之和之2","path":"/2024/10/15/每日一刷day38四数之和/","content":"三数之和给我写崩溃了都，不过最后还是理解了双指针法。四数之和跟三数之和用的方法是一样的，基本可以完全照着抄。又可以继续重拳出击了！ 四数之和之2题目：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 = a, b, c, d n a、b、c 和 d 互不相同(互不相同指的是索引不同，并不是值不相同，即可以同时有两个2，但是这两个2不是同一个数)互不相同：a,b,c,d 都是四个不同的元素，但值可以相同。不如三数之和好理解 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。示例 1： 输入：nums [1,0,-1,0,-2,2], target 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]示例 2： 输入：nums [2,2,2,2,2], target 8 输出：[[2,2,2,2]] 解法-双指针法思路： 1. 2. 3. 复杂度： 时间复杂度： 空间复杂度： 代码： #include vector#include algorithm#include iostreamusing namespace std;class Solution public: vectorvectorint fourSum(vectorint nums, int target) vectorvectorint result; sort(nums.begin(),nums.end()); //计算nums[i]+nums[j]+nums[left]+nums[right] = target; for(int i=0;inums.size();i++) //a去重 if(i0nums[i]targetnums[i]0)return result; if(i0nums[i] == nums[i-1] )continue; for(int j=i+1;jnums.size();j++) if(ji+1 nums[j] == nums[j-1])continue; int left = j+1; int right = nums.size()-1; while(leftright) //说明right偏右了 if(nums[i]+nums[j]+nums[left]+nums[right] target) right--; else if(nums[i]+nums[j]+nums[left]+nums[right] target) //说明left偏左了 left++; else if(nums[i]+nums[j]+nums[left]+nums[right] == target) //说明找到了 result.push_back(vectorintnums[i],nums[j],nums[left],nums[right]); //去重 while(leftrightnums[left]==nums[left+1])left++; while(leftrightnums[right]==nums[right-1])right--; left++;right--; return result; ;int main(int argc, char const *argv[]) Solution solution; vectorint nums1 = -1,0,-5,-2,-2,-4,0,1,-2; //vectorvectorint expected1 = -1, -1, 2, -1, 0, 1; vectorvectorint result1 = solution.fourSum(nums1,-9); //遍历二维数组 for (int i = 0; i result1.size(); i++) for (int j = 0; j result1[i].size(); j++) cout result1[i][j] ; cout endl; return 0; 语法小计 该题没语法小计 *","tags":["c++","四数之和"],"categories":["C++刷题笔记"]},{"title":"翻转字符串里的单词","path":"/2024/10/15/每日一刷day40翻转字符串里的单词/","content":"翻转字符串里的单词 翻转字符串里的单词题目：给定一个字符串，逐个翻转字符串中的每个单词。解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。你可以按 任意顺序 返回答案 。示例 1： 输入：” the sky is blue “ 输出：”blue is sky the”示例 2： 输入：” hello world! “ 输出：”world! hello”示例 3： 输入: “a good example” 输出: “example good a” 解法-双指针法思路：以 the sky is blue 为例 移除多余空格the sky is blue 反转整个字符串eulb si yks eht 将每个单词反转blue is sky the 复杂度： 时间复杂度： 空间复杂度： 代码： class Solution public: //反转,闭区间 void reverse(string s,int start,int end) int slow = start,fast = end; while(slow fast) swap(s[slow++],s[fast--]); //去除多余空格 void removeExtraSpaces(string s) //去除首空格 int slow = 0,fast = 0; while(s[fast] == ) fast++; //去除中间空格 for(;fast s.size();fast++) if(s[fast] == s[fast-1] == s[fast]) //说明此处是多余空格，跳过,fast++ continue; else s[slow]=s[fast]; slow++; //去除尾空格,因为去除中间空格时，可能会出现最后一个字符是空格的情况 if(s[slow-1] == ) s.resize(slow-1); else//更新新的字符串长度 s.resize(slow); //反转字符串里的单词 string reverseWords(string s) //去除多余空格 removeExtraSpaces(s); // //反转整个字符串,反转后的字符串首尾都是字母 reverse(s,0,s.size()-1); //将每个单词反转 int begin = 0; for(int i = 0;is.size();++i) if(s[i] == ) reverse(s,begin,i-1); begin = i+1; //单独处理最后一个字母 reverse(s,begin,s.size()-1); return s; ; 语法小计 该题没语法小计 *","tags":["c++","翻转字符串里的单词"],"categories":["C++刷题笔记"]},{"title":"stack实现queue","path":"/2024/10/14/stack实现queue/","content":"class MyQueue {public: stack stIn;输入栈 stack stOut;输出栈 MyQueue() { } void push(int x) { stIn.push(x); } int pop() { //如果输出栈为空，则将输入栈的元素全部弹出并压入输出栈 if(stOut.empty()){ while (!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } //查看队列的第一个元素 int peek() { int ret = this-pop();//使用已有的pop函数，弹出栈顶元素 stOut.push(ret);//再将弹出的元素压入stOut栈中 return ret; } bool empty() { return stIn.empty() stOut.empty(); } };","tags":["c++","stack","queue"],"categories":["C++刷题笔记"]},{"title":"救赎金","path":"/2024/10/14/每日一刷day36/","content":"救赎金题目：救赎金给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 解法-数组哈希表思路： 定义record[26]数组，用于记录每个字母出现的次数 统计r中每个字母出现的次数，记录record对应的位置上，实现方式为record递增 统计m中每个字母出现的次数，实现方式为：record对应位置上递减 遍历record[26]，只要有record[i]0,则说明m中的元素r中没有或比r中多，返回false 如果record[26]所有的值都0,则说明r可以从m中挑选字母组成（r中的字母m中都有，并且m中可以比r中多），符合题意！ 复杂度： 时间复杂度： 空间复杂度： 代码： class Solution public: bool canConstruct(string r, string m) //用于记录每个字母出现的次数 int record[26] = 0; //记录r字符串中每个字母出现的次数 for(int i = 0;i r.length();i++) record[r[i] - a]++; //将r对应位置的次数递减 for(int i = 0;i m.length();i++) record[m[i] - a]--; for(int i = 0;i 26;i++) //如果record有位置大于0，说明m中的元素r中没有或比r中多，返回false if(record[i]0)return false; return true; ; 语法小计 该题没有语法小计 *","tags":["c++","救赎金"],"categories":["C++刷题笔记"]},{"title":"反转字符串","path":"/2024/10/14/每日一刷day39/","content":"反转字符串题目：反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。示例 1： 输入：s [“h”,”e”,”l”,”l”,”o”] 输出：[“o”,”l”,”l”,”e”,”h”]示例 2： 输入：s [“H”,”a”,”n”,”n”,”a”,”h”] 输出：[“h”,”a”,”n”,”n”,”a”,”H”] 解法-思路：为什么还有这么这样的题目啊？ 为什么我刚开始刷leetcode的时候遇到的题这么难，直接给我劝退呢？ 为什么要如此戏耍我！🤯复杂度： 时间复杂度： 空间复杂度：代码： void reverseString(vectorchar s) char temp; for(int i = 0;i s.size()/2;i++) temp = s[i]; s[i] = s[s.size()-1-i]; s[s.size()-1-i] = temp;","tags":["c++","反转字符串"],"categories":["C++刷题笔记"]},{"title":"吐槽","path":"/2024/10/14/每日一刷之抱怨/","content":"真的没有头绪….烦死了 烦死了","tags":["c++","吐槽"],"categories":["C++刷题笔记"]},{"title":"快乐数","path":"/2024/10/12/每日一刷day33/","content":"题目：快乐数:19 解法-哈希表思路： 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class Solutionprivate: /* data */public: int getSum(int n) int sum = 0; int temp = 0; while (n 0) temp = n % 10; temp *= temp; sum += temp; n/=10; return sum; bool isHappy(int n) unordered_setint record; int sum = 0; while(1) sum = getSum(n); if(n==1)return true; if(record.find(sum) != record.end()) //如果sum在record里面找到了，说明陷入了循环，直接返回false return false; else record.insert(sum); n=sum; std::coutsum= sumstd::endl; //return true; ; 语法小点： 1. * * *2. * * *","tags":["c++","快乐数"],"categories":["C++刷题笔记"]},{"title":"两个数组的交集","path":"/2024/10/12/每日一刷day32/","content":"字母异位词题目：两个数组的交集 解法-哈希表思路： 将Num1存储在set容器nums_set中，可以去重 遍历num2,如果Nums_set中有num2，则将num2插入到result_set中 复杂度： 时间复杂度： 空间复杂度： 代码： #includeiostream#includevector#includeunordered_setusing namespace std;class Solution public: vectorint intersection(vectorint nums1, vectorint nums2) unordered_setint result_set; // 存放结果，之所以用set是为了给结果集去重 //通过传递 nums1.begin() 和 nums1.end()， //可以将 nums1 中的所有元素一次性插入到 unordered_set 中，从而快速构建集合。 //unordered_set 自动去除重复元素，因此可以确保最终集合中没有重复项。 unordered_setint nums_set(nums1.begin(), nums1.end()); // 遍历nums2 for (int num : nums2) // 发现nums2的元素 在nums_set里又出现过 if (nums_set.find(num) != nums_set.end()) result_set.insert(num); return vectorint(result_set.begin(), result_set.end()); ; 语法小点： unordered_set 数据结构：基于哈希表 无序存储 去重 set(ordered_set) 数据结构：基于红黑树 有序存储：元素按照升序排序 去重 解释：unordered_setint nums_set(nums1.begin(), nums1.end()); nums1.begin()：返回指向nums1向量中第一个元素的迭代器 nums1.end()：返回指向nums1向量中最后一个元素下一个位置的迭代器 将nums1向量中的所有元素插入到一个无序集合nums_set中，用于去除重复元素并提供快速查找。 解释： for (int num : nums2) for循环用于遍历名为nums2的容器中的每个元素。循环变量num依次取nums2中的每一个值。通常用于对nums2中的每个元素执行相同的操作。 解释： if (nums_set.find(num) != nums_set.end()) { result_set.insert(num); } nums_set.find(num):这个方法会在 nums_set 中查找是否存在值为 num 的元素。查找成功会返回一个指向该元素的迭代器；查找失败会返回 nums_set.end()，表示查找未找到该元素。 nums_set.find(num) ! nums_set.end()：这个条件判断返回的迭代器是否等于 nums_set.end()。 如果不等于nums_set.end()，说明找到了 num，即 nums_set 中存在 num。 如果等于 nums_set.end()，说明没有找到 num，即 nums_set 中不存在 num。","tags":["c++","两个数组的交集"],"categories":["C++刷题笔记"]},{"title":"两数之和","path":"/2024/10/12/每日一刷day34/","content":"两数之和题目：求两数之和 解法-哈希表思路： 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class Solutionprivate: /* data */public: vectorint twoSum(vectorint nums, int target) unordered_mapint,int record; for(int i = 0;inums.size();i++) auto iter = record.find(target-nums[i]); if(iter != record.end()) //找到了 //返回值，和索引 return iter-second,i; else record.insert(nums[i],i); return ; ; 语法小点： map迭代器的使用： 迭代器 iter 指向映射中的一个元素，我一直理解为一个指针，暂时没有出现问题 iter-first 访问的是键（key）部分。 iter-second 访问的是值（value）部分 解释：return {iter-second,i}; 将迭代器 iter-second 和 i 封装成一个“数组”，并返回，先暂时这样理解！","tags":["c++","两数之和"],"categories":["C++刷题笔记"]},{"title":"四数之和","path":"/2024/10/12/每日一刷day35/","content":"四数之和题目：四数之和 解法-哈希表思路：只要找到A[i] + B[j] + C[k] + D[l] 0就可以，不用考虑有重复的四个元素相加等于0的情况 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 定义int变量count，用来统计 a+b+c+d 0 出现的次数 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来 最后返回统计值 count 就可以了 复杂度： 时间复杂度： 空间复杂度： 代码： #include vector#include unordered_map#include iostreamusing namespace std;class Solution public: int fourSumCount(vectorint A, vectorint B, vectorint C, vectorint D) unordered_mapint, int umap; //key:a+b的数值，value:a+b数值出现的次数 // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中 //注意：umap初始值为空，所以umap[a+b]++是1，如果再次出现相同的a+b，那么umap[a+b]++就是2 for (int a : A) for (int b : B) umap[a + b]++; cout a=ab=bumap[ a+b] = umap[a+b]endl; //遍历umap for(auto i:umap) couti.first=i.first i.second=i.secondendl; int count = 0; // 统计a+b+c+d = 0 出现的次数 // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。 for (int c : C) for (int d : D) //如果在umap中找到0-(c+d)这个key，那么就把对应的value也就是出现次数统计出来 if (umap.find(0 - (c + d)) != umap.end()) count += umap[0 - (c + d)]; return count; ;// 单元测试int main() Solution solution; vectorint A = 1, 2; vectorint B = -2, -1; vectorint C = -1, 2; vectorint D = 0, 2; int result = solution.fourSumCount(A, B, C, D); cout The count of four sum is: result endl; // 应输出 2 return 0; 语法小点： 解释：umap[a + b]++; umap初始值为空，所以umap[a+b]++是1，如果再次出现相同的a+b，那么umap[a+b]++就是2 **","tags":["c++","四数之和"],"categories":["C++刷题笔记"]},{"title":"poll笔记","path":"/2024/09/30/poll笔记/","content":"POLL笔记函数原型#include poll.hint poll(struct pollfd *fds, nfds_t nfds, int timeout); 参数： fds：一个pollfd结构体数组指针，用于描述需要等待的事件，每个数组中包含一个文件描述符 nfds：fd 数组的大小，即需要等待的事件的数量 timeout：等待事件发生的时间，以毫秒为单位。如果为 -1，表示一直等待，直到有事件发生。如果为 0，表示不阻塞，立即返回。 返回值：如果有事件发生，返回值为正数，表示有多少个文件描述符发生了事件，超时则返回0，错误返回值为 -1。 struct pollfd的结构体： struct pollfd　int fd； // 文件描述符　short event；// 请求的事件　short revent；// 返回的事件 fd:要监视的文件描述符，如果fd无效的话那么events监视事件也无效，并且revents返回0. event:表示要监视的事件，可以监视的事件如下(不全)： 事件名 描述 POLLIN 输入数据可读 POLLOUT 输出缓冲区有空闲空间，可以写入数据 POLLHUP 有指定的文件描述符挂起 POLLPRI 输入数据有紧急数据可读（比如带外数据） POLLNVAL 无效的文件描述符 POLLRDNORM 同 POLLIN revents :返回的事件，由linux内核设置具体的返回事件 使用 poll 函数来等待标准输入（键盘输入）和一个文件描述符的变化 初始化 pollfd 结构体： fds[0] 用于标准输入（STDIN_FILENO），关心可读事件（POLLIN）。 fds[1] 用于打开的文件描述符，也关心可读事件（POLLIN）。 调用 poll 函数： 使用 while (1) 循环来持续调用 poll，以便持续监测文件描述符的状态。 poll(fds, 2, 5000) 表示等待 fds 数组中的两个文件描述符在 5000 毫秒内变得可读。 如果返回值为 -1，表示发生错误。 如果返回值为 0，表示超时。 如果返回值为正数，表示有文件描述符发生了事件。 处理事件： 检查 fds[0].revents 和 fds[1].revents，判断哪些文件描述符发生了事件。 如果文件描述符可读，读取数据并打印。 如果文件描述符对端关闭连接或发生错误，打印相应的信息。 完整代码#include stdio.h#include stdlib.h#include unistd.h#include poll.h#include fcntl.h#include string.h#include errno.hint main() struct pollfd fds[2]; int ret; char buffer[1024]; // 初始化 pollfd 结构体 fds[0].fd = STDIN_FILENO; // 标准输入 fds[0].events = POLLIN; // 关心可读事件 // 打开一个文件 fds[1].fd = open(example.txt, O_RDONLY); if (fds[1].fd == -1) perror(open); return -1; fds[1].events = POLLIN; // 关心可读事件 // 调用 poll 函数 while (1) ret = poll(fds, 2, 5000); // 等待 5000 毫秒 if (ret == -1) perror(poll); close(fds[1].fd); return -1; else if (ret == 0) printf(poll 超时 ); else // 当输入内容后，按下回车，就会有事件发生，并且输出标准输入的内容 if (fds[0].revents POLLIN) printf(标准输入可读 ); ssize_t bytes_read = read(STDIN_FILENO, buffer, sizeof(buffer) - 1); if (bytes_read 0) buffer[bytes_read] = \\0; // 确保字符串以 null 结尾 printf(读取到: %s , buffer); // 将文件描述符从可读改为不可读，当解开注释后，输入内容就会将文件描述符变为不可读 // fds[1].events = 0; // 不关心任何事件 if (fds[1].revents POLLIN) printf(文件描述符可读 ); //每次更新example.txt中的内容后才会输出example.txt的内容 ssize_t bytes_read = read(fds[1].fd, buffer, sizeof(buffer) - 1); if (bytes_read 0) buffer[bytes_read] = \\0; // 确保字符串以 null 结尾 printf(从文件读取到: %s , buffer); if (fds[0].revents POLLHUP) printf(标准输入对端关闭连接 ); if (fds[1].revents POLLHUP) printf(文件描述符对端关闭连接 ); if (fds[0].revents POLLERR) printf(标准输入发生错误 ); if (fds[1].revents POLLERR) printf(文件描述符发生错误 ); sleep(1); close(fds[1].fd); return 0;","tags":["poll"],"categories":["嵌入式"]},{"title":"poll笔记深入","path":"/2024/09/30/poll笔记深入/","content":"POLL笔记深入参考韦东山： poll函数执行流程poll函数执行流程： 函数执行流程如上图①～⑧所示，重点从③开始看。假设一开始无按键数据： ③ APP调用poll之后，进入内核态； ④ 导致驱动程序的drv_poll被调用： 注意，drv_poll要把自己这个线程挂入等待队列wq中；假设不放入队列里，那以后- 发生中断时，中断服务程序去哪里找到你嘛？ drv_poll还会判断一下：有没有数据啊？返回这个状态。 ⑤ 假设当前没有数据，则休眠一会； ⑥ 在休眠过程中，按下了按键，发生了中断： 在中断服务程序里记录了按键值，并且从wq中把线程唤醒了。 ⑦ 线程从休眠中被唤醒，继续执行for循环，再次调用drv_poll： drv_poll返回数据状态 ⑧ 哦，你有数据，那从内核态返回到应用态吧 ⑨ APP调用read函数读数据 如果一直没有数据，调用流程也是类似的，重点从③开始看，如下： ③ APP调用poll之后，进入内核态； ④ 导致驱动程序的drv_poll被调用： 注意，drv_poll要把自己这个线程挂入等待队列wq中；假设不放入队列里，那以后发生中断时，中断服务程序去哪里找到你嘛？ drv_poll还会判断一下：有没有数据啊？返回这个状态。 ⑤ 假设当前没有数据，则休眠一会； ⑥ 在休眠过程中，一直没有按下了按键，超时时间到：内核把这个线程唤醒； ⑦ 线程从休眠中被唤醒，继续执行for循环，再次调用drv_poll： drv_poll返回数据状态 ⑧ 哦，你还是没有数据，但是超时时间到了，那从内核态返回到应用态吧 ⑨ APP不能调用read函数读数据 注意几点： ① drv_poll要把线程挂入队列wq，但是并不是在drv_poll中进入休眠，而是在调用drv_poll之后休眠 ② drv_poll要返回数据状态 ③ APP调用一次poll，有可能会导致drv_poll被调用2次 ④ 线程被唤醒的原因有2：中断发生了去队列wq中把它唤醒，超时时间到了内核把它唤醒 ⑤ APP要判断poll返回的原因：有数据，还是超时。有数据时再去调用read函数。 驱动使用poll机制时，驱动程序的核心就是提供对应的drv_poll函数。 在drv_poll函数中要做2件事： ① 把当前线程挂入队列wq：poll_wait APP调用一次poll，可能导致drv_poll被调用2次，但是我们并不需要把当前线程挂入队列2次。可以使用内核的函数poll_wait把线程挂入队列，如果线程已经在队列里了，它就不会再次挂入。 ② 返回设备状态： APP调用poll函数时，有可能是查询“有没有数据可以读”：POLLIN，也有可能是查询“你有没有空间给我写数据”：POLLOUT。 所以drv_poll要返回自己的当前状态：(POLLIN | POLLRDNORM) 或 (POLLOUT | POLLWRNORM)。 POLLRDNORM等同于POLLIN，为了兼容某些APP把它们一起返回。 POLLWRNORM等同于POLLOUT ，为了兼容某些APP把它们一起返回。 完整代码 只需要看static unsigned int gpio_key_drv_poll(struct file *fp, poll_table * wait)这一部分即可 #include linux/module.h#include linux/poll.h#include linux/fs.h#include linux/errno.h#include linux/miscdevice.h#include linux/kernel.h#include linux/major.h#include linux/mutex.h#include linux/proc_fs.h#include linux/seq_file.h#include linux/stat.h#include linux/init.h#include linux/device.h#include linux/tty.h#include linux/kmod.h#include linux/gfp.h#include linux/gpio/consumer.h#include linux/platform_device.h#include linux/of_gpio.h#include linux/of_irq.h#include linux/interrupt.h#include linux/irq.h#include linux/slab.hstruct gpio_key\tint gpio;\tstruct gpio_desc *gpiod;\tint flag;\tint irq; ;static struct gpio_key *gpio_keys_100ask;/* 主设备号 */static int major = 0;static struct class *gpio_key_class;/* 环形缓冲区 */#define BUF_LEN 128static int g_keys[BUF_LEN];static int r, w;#define NEXT_POS(x) ((x+1) % BUF_LEN)static int is_key_buf_empty(void)\treturn (r == w);static int is_key_buf_full(void)\treturn (r == NEXT_POS(w));static void put_key(int key)\tif (!is_key_buf_full()) g_keys[w] = key; w = NEXT_POS(w);\tstatic int get_key(void)\tint key = 0;\tif (!is_key_buf_empty()) key = g_keys[r]; r = NEXT_POS(r); return key;static DECLARE_WAIT_QUEUE_HEAD(gpio_key_wait);/* 实现对应的open/read/write等函数，填入file_operations结构体 */static ssize_t gpio_key_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)\t//printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);\tint err;\tint key; wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());\tkey = get_key();\terr = copy_to_user(buf, key, 4); return 4;static unsigned int gpio_key_drv_poll(struct file *fp, poll_table * wait)\t//调用一次poll可能会调用两次drv_poll\tprintk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);\t//执行poll_wait并不会休眠\tpoll_wait(fp, gpio_key_wait, wait);\treturn is_key_buf_empty() ? 0 : POLLIN | POLLRDNORM;/* 定义自己的file_operations结构体 */static struct file_operations gpio_key_drv = .owner = THIS_MODULE,\t.read = gpio_key_drv_read,\t.poll = gpio_key_drv_poll,;static irqreturn_t gpio_key_isr(int irq, void *dev_id)\tstruct gpio_key *gpio_key = dev_id;\tint val;\tint key; val = gpiod_get_value(gpio_key-gpiod); printk(key %d %d , gpio_key-gpio, val);\tkey = (gpio_key-gpio 8) | val;\tput_key(key);\twake_up_interruptible(gpio_key_wait); return IRQ_HANDLED;/* 1. 从platform_device获得GPIO * 2. gpio=irq * 3. request_irq */static int gpio_key_probe(struct platform_device *pdev)\tint err;\tstruct device_node *node = pdev-dev.of_node;\tint count;\tint i;\tenum of_gpio_flags flag; printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__);\tcount = of_gpio_count(node);\tif (!count) printk(%s %s line %d, there isnt any gpio available , __FILE__, __FUNCTION__, __LINE__); return -1; gpio_keys_100ask = kzalloc(sizeof(struct gpio_key) * count, GFP_KERNEL);\tfor (i = 0; i count; i++) gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, flag); if (gpio_keys_100ask[i].gpio 0) printk(%s %s line %d, of_get_gpio_flags fail , __FILE__, __FUNCTION__, __LINE__); return -1; gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio); gpio_keys_100ask[i].flag = flag OF_GPIO_ACTIVE_LOW; gpio_keys_100ask[i].irq = gpio_to_irq(gpio_keys_100ask[i].gpio); for (i = 0; i count; i++) err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, 100ask_gpio_key, gpio_keys_100ask[i]); /* 注册file_operations */\tmajor = register_chrdev(0, 100ask_gpio_key, gpio_key_drv); /* /dev/gpio_key */\tgpio_key_class = class_create(THIS_MODULE, 100ask_gpio_key_class);\tif (IS_ERR(gpio_key_class)) printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, 100ask_gpio_key); return PTR_ERR(gpio_key_class); device_create(gpio_key_class, NULL, MKDEV(major, 0), NULL, 100ask_gpio_key); /* /dev/100ask_gpio_key */ return 0; static int gpio_key_remove(struct platform_device *pdev)\t//int err;\tstruct device_node *node = pdev-dev.of_node;\tint count;\tint i;\tdevice_destroy(gpio_key_class, MKDEV(major, 0));\tclass_destroy(gpio_key_class);\tunregister_chrdev(major, 100ask_gpio_key);\tcount = of_gpio_count(node);\tfor (i = 0; i count; i++) free_irq(gpio_keys_100ask[i].irq, gpio_keys_100ask[i]); kfree(gpio_keys_100ask); return 0;static const struct of_device_id ask100_keys[] = .compatible = 100ask,gpio_key , ,;/* 1. 定义platform_driver */static struct platform_driver gpio_keys_driver = .probe = gpio_key_probe, .remove = gpio_key_remove, .driver = .name = 100ask_gpio_key, .of_match_table = ask100_keys, ,;/* 2. 在入口函数注册platform_driver */static int __init gpio_key_init(void) int err; printk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__); err = platform_driver_register(gpio_keys_driver); return err;/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 * 卸载platform_driver */static void __exit gpio_key_exit(void)\tprintk(%s %s line %d , __FILE__, __FUNCTION__, __LINE__); platform_driver_unregister(gpio_keys_driver);/* 7. 其他完善：提供设备信息，自动创建设备节点 */module_init(gpio_key_init);module_exit(gpio_key_exit);MODULE_LICENSE(GPL); 应用部分 在调用poll函数时，要指明： ① 你要监测哪一个文件：哪一个fd ② 你想监测这个文件的哪种事件：是POLLIN、还是POLLOUT ③ 在poll函数返回时，要判断状态。 完整代码 #include sys/types.h#include sys/stat.h#include fcntl.h#include unistd.h#include stdio.h#include string.h#include poll.h/* * ./button_test /dev/100ask_button0 * */int main(int argc, char **argv)\tint fd;\tint val;\tstruct pollfd fds[1];\tint timeout_ms = 5000;\tint ret; /* 1. 判断参数 */\tif (argc != 2) printf(Usage: %s dev , argv[0]); return -1; /* 2. 打开文件 */\tfd = open(argv[1], O_RDWR);\tif (fd == -1) printf(can not open file %s , argv[1]); return -1; fds[0].fd = fd;\tfds[0].events = POLLIN; while (1) /* 3. 读文件 */ //根据poll的返回值，判断是否有数据可读 ret = poll(fds, 1, timeout_ms); if ((ret == 1) (fds[0].revents POLLIN)) read(fd, val, 4); printf(get button : 0x%x , val); else printf(timeout ); close(fd); return 0; poll机制 从应用程序中的poll调用，最终会一步一步得调用到do_poll函数，具体流程； poll - drv_poll - sys_poll - do_sys_poll - do_poll do_poll ① 从这里开始，将会导致驱动程序的poll函数被第一次调用。 沿着②③④⑤，你可以看到：驱动程序里的poll_wait会调用__pollwait函数把线程放入某个队列。 当执行完①之后，在⑥或⑦处，pt-_qproc被设置为NULL，所以第二次调用驱动程序的poll时，不会再次把线程放入某个队列里。 ⑧ 如果驱动程序的poll返回有效值，则count非0，跳出循环； ⑨ 否则休眠一段时间；当休眠时间到，或是被中断唤醒时，会再次循环、再次调用驱动程序的poll。 回顾APP的代码，APP可以指定“想等待某些事件”，poll函数返回后，可以知道“发生了哪些事件”： 驱动程序里怎么体现呢？在上上一个图中，看②位置处，细说如下： 参考链接 http://blog.chinaunix.net/uid-30592332-id-5599907.html https://cloud.tencent.com/developer/article/1708996","tags":["poll"],"categories":["嵌入式"]},{"title":"小杜的重庆之行","path":"/2024/09/29/小杜的重庆之行/","content":"小杜的重庆之行 出发时间 抵达时间 2024年9月30日 15:06 2024年10月1日 15:43 Day1 地点 注意 门票 解放碑（抗战胜利的纪念碑） 注意拍摄角度 带墨镜 免费 山城书店（爱心书店 ） 注意拍摄角度图 免费 八一好吃街（特色美食） 吃什么 自费的， 罗汉寺 拍照打卡点 20元 day 2 地点 注意 门票 白象居 可以拍长江索道 湖广会馆 拍照出片 （25元） 长江索道 （提前预约） 25-30元 十八梯 出片 南滨路 （夜景） day3 地点 攻略 戴家巷 出片 来福士 大商场 朝天门 （两江交汇） 洪崖洞 夜景 千厮门大桥 （拍洪崖洞全景） day4 地点 注意 门票 开埠遗址公园 （重庆文化） 龙门浩老街 （爬坡，） 怀旧轮渡 （15元） 弹子石老街 （中式庭院） 南山一颗树 （美景） day5 地点 攻略 鹅岭二厂 （废弃共厂改造） 鹅岭公园 （文艺照片） 李子坝 （轻轨） 北仓文创院 （文艺片） 观音桥 （地标） day6 地点 攻略 磁器口 （古镇） 白公馆 渣滓洞 罗中立美术馆 马房湾七彩巷 day7 地点 注意 门票 重庆动物园 （，四喜丸子） 25元 钟书阁 （ 哈利波特书屋） 涂鸦一条街 交通茶馆 王源同款茶 10 黄桷娅老街 安逸喔~ 接下来是要去预约的景点~ 需要预约的景点 放票时间 票价 特色 长江索道 每天7；15放票 罗中立美术馆（四川美院美术馆） 有名额限制 重庆三峡博物馆 （重庆中国山峡博物馆） 预约成功（周三）周一闭馆 南山一棵树：“重庆南山植物馆” 门票30 湖广会馆 怀旧轮渡（重庆两江交运） 15 （ 大美重庆 ） 人民大礼堂 “重庆市人民大礼堂” 一下可预约两天 周一闭关 8元 接下来是一些好吃的！ 美食 特点 朝天门天桥滑肉 一只酸奶牛 （茶话弄） 歌乐山辣子鸡 看着特别辣，有百十块的 春红火锅 买券了150多 南山有烧烤 200多，贵在景色 都没听过呢~ 开始期待… 心情多云转晴了","tags":["重庆","旅行"],"categories":["旅行"]},{"title":"gcc的四个过程","path":"/2024/09/24/gcc的四个过程/","content":"gcc四个过程CC++通过gccg++编译器包括以下四个过程：预处理，编译，汇编，链接 预处理(preprocess)预处理可以理解为将#里边的内容展开，包括宏定义，头文件路径等等，然后直接插入到程序里边去。预处理通过预处理器将.c文件转换成.i文件。预处理阶段不会检查语法错误 编译(compile)编译是通过编译器(ccl)将.i文件转换为汇编代码文件，一般是.s文件。在编译阶段会进行语法分析等 汇编(assemble)汇编器(as)将.s文件翻译成二进制机器语言指令（二进制机器码），生成.o文件。 链接(link)链接器(ld)将上述产生的一堆文件还有各种库通过某种方式链接起来，生成.out(.exe)文件 以上都是自己理解","tags":["c++","笔记"],"categories":["C++"]},{"title":"rosAPI","path":"/2024/09/24/rosAPI/","content":"ROS API init 函数 //有3个重载，常用以下void ros::init(int argc, char **argv, const std::string name, uint32_t options = 0U) 作用： 初始化ROS系统，并创建一个节点，节点名称为name argc 参数个数 argv 参数数组，需要符合ros的特定格式 name 节点名称，默认为argv[0]，不允许重复 options ROS中同一个节点不能重复启动，此时可以通过options选项来设置是否允许重复启动,原理是在节点名称后加上生成随机数字尾缀。使用方法：ros::init_options::AnonymousName 使用细节 发布对象 //使用示例ros::Publisher pub = nh.advertisegeometry_msgs::Twist(/turtle1/cmd_vel,1000);//函数原型inline ros::Publisher ros::NodeHandle::advertisestd_msgs::String(const std::string topic, uint32_t queue_size, bool latch = false) 作用： 创建发布者对象 模板 被发布者的消息类型 topic 话题名称 queue_size 缓存消息个数，如果满了丢弃之前的 latch 如果为ture,会保存发布方的最后一条消息，并且当新的订阅者连接到发布方时，发布方会将这条信息发送给订阅者。应用场景：静态地图 使用细节 3. 回旋函数 有回调就伴随着回旋 void ros::spin()void ros::spinOnce() 作用： 处理回调函数 spin() 是进入了循环执行回调函数，进入循环后不会自己退出，在 ros::spin() 后的语句不会执行到 spinOnce() 只会执行一次回调函数(没有循环)，ros::spinOnce() 后的语句可以执行 时刻参考系1970年1月1日0时0分0秒 ros::Time::now()//now() 返回一个ros::Time对象，表示当前时间//ros::Time::now().toSec()//ros::Time::now().sec 定时器ros::Timer timer = nh.createTimer(ros::Duration(0.5),doSomeThing,true);//只执行一次 https://support.3dsystems.com/s/article/OpenHaptics-for-Linux-Developer-Edition-v34?language=en_US","tags":["ros","笔记"],"categories":["ROS"]},{"title":"搭建博客参考过的链接","path":"/2024/09/22/搭建博客参考过的链接/","content":"https://yuanlichenai.cn/2020/02/02/chic/https://blog.csdn.net/QFREX/article/details/108798945https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.clickhttps://did321.gitee.io/","tags":["hexo","搭建博客","blog"],"categories":["搭建博客"]},{"title":"图床链接格式测试","path":"/2024/09/20/图床链接格式测试/","content":"本地文件名：【雪】2024-09-20 23_57_02.pnggithub文件名：https://github.com/dkyou/ImageHostingdku/blob/main/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png https://github.com/dkyou/ImageHostingdku/blob/main/img/【雪】2024-09-20%2023_57_02.png 复制markdown 复制HTML 复制URLhttps://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png 复制UBB[IMG]https://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png[/IMG] 复制customhttps://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/【雪】2024-09-20 23_57_02.png 自己常用格式：","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"搭建图床笔记","path":"/2024/09/20/搭建图床笔记/","content":"图床准备工作 github账号注册：必须，但省略 下载PicGo,链接如下：必须 ​\thttps://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/ typora软件：非必须，最好有。也可找其他mrakdown代替，比如我使用的vscode+Markdown All in One 图床是什么图床可以翻译为”image hosting”或者”image storage”，主要功能包括： 图片上传：用户可以将图片上传到图床平台。 图片存储：平台会存储用户的图片，并提供一定的管理和访问权限。 图片分享：用户可以获得图片的直接链接，并通过这些链接在其他网站、论坛、社交媒体等地方分享图片。 图片管理：用户可以在图床上管理自己的图片，包括查看、编辑、删除等操作。 国内常见的图床服务 七牛云 阿里云oss 又拍云 之前我一直将图片上传到七牛云，但是七牛云的免费域名只有30天，到期了有需要重新申请，解决方案是自己申请一个域名，便可以长期使用七牛云的免费空间额度进行图床搭建。个人实在不想折腾，于是选择了github的搭建方案，相比于其他国内的搭建方案，步骤可谓非常简单，而且不限制容量。 网上查了一些攻略说github搭建图床的缺点是访问速度慢，但是仔细一想，我的笔记写来是给自己看的，对速度没有要求。 使用github搭建图床思路：其实很简单，就是在github上建立一个public的仓库，然后使用该仓库作为图床服务器存储 1. 创建新仓库默认 仓库名随意，一定设置为public 2. 生成token令牌setting-Developer Settings-Personal access tokens-Tokens(classic)-Generate new token(classic) 然后创建tokens即可，这个步骤可能让你验证账号之类的，接下来就是一些token的设置如下： **note：**随便填写，没有影响 **expiration：**也可以随便填写，可以填永久，也可以按照自己的需求填写，我目前还不知道到期了有什么影响2024年10月14日更新：实测7天过期之后只需要重新生成即可，不需要进行任何多余的操作，十分简单。因此，不建议永久有效。 **select scopes:**勾选repo前边的选项 具体设置见下图： 其他设置全部默认，然后拉到最后点击蓝色的Generate Tokes等待生成即可 注意：生成的token记得复制备份，之后的PicGo设置需要用到 PicGo来实现图片上传PicGo是方便我们进行图片上传的，而且方便我们对图片进行管理。 下载地址：https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/ 1. PicGo设置：选择：图床设置-Github，然后进行核心配置 **设定仓库名：**格式为用户名/仓库名直接复制下方红框中的内容也可。 **设定分支名：**一般为main或者master，具体需要看自己的设置 设置token：就是github搭建图床生成的token 设定存储路径：img/可根据自己喜好填写即可 **自定义域名：**这个需要一个免费的加速域名，可以直接用https://cdn.jsdelivr.net/gh/,或者自己申请一个。 具体格式为：加速域名+账户名+仓库名/分支名，中间+号不用填写，举例： https://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku 以上便完成了PicGo的所有设置，详情见下图： 之后，可以返回上传区域，直接上传即可，也可以把github设置为默认图床 2. 使用PicGo上传图片到github仓库拖拽即可，非常简单 3. 引用PicGo的链接到typora中进行测试点击复制即可得到以下markdown格式的图片链接，插入到markdown中即可解析出图片 ![](https://cdn.jsdelivr.net/gh/dkyou/ImageHostingdku/img/%E3%80%90%E9%9B%AA%E3%80%912024-09-20%2023_57_02.png)` 当然也可以选择HTML URL等等其他格式的链接，非常灵活 4. 测试结果 设置Typora实现插入到typora的图片自动上传到图床前提：开启代理 打开typora，依次点击：文件-偏好设置-图像。选择 上传服务，设置一下picgo和picgo路径。比较简单，就不贴图了。 这样之后插入到Typora的图片就会自动上传到github仓库里了 批量转移图床这里只是记录一下批量转移图床的思路，具体我还没有遇到过，但是我感觉我很有可能以后会遇到。 简单思路：使用vscode或者typora的批量替换功能可以实现图片关键信息链接的替换，vscode似乎可以替换多个文件。 参考链接 如何用github搭建图床（亲测有效）_github图床-CSDN博客 2024新版-使用GitHub搭建个人图床-CSDN博客","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"搭建博客","path":"/2024/09/20/网上一些主题推荐/","content":"Stellar 主题 https://xaoxuu.com/wiki/stellar/#startSolitude 主题 https://solitude.js.org/config/basic https://blog.everfu.cn/https://blog.lixiaomu.fun/posts/43857/ 16 款精美的 hexo 博客主题推荐 https://pengtech.net/hexo/hexo_theme_recommendation.html#5-Stellar-%E4%B8%BB%E9%A2%98 更新主题截止到2024年12月25日，我所使用的主题是 Stellar 稳定版 安装方法： 进入myblog目录，执行 npm i hexo-theme-stellar 在myblog_config.yml文件中修改为： theme: stellar 更新方法： 进入myblog目录，执行： npm i hexo-theme-stellar 以上内容更新时间为：2024年12月25日","tags":["hexo","搭建博客","主题"],"categories":["搭建博客"]},{"title":"LVGL","path":"/2024/09/20/LVGL/","content":"LVGL常用API对齐lv_obj_align和lv_obj_align_to区别 void lv_obj_align(lv_obj_t * obj, lv_align_t align, int32_t x_ofs, int32_t y_ofs) 功能：将对象obj对齐到其父对象参数：obj：要对齐的对象 align：对齐方式 x_ofs：x轴偏移 y_ofs：y轴偏移 void lv_obj_align_to(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, int32_t x_ofs, int32_t y_ofs)功能：将对象obj对齐到指定的基准对象base参数：obj：要对齐的对象 base：基准对象 align：对齐方式 x_ofs：x轴偏移 y_ofs：y轴偏移 区别：lv_obj_align 是将对象对齐到其父对象。lv_obj_align_to 是将对象对齐到指定的基准对象 base，灵活性更高","tags":["嵌入式","LVGL"],"categories":["LVGL"]},{"title":"hexo+github搭建博客笔记","path":"/2024/09/20/hexo+github搭建博客笔记/","content":"hexo+github搭建博客笔记1. 软件安装和使用1.Git 查看是否成功安装 git version 绑定git邮箱和git用户，命令如下： git config --global user.name dkyou #输入git不需要双引号git config --global user.email 2323@xx.com 2.安装NodeJS 2.1 NodeJS 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 IO 的模型，使其轻量又高效。 简单的说 Node.js 就是运行在服务端的 JavaScript，利用JavaScript在服务端进行编程。 关于NodeJS是什么可以参考：nodejs(第一篇)：nodejs是什么？ 2.2 安装并配置环境变量，可以参考：[Node.js安装及环境配置超详细教程](Node.js安装及环境配置超详细教程【Windows系统】_windows 安装nodejs-CSDN博客) 2.3 同样的，使用命令查看是否安装成功 node -vnpm -v 3.Hexo安装和设置 3.1 hexo安装命令 npm install -g hexo-cli#用于全局安装 Hexo 的命令行工具 以下是上述命令的解释： 1.npmnpm 是 Node.js 包管理器（Node Package Manager）的缩写，用于管理和安装 Node.js 应用程序的依赖包。2.installinstall 是 npm 的一个子命令，用于安装指定的包。3. -g-g 表示全局安装（global）。这意味着包将被安装到系统的全局位置，而不是项目的本地 node_modules 目录中。全局安装的包可以在系统中的任何位置使用。hexo-cli4. hexo-cli 是 Hexo 的命令行接口工具。Hexo 是一个静态站点生成器，可以用来快速生成静态博客或网站。 3.2 新建一个文件夹，例如”D:\\myblog”，不需要进入该文件夹，直接鼠标右键—Git Bash Here，依次执行以下命令 初始化myblog,即从https://github.com/hexojs/hexo-starter.git克隆文件，并且安装依赖 hexo init myBlog 进入myblog文件夹，并且执行npm install命令 cd myBlognpm install 运行hexo s命令 hexo s 根据提示，可以直接在浏览器中输入http://localhost:4000/,回车即可看到效果 这是部署在本地的默认的一篇hello world博客，使用的是默认theme: landscape主题，此时和github还没有任何关系。 2. 主题安装可从主题官网下载自己喜欢的主题：Themes | Hexo 以hexo-theme-Chic为例设置自己的主题,链接：https://github.com/Siricee/hexo-theme-Chic.git 执行git clone https://github.com/Siricee/hexo-theme-Chic.git或者直接download zip将下载的主题文件解压放在D:\\myblog\\themes文件夹中。注意文件名为hexo-theme-Chic后边没有-master和其他信息。 在D:\\myblog中找到_config.yml，使用记事本或者vscode等打开，在第100行左右找到theme: landscape，改为theme: hexo-theme-Chic。 注意：这里的_config.yml是根目录下的，即”D:\\myblog\\_config.yml”，不是D:\\myblog\\themes\\hexo-theme-Chic下的_config.yml 依次执行以下命令 hexo ghexo s 根据提示，可以直接在浏览器中输入http://localhost:4000/,回车即可看到更换主题之后的效果 themes主题文件结构： .├── _config.yml├── languages├── layout├── scripts└── source 主题配置文件设置：D:\\myblog\\themes\\hexo-theme-Chic下的_config.yml #文件位置`D:\\myblog\\themes\\hexo-theme-Chic`下的`_config.yml`# Header navname: dkus Blog //对应左上角# 对应右上角 Posts Categories Tags About# navigatior itemsnav: Posts: /archives Categories: /category Tags: /tag About: /about# favicon 浏览器网址栏显示的图标，但是不知道为什么我默认的不是favicon.ico，而是我之前设置的神里凌华的图片，有点奇怪favicon: /favicon.ico# Profile 中间显示的名字nickname: Dku### this variable is MarkDown form.# 个人描述 显示在图像下边description: Lorem ipsum dolor sit amet, **consectetur adipiscing elit.** brFusce eget urna vitae velit *eleifend interdum at ac* nisi.# 个人头像图片avatar: /image/avatar.jpeg# main menu navigation## links key words should not be changed.## Complete url after key words.## Unused key can be commented out.#常用网站的个人链接，取消注释添加即可links: Blog: /archives # Category: # Tags: # Link: # Resume: # Publish: # Trophy: # Gallery: # RSS: # AliPay: ZhiHu: https://www.zhihu.com/people/sirice # LinkedIn: # FaceBook: # Twitter: # Skype: # CodeSandBox: # CodePen: # Sketch: # Gitlab: # Dribbble: Instagram: Reddit: # YouTube: # QQ: # Weibo: # WeChat: Github: https://github.com/Siricee# how links show: you have 2 choice--text or icon.# 图标或者文字显示常用网站的个人链接links_text_enable: falselinks_icon_enable: true# Post page## Post_metapost_meta_enable: truepost_author_enable: truepost_date_enable: truepost_category_enable: true## Post copyrightpost_copyright_enable: truepost_copyright_author_enable: truepost_copyright_permalink_enable: truepost_copyright_license_enable: truepost_copyright_license_text: Copyright (c) 2019 a href=http://creativecommons.org/licenses/by-nc/4.0/CC-BY-NC-4.0/a LICENSEpost_copyright_slogan_enable: truepost_copyright_slogan_text: Do you believe in strongDESTINY/strong?## tocpost_toc_enable: true# Pagepage_title_enable: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/#日期格式date_format: MMMM D, YYYYtime_format: H:mm:ss# stylesheets loaded in the headstylesheets: - /css/style.css# scripts loaded in the end of the bodyscripts: - /js/script.js - /js/tocbot.min.js # tscanlin/tocbot: Build a table of contents from headings in an HTML document. # https://github.com/tscanlin/tocbot# plugin functions## Mathjax: Math Formula Support## https://www.mathjax.orgmathjax: enable: true import: demand # global or demand ## global: all pages will load mathjax,this will degrade performance and some grammers may be parsed wrong. ## demand: Recommend option,if your post need fomula, you can declare mathjax: true in Front-matter 更改完D:\\myblog\\themes\\hexo-theme-Chic下的_config.yml配置文件之后，可以依次执行hexo g hexo s根据提示，在浏览器中输入http://localhost:4000/,回车即可看到设置主题之后的效果 可以设置的东西挺多，简单设置的效果 3.将hexo博客部署到github上以上，所有的设置和内容都只能显示在自己的电脑上，如何部署到github上？ 3.1 准备工作—新建仓库并设置ssh key 如果之前已经使用hexo搭建过博客，或者设置过以下内容，则无需再进行设置！如果想了解什么是ssh key及其原理，可以参考ssh_key简记，本文只讲如何操作。 新建一个github仓库，仓库名要按照：用户名.github.io设置 配置ssh key,使用git配置ssh key，命令如下 git config --global user.name dkyou #输入git不需要双引号git config --global user.email 2323@xx.comssh-keygen -t rsa -C 2323@xx.com 查看ssh cat ~/.ssh/id_rsa.pub 添加可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证实添加成功。 ssh -T git@github.com 登陆 Github 上添加刚刚生成的SSH key，按如下步骤添加，右上角点击头像- settings - SSH and GPG keys，建立一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认建立，这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。 3.2 部署 在D:\\myblog中找到_config.yml，使用记事本或者vscode等打开，找到最后几行，改为 # 文件路径：D:\\myblog\\_config.ymldeploy: type: git repo: https://github.com/dkyou/dkyou.github.io branch: master 安装 hexo-deployer-git npm install hexo-deployer-git --save 执行命令上传 hexo g #生成hexo d #上传 有时候在执行hexo d会报错，再执行一次就可以 成功的截图 接下来使用用户名.github.io即可访问部署到github上的博客 成功部署到github效果演示 4.更新文章可以使用hexo new 文章标题命令来创建一个文章标题.md文件，也可以按照格式直接将自己的.md 文件复制到D:\\myblog\\source\\_posts\\文件夹中，同时按照以下格式添加一些命令 使用hexo new 文章标题命令来创建一个文章标题.md文件 hexo new 文章标题 博客语法结构: ---title: Hello World #文章标题date: 2024-09-20 20:13:20tags: [tag1,tag2,...]categories: --- 将新文章部署到github上 hexo g # 生成，必须hexo s # 本地渲染，非必要hexo d # 部署到Github 上，必须 注意：一个主题可能有以下文件结构 .├── _config.yml├── languages├── layout├── scripts└── source 涉及到hexo d的文件 Source 文件夹。 将您的素材（如 CSS 和 JavaScript 文件）放在这里。 文件或文件夹开头名称为 _（下划线）或隐藏的文件会被忽略。 Hexo 将处理所有可渲染的文件，并将它们保存到 public 文件夹下。 不可渲染的文件将直接复制到 public 文件夹。 hexo d也会把D:\\myblog\\source_posts中的md文件上传到 public 文件夹下，如果_post的md文件被删除或者增加，则会完全覆盖github中的md文件，所以不要轻易删除_post文件夹下的md文件。 5.完结！","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"ssh_key简记","path":"/2024/09/20/ssh_key/","content":"摘要：本文是上篇《hexo+github搭建博客笔记》的一些补充。翻阅博客的时候，对本地博客怎么部署到github上，以及如何配置SSH密钥，以及如何将公钥添加到远程服务器上的原理有一些不清楚，于是作了一个笔记，记录下来。 SSH 密钥生成SSH密钥SSH 密钥用于安全地连接到远程服务器，通常用于无密码登录和身份验证。以下是如何生成和使用 SSH 密钥的步骤： 生成 SSH 密钥打开终端： 在 Linux ，打开终端。在 Windows 上，使用 Git Bash。生成 SSH 密钥对： ssh-keygen -t rsa -b 4096 -C your_email@example.com -t rsa 指定密钥类型为 RSA。 -b 4096 指定密钥长度为 4096 位。 -C “your_email@example.com“ 添加一个标签，通常是你的电子邮件地址。 保存密钥：按回车键接受默认文件位置（通常是 ~.sshid_rsa）。输入一个密码（可选）以增加安全性。查看生成的密钥生成的密钥对将保存在 ~.ssh 目录下： 私钥：id_rsa 公钥：id_rsa.pub 公钥： 加密：用于加密数据，只有对应的私钥才能解密。 签名验证：用于验证使用私钥签名的数据的正确性和完整性。 保密性：可以公开共享，通常用于添加到远程服务器的 ~.sshauthorized_keys 文件中，以便进行无密码登录。 私钥： 解密：用于解密使用公钥加密的数据。 签名：用于对数据进行签名，以证明数据的来源和完整性。 保密性：必须严格保密，不能公开。如果私钥泄露，攻击者可以冒充你进行身份验证或解密数据。 总结两者之间的关系： 公钥：添加到 GitHub 账户中，用于验证你的身份。 私钥：保存在你的本地机器上，用于解密 GitHub 发送的挑战。 将公钥添加到GitHub上 登录到你的 GitHub 账户。 进入 Settings SSH and GPG keys。 点击 New SSH key。 在 Title 中输入一个描述性的名称，例如 “My Laptop”。 在 Key 中粘贴你之前复制的公钥内容。 点击 Add SSH key。 测试 SSH 连接： ssh -T git@github.com% -T 选项：禁用伪终端分配。这使得命令的输出更简洁，更适合脚本和自动化任务。% git@github.com：指定你要连接的 GitHub 服务器和用户（git 用户）。 命令解释：简单回答：ssh -T git@github.com 是一个用于测试 SSH 连接到 GitHub 的命令。这个命令可以帮助你验证你的 SSH 密钥是否已经正确地添加到 GitHub 账户中，并且可以成功地进行身份验证。详细回答： 身份验证：当你运行 ssh -T git@github.com 时，GitHub 服务器会使用你提供的公钥来验证你的身份。具体来说，GitHub 会使用你的公钥来解密一个挑战（challenge），如果你的私钥能够成功解密这个挑战，GitHub 会认为你是合法用户。 公钥和私钥的关系：公钥和私钥是一对，公钥用于加密，私钥用于解密。当你在 GitHub 上添加公钥后，GitHub 会使用这个公钥来验证你提供的私钥是否匹配。 通过 ssh -T git@github.com 命令，你可以验证你的公钥是否已经正确添加到 GitHub 账户中，并且你的私钥是否能够成功进行身份验证 预期输出首次连接： 如果这是你第一次连接到 GitHub，系统会提示你确认 GitHub 的主机密钥指纹： The authenticity of host github.com (IP_ADDRESS) cant be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入 yes 继续连接。成功连接： 如果你的 SSH 密钥已正确添加到 GitHub 账户中，你会看到以下消息： Hi username! Youve successfully authenticated, but GitHub does not provide shell access. 其中 username 是你的 GitHub 用户名。 将公钥添加到远程服务器复制公钥： cat ~/.ssh/id_rsa.pub 复制输出的内容。将公钥添加到远程服务器：登录到远程服务器： ssh user@remote_host 创建 .ssh 目录（如果不存在）： mkdir -p ~/.ssh 将公钥添加到 authorized_keys 文件： echo your_public_key ~/.ssh/authorized_keys 设置正确的权限： chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 测试 SSH 连接退出远程服务器： exit 尝试无密码登录： ssh user@remote_host 如果一切配置正确，你应该能够无密码登录到远程服务器。 常见问题 权限问题：确保 .ssh 目录和 authorized_keys 文件的权限设置正确。 密钥密码：如果你在生成密钥时设置了密码，每次使用 SSH 连接时都需要输入该密码。可以使用 ssh-agent 来管理密钥密码： eval $(ssh-agent -s)ssh-add ~/.ssh/id_rsa 完","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"友链","path":"/2024/09/20/友链/","content":"友链创建多个友链组数据文件在 D:myblogsource_datalinks 目录下创建多个 YAML 文件，每个文件对应一个友链组。 示例文件结构 myblog/├── source/│ ├── _data/│ │ └── links/│ │ ├── ios_developer.yml│ │ ├── web_developer.yml│ │ └── design.yml 示例数据文件内容ios_developer.yml - title: 某某某 url: https://example1.com cover: https://example1.com/cover.jpg icon: https://example1.com/icon.png description: 这是一个 iOS 开发者的友链。 web_developer.yml - title: 某某某 url: https://example2.com cover: https://example2.com/cover.jpg icon: https://example2.com/icon.png description: 这是一个 Web 开发者的友链。 design.yml - title: 某某某 url: https://example3.com cover: https://example3.com/cover.jpg icon: https://example3.com/icon.png description: 这是一个设计师的友链。 在页面中插入不同的友链组在需要显示不同友链组的位置，使用相应的 Liquid 标签。 示例页面文件假设你在 myblog/source/_posts/2023-10-01-my-post.md 文件中插入多个友链组，编辑后的markdown文件可能如下所示： ---title: 友链date: 2024-09-20 20:13:20tags: [hexo,搭建博客]categories: 搭建博客---# 文章标题这是我的文章内容。## iOS 开发者友链% friends ios_developer %## Web 开发者友链% friends web_developer %## 设计师友链% friends design %## 友链组% friends ios_developer %## 其他内容其他文章内容。 效果展示备注：由于换主题，不能插入友链，因此暂时注释掉","tags":["hexo","搭建博客"],"categories":["搭建博客"]},{"title":"双指针法合并顺序表","path":"/2024/09/20/双指针法合并顺序表/","content":"双指针法合并顺序表题目：有2个顺序表table1和table2，合并成一个新的顺序表 解法1思路： 双指针方法 复杂度： 时间复杂度： 空间复杂度： 代码： std::vectorint test::solution(std::vectorint table1, std::vectorint table2) std::vectorint result; int slow = 0,fast = 0; while (slowtable1.size()fasttable2.size()) if (table1[slow]table2[fast]) result.push_back(table1[slow]); slow++; else result.push_back(table2[fast]); fast++; while (slowtable1.size()) result.push_back(table1[slow]); slow++; while (fasttable2.size()) result.push_back(table2[fast]); fast++; return result;","tags":["c++","刷题"],"categories":["C++刷题笔记"]},{"title":"字母异位词","path":"/2024/09/20/每日一刷day31/","content":"字母异位词题目：给定两个字符串s和t，编写一个函数来判断 t 是否是 s 的字母异位词。 解法-哈希表思路：本能暴力循环，学习哈希表解决 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class Solution public: //aee //eae bool isAnagram(string s, string t) int record[26] = 0; //设定一个表，对应位置++ for (int i = 0; i s.size(); i++) record[s[i] - a]++; //然后再在对应位置-- for (int i = 0; i t.size(); i++) record[t[i] - a]--; for (int i = 0; i 26; i++) if (record[i] != 0) return false; return true; ;","tags":["c++","字母异位词"],"categories":["C++刷题笔记"]},{"title":"Linux嵌入式学习粗略笔记","path":"/2024/09/18/Linux嵌入式/","content":"🐧🐧🐧🐧🐧🐧🐧🐧🐧🐧🐧 一些缩写.elf 文件：Executable and Linkable Format，可执行连接格式编译(compilation)指令：gcc -S hello.c -o hello.s汇编(assembly)指令：gcc -c hello.s -o hello.o信号量：semaphoremisc:文件位于drivers\\char\\misc.c msic意思是杂项。因此 MISC 驱动也叫做杂项驱动，也就是当我们板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。 MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动，所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号， MISC 设备驱动就用于解决此问题。 MISC 设备会自动创建 cdev，不需要像我们以前那样手动创建，因此采用 MISC 设备驱动可以简化字符设备驱动的编写。IOMUX是“InputOutput Multiplexer and Unifier”的缩写，中文可以翻译为“输入输出多路复用器和统一器”。它是一种电子设备或电路，用于在多个信号源和目标之间进行选择和转换。在具体应用中，IOMUX通常用于处理电子设备中的信号输入和输出。它可以将多个信号源（如不同的传感器或数据源）与多个目标（如不同的处理器或输出设备）进行连接和分配，从而实现信号的复用和转换。关键词解释： InputOutput（输入输出）：指设备或系统接收和发送数据的接口。 Multiplexer（多路复用器）：一种设备或技术，可以将多个信号或数据流合并为一个信号流进行传输或处理。 Unifier（统一器）：用于将不同来源或格式的数据、信号等统一处理或输出的设备或技术。IOMUX在许多电子设备和系统中都有应用，如嵌入式系统、微控制器、FPGA等，它可以帮助提高系统的效率和性能，同时减少硬件的复杂性和成本。 一些C语法c语言中将int变量转换为void *指针或int *指针在C语言中，将一个整型变量强制转换为void *指针类型通常是为了将整数值作为一个通用指针传递给函数，或者在特定的上下文中使用这个整数的值作为内存地址。进行这样的转换可以用类型转换运算符 (void *)。以下是一个简单的示例： int integerValue = 12345;void *pointerValue = (void *)(intptr_t)integerValue; 在这个例子中，整型变量integerValue的值被转换为一个intptr_t类型，然后再转换为void *类型。intptr_t是一种整数类型，它的大小足够存放指针，这保证了转换过程中不会丢失信息。这种转换方法是可移植性较好的，因为它考虑到了不同平台上指针和整数大小可能不一致的情况。 需要注意的是，这样的转换并不意味着整数真的变成了一个有效的内存地址。如果你打算通过这样的指针去访问内存，必须非常小心，确保这个整数值确实对应于一个合法且可访问的内存地址，否则会导致未定义行为，比如程序崩溃或者数据损坏。在多线程和异步编程中，将整数简单地作为数据通过指针传递给线程函数是一种常见且安全的用途。于是想到是否解引用pointerValue的值，发现是不可以的。目前暂时不知道将int 变量转换为void指针的目的是什么 #includestdio.hint main() int integerValue = 12345; int * pointerValue = (int *)integerValue;\t//int * pointerValue = (int *)(long)integerValue; printf(* pointerValue2 = %d,*pointerValue);\treturn 0; 这一部分问题在于： 将一个整数直接转换为指针并解引用该指针，这通常会导致未定义行为（undefined behavior）。因为在现代操作系统中，这样的指针几乎不可能指向合法的内存位置，因此解引用它的结果是不可预测的，可能会导致程序崩溃、数据损坏或安全漏洞。正确的做法是确保指针总是指向有效的、已分配的内存位置。对于测试的目的，我们应该构造一个安全的环境来模拟和验证逻辑，而不是直接执行可能导致未定义行为的操作。 一些有用的命令查看工具链中头文件和库文件的路径echo main(){}| arm-linux-gnueabihf-gcc -E -v -搜索某一个字符grep prefix * -nwr MakefileMakefile的引入及规则使用keil, mdk,avr等工具开发程序时点击鼠标就可以编译了，它的内部机制是什么？它怎么组织管理程序？怎么决定编译哪一个文件？ 答：实际上windows工具管理程序的内部机制，也是Makefile，我们在linux下来开发裸板程序的时候，使用Makefile组织管理这些程序，本节我们来讲解Makefile最基本的规则。Makefile要做什么事情呢？组织管理程序，组织管理文件，我们写一个程序来实验一下： 文件a.c 02\t#include stdio.h0304\tint main()05\t06\tfunc_b();07\treturn 0;08 文件b.c 2\t#include stdio.h34\tvoid func_b()5\t6 printf(This is B );7 编译： gcc -o test a.c b.c 运行： ./test 结果： This is B gcc -o test a.c b.c 这条命令虽然简单，但是它完成的功能不简单。 我们来看看它做了哪些事情， 我们知道.c程序 》 得到可执行程序它们之间要经过四个步骤： 1.预处理 2.编译 3.汇编 4.链接 我们经常把前三个步骤统称为编译了。我们具体分析：gcc -o test a.c b.c这条命令它们要经过下面几个步骤： 1）对于a.c：执行：预处理 编译 汇编 的过程，a.c xxx.s xxx.o 文件。 2）对于b.c：执行：预处理 编译 汇编 的过程，b.c yyy.s yyy.o 文件。 3）最后：xxx.o和yyy.o链接在一起得到一个test应用程序。 提示：gcc -o test a.c b.c -v ：加上一个**‘-v’**选项可以看到它们的处理过程， 第一次编译 a.c 得到 xxx.o 文件，这是很合乎情理的， 执行完第一次之后，如果修改 a.c 又再次执行：gcc -o test a.c b.c，对于 a.c 应该重新生成 xxx.o，但是对于 b.c 又会重新编译一次，这完全没有必要，b.c 根本没有修改，直接使用第一次生成的 yyy.o 文件就可以了。 缺点：对所有的文件都会再处理一次，即使 b.c 没有经过修改，b.c 也会重新编译一次，当文件比较少时，这没有没有什么问题，当文件非常多的时候，就会带来非常多的效率问题如果文件非常多的时候，我们，只是修改了一个文件，所用的文件就会重新处理一次，编译的时候就会等待很长时间。 对于这些源文件，我们应该分别处理，执行：预处理 编译 汇编，先分别编译它们，最后再把它们链接在一次，比如： 编译： gcc -o a.o a.cgcc -o b.o b.c 链接： gcc -o test a.o b.o 比如：上面的例子，当我们修改a.c之后,a.c会重现编译然后再把它们链接在一起就可以了。b.c就不需要重新编译。 那么问题又来了，怎么知道哪些文件被更新了被修改了？ 比较时间：比较 a.o 和 a.c 的时间，如果a.c的时间比 a.o 的时间更加新的话，就表明 a.c 被修改了，同理b.o和b.c也会进行同样的比较。比较test和 a.o,b.o 的时间，如果a.o或者b.o的时间比test更加新的话，就表明应该重新生成test。Makefile就是这样做的。我们现在来写出一个简单的Makefile: makefie最基本的语法是规则，规则： 目标 : 依赖1 依赖2 ...[TAB]命令 当“依赖”比“目标”新，执行它们下面的命令。我们要把上面三个命令写成makefile规则，如下： test ：a.o b.o //test是目标，它依赖于a.o b.o文件，一旦a.o或者b.o比test新的时候，就需要执行下面的命令，重新生成test可执行程序。gcc -o test a.o b.oa.o : a.c //a.o依赖于a.c，当a.c更加新的话，执行下面的命令来生成a.ogcc -c -o a.o a.cb.o : b.c //b.o依赖于b.c,当b.c更加新的话，执行下面的命令，来生成b.ogcc -c -o b.o b.c 我们来作一下实验： 在改目录下我们写一个Makefile文件： 文件：Makefile 1\ttest:a.o b.o2 gcc -o test a.o b.o3\t4\ta.o : a.c5 gcc -c -o a.o a.c7\tb.o : b.c8 gcc -c -o b.o b.c 上面是makefile中的三条规则。makefile,就是名字为“makefile”的文件。当我们想编译程序时，直接执行make命令就可以了，一执行make命令它想生成第一个目标test可执行程序,如果发现a.o 或者b.o没有，就要先生成a.o或者b.o，发现a.o依赖a.c，有a.c但是没有a.o,他就会认为a.c比a.o新，就会执行它们下面的命令来生成a.o，同理b.o和b.c的处理关系也是这样的。 如果修改a.c ，我们再次执行make，它的本意是想生成第一个目标test应用程序,它需要先生成a.o,发现a.o依赖a.c(执行我们修改了a.c)发现a.c比a.o更加新，就会执行gcc -c -o a.oa.c命令来生成a.o文件。b.o依赖b.c，发现b.c并没有修改，就不会执行gcc -c -o b.ob.c来重新生成b.o文件。现在a.o b.o都有了，其中的a.o比test更加新，就会执行 gcc -otest a.ob.o来重新链接得到test可执行程序。所以当执行make命令时候就会执行下面两条执行： gcc -c -o a.o a.cgcc -o test a.o b.o 我们第一次执行make的时候，会执行下面三条命令(三条命令都执行)： gcc -c -o a.o a.cgcc -c -o b.o b.cgcc -o test a.o b.o 再次执行make 就会显示下面的提示： make: `test is up to date. 我们再次执行make就会判断Makefile文件中的依赖，发现依赖没有更新，所以目标文件就不会重现生成，就会有上面的提示。当我们修改a.c后，重新执行make, 就会执行下面两条指令： gcc -c -o a.o a.cgcc -o test a.o b.o 我们同时修改a.c b.c，执行make就会执行下面三条指令。 gcc -c -o a.o a.cgcc -c -o b.o b.cgcc -o test a.o b.o a.c文件修改了，重新编译生成a.o, b.c修改了重新编译生成b.o，a.o,b.o都更新了重新链接生成test可执行程序，makefile的规则其实还是比较简单的。规则是Makefie的核心， 执行make命令的时候，就会在当前目录下面找到名字为：Makefile的文件，根据里面的内容来执行里面的判断命令。 shell pwd 和PWD的区别pwd:是一条命令，可以在makefile文件中引用(shel pwd)来获取当前目录PWD:是一个变量，可以直接echo $PWD来获取当前目录经过测试echo pwd和echo $PWD结果是一样的，推测可以在makefile文件中替换使用pwd $PWD $(shell pwd)一个shell pwd的例子，这样的例子很常见 INCDIR := $(shell pwd) //将shell pwd作为变量，通过 $(shell pwd)形式引用这个变量// C预处理器的flag，flag就是编译器可选的选项CPPFLAGS := -nostdlib -nostdinc -I$(INCDIR)/include //-nostdlib表示不使用标准库 //-nostdinc表示不使用标准头文件//-I是用来指定相对路径的，这里表示我们需要预处理的文件所在的路径是相对路径下的include文件夹 文件IO标准io和系统io的区别在于标准io引入了一个用户buffer，系统io没有。 系统io文件句柄：fd 0 1 2 3文件句柄如何和具体文件挂钩？ 0 - devpts0 代表标准输入 1 - devpts0 代表标准输出 2 - devpts0 代表标准错误 3 - homebook01_all_series_quickstart04_嵌入式Linux应用开发基础知识source06_fileio01_open1.txt 代表自己打开的文件 open 函数errno: 错误码，可以配合strerror(errno)来打印错误信息，效果同perrorperror(“open error”)用来打印错误信息 O_RDONLY: 以只读方式打开文件。O_WRONLY: 以只写方式打开文件。O_RDWR: 以读写方式打开文件。O_CREAT: 如果文件不存在，则创建之。以默认权限创建，最终的权限由mode和umask决定。O_EXCL: 当与O_CREAT一起使用时，如果文件已存在则打开失败。O_TRUNC: 打开文件后将其长度截断为0。O_APPEND: 写入时，数据将被追加到文件末尾。 int open(const char *pathname, int flags); 1)使用open创建一个不存在的文件 fd =open(argv[1],O_CREAT|O_RDWR)ssize_t write(int fd, const void *buf, size_t count);ssize_t read(int fd, void *buf, size_t count); 交叉编译 freetype1.编译程序时去哪找头文件 1）系统目录：交叉编译工具链的某个include 目录 2）自行指定：使用 -I dir 来指定2.链接时去哪找库文件 1）系统目录：交叉编译工具链的某个lib 目录 2）自行指定：使用 -L dir 来指定3.运行时去哪找库文件 1）系统目录：板子上的lib usrlib 目录 2）自行指定：使用 LD_LIBRARY_PATH 来指定4.运行时不需要头文件 homebook100ask_imx6ull-sdkToolChainarm-buildroot-linux-gnueabihf_sdk-buildrootarm-buildroot-linux-gnueabihfsysrootusrinclude LIBRARY_PATHhomebook100ask_imx6ull-sdkToolChainarm-buildroot-linux-gnueabihf_sdk-buildrootarm-buildroot-linux-gnueabihfsysrootusrlib 输入设备内核中使用input_dev结构体来描述一个输入设备。 //D:\\Linux-4.9.88\\include\\linux\\input.hstruct input_dev const char *name;\tconst char *phys;\tconst char *uniq;\tstruct input_id id;\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)];\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)];\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)];\tunsigned int hint_events_per_packet;\tunsigned int keycodemax;\tunsigned int keycodesize;\tvoid *keycode;\tint (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode);\tint (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke);\tstruct ff_device *ff;\tunsigned int repeat_key;\tstruct timer_list timer;\tint rep[REP_CNT];\tstruct input_mt *mt;\tstruct input_absinfo *absinfo;\tunsigned long key[BITS_TO_LONGS(KEY_CNT)];\tunsigned long led[BITS_TO_LONGS(LED_CNT)];\tunsigned long snd[BITS_TO_LONGS(SND_CNT)];\tunsigned long sw[BITS_TO_LONGS(SW_CNT)];\tint (*open)(struct input_dev *dev);\tvoid (*close)(struct input_dev *dev);\tint (*flush)(struct input_dev *dev, struct file *file);\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);\tstruct input_handle __rcu *grab;\tspinlock_t event_lock;\tstruct mutex mutex;\tunsigned int users;\tbool going_away;\tstruct device dev;\tstruct list_head\th_list;\tstruct list_head\tnode;\tunsigned int num_vals;\tunsigned int max_vals;\tstruct input_value *vals;\tbool devres_managed;;设备ID结构体为```C struct input_id __u16 bustype;\t__u16 vendor;\t__u16 product;\t__u16 version;;__u16 bustype;//枚举类型，如usb,pci等等取值为：#define BUS_PCI 0x01#define BUS_ISAPNP 0x02#define BUS_USB 0x03#define BUS_HIL 0x04#define BUS_BLUETOOTH 0x05#define BUS_VIRTUAL 0x06#define BUS_ISA 0x10#define BUS_I8042 0x11#define BUS_XTKBD 0x12#define BUS_RS232 0x13#define BUS_GAMEPORT 0x14#define BUS_PARPORT 0x15#define BUS_AMIGA 0x16#define BUS_ADB 0x17#define BUS_I2C 0x18#define BUS_HOST 0x19#define BUS_GSC 0x1A#define BUS_ATARI 0x1B#define BUS_SPI 0x1C#define BUS_RMI 0x1D#define BUS_CEC 0x1E#define BUS_INTEL_ISHTP 0x1F__u16 vendor;__u16 product;__u16 version;厂商号，产品号，版本号 内核使用input_event结构体来描述“输入事件” //include\\uapi\\linux\\input.hstruct input_event struct timeval time;\t__u16 type;\t__u16 code;\t__s32 value;;struct timeval\tlong tv_sec;\tlong tv_usec;;struct timeval time;记录了input_event时间发生的时间，这个包括秒和微秒，时间起点是系统启动的时刻。__u16 type;记录了哪一类事件在include\\uapi\\linux\\input-event-codes.h中，详细定义了事件类型 /* * Event types */#define EV_SYN 0x00//表示设备支持所有的事件?#define EV_KEY 0x01//键盘或者按键#define EV_REL 0x02//relative,鼠标或者相对坐标位置#define EV_ABS 0x03//absolute，手写板的值，绝对整数值#define EV_MSC 0x04//其他类型事件#define EV_SW 0x05#define EV_LED 0x11//LED设备事件#define EV_SND 0x12//蜂鸣器事件#define EV_REP 0x14//重复按键类型事件#define EV_FF 0x15#define EV_PWR 0x16//电源管理事件#define EV_FF_STATUS 0x17#define EV_MAX 0x1f#define EV_CNT (EV_MAX+1)__u16 code;记录了哪一个事件code 根据type的不同而有不同的含义例如：type = EV_KEY//按键事件，code表示键盘code或鼠标button值#define REL_X 0x00#define REL_Y 0x01#define REL_Z 0x02#define REL_RX 0x03#define REL_RY 0x04#define REL_RZ 0x05#define ...#define KEY_MAX 0x2ff#define KEY_CNT (KEY_MAX+1)例如：\ttype = EV_REL时，code表示操作的是哪个坐标轴，如REL_X,REL_Y /* * Relative axes */#define REL_X 0x00#define REL_Y 0x01#define REL_Z 0x02#define REL_RX 0x03#define REL_RY 0x04#define REL_RZ 0x05#define REL_HWHEEL 0x06#define REL_DIAL 0x07#define REL_WHEEL 0x08#define REL_MISC 0x09#define REL_MAX 0x0f#define REL_CNT (REL_MAX+1)例如：type = EV_ABS时，code表示绝对坐标轴的值 /* * Absolute axes */#define ABS_X 0x00#define ABS_Y 0x01#define ABS_Z 0x02#define ABS_RX 0x03#define ABS_RY 0x04#define ABS_RZ 0x05#define ...//表示正在修改的多点触控槽位，用于跟踪多个接触点。#define ABS_MT_SLOT 0x2f\t/* MT slot being modified *///触摸椭圆的主要轴长，表示接触区域的最大尺寸。#define ABS_MT_TOUCH_MAJOR\t0x30\t/* Major axis of touching ellipse *///触摸椭圆的次要轴长，如果接触区域是圆形，则忽略此值#define ABS_MT_TOUCH_MINOR\t0x31\t/* Minor axis (omit if circular) *///接近椭圆的主要轴长，可能比实际接触区域更大。#define ABS_MT_WIDTH_MAJOR\t0x32\t/* Major axis of approaching ellipse *///接近椭圆的次要轴长，如果接近区域是圆形，则忽略此值#define ABS_MT_WIDTH_MINOR\t0x33\t/* Minor axis (omit if circular) *///椭圆的方向，用于描述接触点的倾斜角度。#define ABS_MT_ORIENTATION\t0x34\t/* Ellipse orientation */// 触摸中心的X坐标位置。#define ABS_MT_POSITION_X\t0x35\t/* Center X touch position */#define ABS_MT_POSITION_Y\t0x36\t/* Center Y touch position *///触摸设备的类型，如手指、笔等。#define ABS_MT_TOOL_TYPE\t0x37\t/* Type of touching device *///将一组数据包分组为一个“blob”（数据块），用于关联相关的触摸事件。#define ABS_MT_BLOB_ID 0x38\t/* Group a set of packets as a blob *///跟踪接触的唯一ID，用于识别特定的触摸接触。或许应该翻译成初始触摸点唯一id？#define ABS_MT_TRACKING_ID\t0x39\t/* Unique ID of initiated contact *///在接触区域上的压力大小。#define ABS_MT_PRESSURE 0x3a\t/* Pressure on contact area *///接触点悬停时的距离，用于检测未实际接触但靠近传感器的情况。#define ABS_MT_DISTANCE 0x3b\t/* Contact hover distance *///工具中心的X坐标位置，可能与ABS_MT_POSITION_X不同，例如对于笔或其他工具。#define ABS_MT_TOOL_X 0x3c\t/* Center X tool position */#define ABS_MT_TOOL_Y 0x3d\t/* Center Y tool position */#define ABS_MAX 0x3f#define ABS_CNT (ABS_MAX+1)__s32 value;记录了事件的值同样的value也会根据type的值不同而有不同的含义例如：type = EV_KEY时，value表示按键的值，0表示按键没有按下，1表示按键按下//这里没有找到定义，网上查的type = EV_REL时，value表示移动的值和方向（正负）type = EV_ABS时，value表示移动的绝对坐标 当一个事件上传完之后，会上报一个“同步事件”，表示数据上传完毕。同步事件也是一个input_event结构体，type EV_SYN，code SYN_REPORT，value 0.即0 0 0 查看有哪些输入设备： ls /dev/input/* -lcrw-rw---- 1 root input 13, 64 Jan 1 00:00 /dev/input/event0crw-rw---- 1 root input 13, 65 Jan 1 00:00 /dev/input/event1crw-rw---- 1 root input 13, 66 Jan 1 00:00 /dev/input/event2crw-rw---- 1 root input 13, 63 Jan 1 00:00 /dev/input/mice//鼠标/dev/input/by-path:total 0lrwxrwxrwx 1 root root 9 Jan 1 00:00 platform-20cc000.snvs:snvs-powerkey-event - ../event0lrwxrwxrwx 1 root root 9 Jan 1 00:00 platform-gpio-keys-event - ../event2获取与 event 对应的相关设备信息 cat /proc/bus/input/devicesI: Bus=0019 Vendor=0000 Product=0000 Version=0000//I 设备IDN: Name=20cc000.snvs:snvs-powerkey//Name P: Phys=snvs-pwrkey/input0//物理路径S: Sysfs=/devices/soc0/soc/2000000.aips-bus/20cc000.snvs/20cc000.snvs:snvs-powerkey/input/input0//位于 sys 文件系统的路径U: Uniq=//唯一标识符H: Handlers=kbd event0 evbug//输入句柄HandlerB: PROP=0//B位图B: EV=3B: KEY=100000 0 0 0 //与04_嵌入式Linux应用开发基础知识\\source\\11_input\\01_app_demo\\01_get_input_info.c结果相同I: Bus=0018 Vendor=dead Product=beef Version=28bbN: Name=goodix-ts//触摸屏即#define BUS_I2C 0x18P: Phys=input/tsS: Sysfs=/devices/virtual/input/input1U: Uniq=H: Handlers=event1 evbugB: PROP=2B: EV=bB: KEY=1c00 0 0 0 0 0 0 0 0 0 0B: ABS=6e18000 0I: Bus=0019 Vendor=0001 Product=0001 Version=0100N: Name=gpio-keysP: Phys=gpio-keys/input0S: Sysfs=/devices/soc0/gpio-keys/input/input2U: Uniq=H: Handlers=kbd event2 evbugB: PROP=0B: EV=3B: KEY=c 获取设备信息使用hexdump命令hexdump /dev/input/event1来获取设备信息 //下表中与值相对应的事件类型type#define EV_ABS 0x03//绝对坐标事件#define EV_KEY 0x01//键盘或者按键事件#define EV_SYN 0x00//下表中与值相对应的事件code#define BTN_TOUCH 0x14a 下表为使用一个手指点击触摸屏返回的数据 序号 秒 微秒 type code value type code value数值代表的详细信息 0000000 7180 0000 57bc 0006 0003 0039 0014 0000 EV_ABS ABS_MT_TRACKING_ID 14 0000010 7180 0000 57bc 0006 0003 0035 006f 0000 EV_ABS ABS_MT_POSITION_X 0000020 7180 0000 57bc 0006 0003 0036 013a 0000 EV_ABS ABS_MT_POSITION_Y 0000030 7180 0000 57bc 0006 0003 0030 001e 0000 EV_ABS ABS_MT_TOUCH_MAJOR 0000040 7180 0000 57bc 0006 0003 003a 001e 0000 EV_ABS ABS_MT_PRESSURE 0000050 7180 0000 57bc 0006 0001 014a 0001 0000 EV_KEY BTN_TOUCH 0000060 7180 0000 57bc 0006 0000 0000 0000 0000 EV_SYN 0000070 7180 0000 27c5 0007 0003 0039 ffff ffff ABS_MT_TRACKING_ID -1 0000080 7180 0000 27c5 0007 0001 014a 0000 0000 EV_KEY BTN_TOUCH 0000090 7180 0000 27c5 0007 0000 0000 0000 0000 EV_SYN 对于多点触摸会上传ABS_MT_SLOT,数据更加复杂一些，但是原理是差不多的，会看信息表即可 获取设备信息int ioctl(int fd, unsigned long request, ...)//输入格式request要求：//include\\uapi\\asm-generic\\ioctl.h#define _IOC(dir,type,nr,size) \\\t(((dir) _IOC_DIRSHIFT) | \\ ((type) _IOC_TYPESHIFT) | \\ ((nr) _IOC_NRSHIFT) | \\ ((size) _IOC_SIZESHIFT))dir:_IOC_READ 读数据 _IOC_WRITE 写数据size:ioctl传输的字节数type:nr: _IOC_NR _IOC_TYPE _IOC_SIZE _IOC_DIR可以参考这篇博客 requret可以取以下值： //include\\uapi\\linux\\input.h#define EVIOCGVERSION _IOR(E, 0x01, int) /* get driver version */#define EVIOCGID _IOR(E, 0x02, struct input_id)\t/* get device ID */#define EVIOCGREP _IOR(E, 0x03, unsigned int[2])\t/* get repeat settings */#define EVIOCSREP _IOW(E, 0x03, unsigned int[2])\t/* set repeat settings */#define EVIOCGKEYCODE _IOR(E, 0x04, unsigned int[2]) /* get keycode */#define EVIOCGKEYCODE_V2\t_IOR(E, 0x04, struct input_keymap_entry)#define EVIOCSKEYCODE _IOW(E, 0x04, unsigned int[2]) /* set keycode */#define EVIOCSKEYCODE_V2\t_IOW(E, 0x04, struct input_keymap_entry)#define EVIOCGNAME(len) _IOC(_IOC_READ, E, 0x06, len) /* get device name */#define EVIOCGPHYS(len) _IOC(_IOC_READ, E, 0x07, len) /* get physical location */#define EVIOCGUNIQ(len) _IOC(_IOC_READ, E, 0x08, len) /* get unique identifier */#define EVIOCGPROP(len) _IOC(_IOC_READ, E, 0x09, len) /* get device properties */#define EVIOCGBIT(ev,len)\t_IOC(_IOC_READ, E, 0x20 + (ev), len)\t/* get event bits */#define EVIOCGABS(abs) _IOR(E, 0x40 + (abs), struct input_absinfo)\t/* get abs value/limits */#define EVIOCSABS(abs) _IOW(E, 0xc0 + (abs), struct input_absinfo)\t/* set abs value/limits */#define ... 软件访问硬件的几种方式1.查询方式示例：软件调用open函数，传入非阻塞参数O_NONBLOCK,如果驱动程序中有数据则立刻返回数据，否则返回错误 2.休眠唤醒方式示例：软件调用open函数，不传入非阻塞参数O_NONBLOCK，如果驱动程序中有数据，则返回数据；否则驱动程序休眠，直到有数据唤醒。 3.pollselect方式在pollselect中传入超时参数，比如ret poll(fds, nfds, 5000);，则在有数据可读或者有空间可写时，返回数据；否则等到超时时间5s后，返回错误。pollselect可以检测多个文件，多个事件；pollselect的缺点： 4.异步通知方式暂时没写 多线程编程基本概念使用top命令查看系统占用的资源，查看线程数，查看进程数。线程：thread进程：process调度是以线程为单位的，即系统调度的最小单位是线程。进程是线程的集合，资源分配以进程为基本单位。 互斥量：mutex共享资源：在进程中出现的全局变量，线程都可以访问唯一标识：进程号：PID 线程号：TID,pthread_t类型编译时候需要指明库 gcc xxx.c -lpthread 常用函数 查看线程id：pthread_t pthread_self(void);返回值为pthread_t，一个长整型 创建线程：int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)重要参数解释： pthread_t *thread：如果成功创建线程，则返回线程标识符，保存在thread中 const pthread_attr_t *attr：线程属性（栈大小，优先级等），默认为NULL void *(*start_routine)(void *):c函数指针，声明了一个名为start_routine的函数指针，该函数指针具有以下特性： 函数接收一个参数，且参数为void * 函数返回一个void *指针 函数名为start_routine,start_routine可以被替换为任意字符 void *arg:传递给start_routine的参数，可以设置为NULL。一般情况下，需要指向arg指向一个全局堆变量 返回值：成功返回0，失败返回错误码 线程退出 start_routine函数执行return 线程调用prhread_exit(void retval)函数 pthread_exit 函数为线程退出函数，在退出时候可以传递一个 void类型的数据带给主线程，若选择不传出数据，可将参数填充为 NULL。函数原型为void pthread_exit(void *retval); 调用pthread_cancel(pthread_t thread)函数函数原型为：int pthread_cancel(pthread_t thread);传入一个tid，则会强制退出该tid对应的线程。成功返回0 需要注意：如果进程中任意线程调用exit(),_exit(),_Exit()函数，则进程退出，所有线程退出。 回收线程 int pthread_join(pthread_t thread, void **retval);阻塞状态，直到成功回收线程后才返回，第一个参数为要回收线程的 tid 号，第二个参数为线程回收后接受线程传出的数据。 int pthread_tryjoin_np(pthread_t thread, void **retval);非阻塞模式回收函数，通过返回值判断是否回收掉线程，成功回收则返回 0，其余参数与 pthread_join 一致 线程控制-互斥锁 互斥锁解决临界资源访问冲突问题。通过对临界资源加锁来保护资源只被单个线程操作，待操作结束后解锁，其余线程才可获得操作权。例如：对某个全局变量进行访问时，通过互斥锁保证同一时间只能被一个线程访问互斥锁实现的过程可以如下： 创建互斥锁函数原型为：int pthread_mutex_init(phtread_mutex_t *mutex,const pthread_mutexattr_t *restrict attr);其中：mutex (pthread_mutex_t *): 互斥量指针。指向未初始化的互斥锁对象的指针。成功初始化后，这个互斥锁可用于线程间的同步。 参数：attr (const pthread_mutexattr_t *restrict): 指向互斥锁属性对象的指针，该对象指定了互斥锁的特性。如果设为NULL，则使用默认属性。restrict关键字表明在函数执行期间，attr指针不与其他访问的内存别名，这允许编译器进行潜在的优化。返回值 0: 成功，表示互斥锁已成功初始化。errno (错误码): 失败时，返回一个错误编号以指示遇到的错误类型（例如，如果内存不足无法初始化互斥锁，则返回ENOMEM）。函数应在互斥锁首次使用前被调用.一旦初始化，线程可以使用如pthread_mutex_lock、pthread_mutex_trylock和pthread_mutex_unlock等函数来管理对共享资源的访问 加锁去锁(阻塞) 当某一个线程获得了执行权后，执行 lock 函数，一旦加锁成功后，其余线程遇到 lock 函数时候会发生阻塞，直至获取资源的线程执行 unlock 函数后。unlock 函数会唤醒其他正在等待互斥量的线程。 加锁函数原型为：int pthread_mutex_lock(pthread_mutex_t *mutex);成功后会返回 0 去锁函数原型为：int pthread_mutex_unlock(pthread_mutex_t *mutex); 特别注意的是，当获取 lock 之后，必须在逻辑处理结束后执行 unlock，否则会发生死锁现象！导致其余线程一直处于阻塞状态，无法执行下去。在使用互斥量的时候，尤其要注意使用 pthread_cancel 函数，防止发生死锁现象！ 加锁(非阻塞模式)函数原型：int pthread_mutex_trylock(pthread_mutex_t *mutex);该函数是非阻塞模式通过返回值来判断是否加锁成功，用法与上述阻塞加锁函数一致 销毁互斥量(非阻塞)函数原型：int pthread_mutex_destory(pthread_mutex_t *mutex);，传入互斥量的指针，就可以完成互斥量的销毁，成功返回 0。 线程控制-信号量互斥量：防止多个线程同时访问同一个临界资源冲突问题信号量：通知 创建信号量int sem_init(sem_t *sem,int pshared,unsigned int value); sem_t *sem：指向信号量结构体的指针，这个结构体需要在调用sem_init前由用户分配空间。函数会初始化这个信号量。 int pshared：指定信号量是否可以在进程间共享。 如果pshared为0，表示信号量仅在当前进程中有效，不能被其他进程访问。 如果pshared为非0值（通常为1），则信号量可以在多个进程间共享，要求sem位于共享内存中。 unsigned int value：初始化信号量的值，即信号量计数器的初始值。表示最初可以同时访问共享资源的线程或进程的数量。 信号量操作 int sem_wait(sem_t *sem);int sem_post(sem_t *sem);int sem_trywait(sem_t *sem); sem_wait:函数作用为检测指定信号量是否有资源可用，若无资源可用会阻塞等待，若有资源可用会自动的执行“sem-1”的操作。所谓的“sem-1”是与上述初始化函数中第三个参数值一致，成功执行会返回 0。 sem_post： 函数会释放指定信号量的资源，执行“sem+1”操作。 sem_trywait：非阻塞方式 信号量销毁int sem_destory(sem_t *sem); Linux串口数据成员ermios 函数族提供了一个常规的终端接口，用于控制非同步通信端口。 这个结构包含了至少下列成员： struct termios\tunsigned short c_iflag; /* 输入模式标志*/\tunsigned short c_oflag; /* 输出模式标志*/\tunsigned short c_cflag; /* 控制模式标志*/\tunsigned short c_lflag; /*区域模式标志或本地模式标志或局部模式*/\tunsigned char c_line; /*行控制line discipline */\tunsigned char c_cc[NCC]; /* 控制字符特性*/; 常用函数tc:terminao control cd control flag 函数名 描述 int tcgetattr(int fd, struct termios *termios_p); 获取终端属性 int tcsetattr(int fd, int optional_actions, const struct termios *termios_p); 设置终端属性 int tcflush(int fd, int queue_selector); 清除终端缓冲区 int tcflow(int fd, int action); 控制终端的输入输出流 int tcdrain(int fd); 等待输出缓冲区中的所有字符被发送 int tcsendbreak(int fd, int duration); 发送一个持续duration的BREAK信号 int cfsetospeed(struct termios *termios_p, speed_t speed); 设置输出波特率 int cfsetispeed(struct termios *termios_p, speed_t speed); 设置输入波特率 speed_t cfgetospeed(const struct termios *termios_p); 获取输出波特率 speed_t cfgetispeed(const struct termios *termios_p); 获取输入波特率 int cfsetspeed(struct termios *termios_p, speed_t speed); 设置波特率 驱动 准备工作编译驱动程序之前需要先编译内核，内核的配置文件在arch/arm/configs/目录下，内核编译过程为: make mrpropermake 100_ask_imx6ull_defconfigmake zImage -j4make dtbs 生成arch/arm/boot/zImage和arch/arm/boot/dts/100ask_imx6ull-14x14.dtb文件,将这两个文件复制到homebooknfs_rootfs目录下备用 cp arch/arm/boot/zImage ~/nfs_rootfscp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs 进入内核源码目录，编译内核模块 cd /home/book/100ask_imx6ull-sdk/Linux-4.9.88/make modules 安装内核模块到/home/book/nfs_rootfs make ARCH=arm INSTALL_MOD_PATH=/home/book/nfs_rootfs modules_install 安装内核和模块到开发板上，先执行挂在命令，再执行以下命令 cp /mnt/zImage /bootcp /mnt/100ask_imx6ull-14x14.dtb /bootcp /mnt/lib/modules /lib -rfdsync 完成以上配置驱动程序流程： 确定主设备号，也可以让内核分配 定义自己的file_operations结构体 实现对应的drv_opendrv_readdrv_wtire等函数，填入file_operations结构体 把file_operations结构体注册到内核中:register_chrdev(主设备号，设备名，file_operations结构体指针)? 入口函数：安装驱动程序时，就会调用此入口函数 出口函数：卸载驱动程序，出口函数调用unregister_chrdev(主设备号，设备名)? 提供设备信息，自动创建设备节点：class_create,device_create 重要的类class解释参考博客：Linux内核中的 struct class 简介代码中出现的 class 指的是 设备类（device classes），是对于设备的高级抽象。但 实际上 class 也是一个结构体，只不过 class 结构体在声明时是按照类的思想来组织其成员的。运用 class，可以让用户空间的程序根据自己要处理的事情来调用设备，而不是根据设备被接入到系统的方式或设备的工作原理来调用。 //include\\linux\\device.hstruct class const char *name; // 类名称 struct module *owner; // 类所属的模块，比如 usb模块、led模块等 struct class_attribute *class_attrs; // 类所添加的属性 const struct attribute_group **dev_groups; // 类所包含的设备所添加的属性 struct kobject *dev_kobj; // 用于标识 类所包含的设备属于块设备还是字符设备 int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env); // 用于在设备发出 uevent 消息时添加环境变量 char *(*devnode)(struct device *dev, umode_t *mode); // 设备节点的相对路径名 void (*class_release)(struct class *class); // 类被释放时调用的函数 void (*dev_release)(struct device *dev); // 设备被释放时调用的函数 int (*suspend)(struct device *dev, pm_message_t state); // 设备休眠时调用的函数 int (*resume)(struct device *dev); // 设备被唤醒时调用的函数 const struct kobj_ns_type_operations *ns_type; const void *(*namespace)(struct device *dev); const struct dev_pm_ops *pm; // 用于电源管理的函数 struct subsys_private *p; // 指向 class_private 结构的指针; 重要的类file_operations结构体，参考博客：Linux 字符设备驱动结构（四）—— file_operations 结构体知识解析 //include\\linux\\fs.hstruct file_operations struct module *owner;//拥有该结构的模块的指针，一般为THIS_MODULES loff_t (*llseek) (struct file *, loff_t, int);//用来修改文件当前的读写位置 ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//从设备中同步读取数据 ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//向设备发送数据 ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);//初始化一个异步的读取操作 ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);//初始化一个异步的写入操作 int (*readdir) (struct file *, void *, filldir_t);//仅用于读取目录，对于设备文件，该字段为NULL unsigned int (*poll) (struct file *, struct poll_table_struct *); //轮询函数，判断目前是否可以进行非阻塞的读写或写入 int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); //执行设备I/O控制命令 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); //不使用BLK文件系统，将使用此种函数指针代替ioctl long (*compat_ioctl) (struct file *, unsigned int, unsigned long); //在64位系统上，32位的ioctl调用将使用此函数指针代替 int (*mmap) (struct file *, struct vm_area_struct *); //用于请求将设备内存映射到进程地址空间 int (*open) (struct inode *, struct file *); //打开 int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); //关闭 int (*fsync) (struct file *, struct dentry *, int datasync); //刷新待处理的数据 int (*aio_fsync) (struct kiocb *, int datasync); //异步刷新待处理的数据 int (*fasync) (int, struct file *, int); //通知设备FASYNC标志发生变化 int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **); ; 常用函数 函数名 描述 unsigned long copy_to_user(void *to, const void *from, unsigned long n); 这个函数的作用是将内核空间的数据复制到用户空间 to：目标地址（用户空间） from：源地址（内核空间） n：将要拷贝数据的字节数 返回：成功返回0，失败返回没有拷贝成功的数据字节数 unsigned long copy_from_user(void *to, const void *from, unsigned long n); 这个函数的作用是将用户空间的数据复制到内核空间 to：目标地址（内核空间）from：源地址（用户空间）n：将要拷贝数据的字节数返回：成功返回0，失败返回没有拷贝成功的数据字节数 led驱动static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)","tags":["嵌入式","linux","imx6ull"],"categories":["LINUX"]},{"title":"ros常用命令","path":"/2024/09/18/ros常用命令/","content":"ROS文件系统 WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 package.xml该文件定义有关软件包的属性，例如软件包名称，版本号，作者，维护者以及对其他catkin软件包的依赖性。请注意，该概念类似于旧版 rosbuild 构建系统中使用的manifest.xml文件。 CMakeLists.txt文件CMakeLists.txt是CMake构建系统的输入，用于构建软件包。任何兼容CMake的软件包都包含一个或多个CMakeLists.txt文件，这些文件描述了如何构建代码以及将代码安装到何处。 ros文件系统相关命令 增 删 改 查 启停 ros常用命令参考网址：ros命令 rosnode ：操作节点 rostopic ：操作话题 rosservicea : 操作服务 rosmsg : 操作msg消息 rossrv : 操作srv服务 rosparam : 操作参数 新生成一个乌龟 rosservice call /spawn x: 0.0y: 0.0theta: 0.0name: 常用API","tags":["ros","笔记"],"categories":["ROS"]},{"title":"环形缓冲区","path":"/2024/09/18/环形缓冲区/","content":"环形缓冲区 位置： 起始位置 缓冲区长度 读位置 写位置 状态： 空 满 非空非满","tags":["嵌入式","linux","环形缓冲区"],"categories":["LINUX"]},{"title":"fileZilla连接虚拟机，同样适用MobaXterm","path":"/2024/09/15/fileZilla连接虚拟机/","content":"fileZilla连接虚拟机，同样适用MobaXterm主要分为fileZilla设置和虚拟机设置，虚拟机主要是设置ip地址和用户名 一图查看 虚拟机设置 设置网络适配器为NAT模式(不知道是不是必须NAT，因为现在使用的是NAT模式) 使用ifconfig查看ip 使用whoami查看用户名，得到用户名book 注意这里不是：hostname,也不是管理员权限下的whoami 在设置中查看Detail-About也不对 至此，就完成了虚拟机相关的设置，主要是注意使用用户名 book用于登录到远程服务器，不是root，也不是主机名100ask FileZilla设置 按照虚拟机设置，依次设置即可 主机：即ifconfig查看的远程主机的ip地址 用户名：即book 密码：即乌班图开机密码 端口：默认22 MobaXterm连接虚拟机MobaXterm和fileZilla设置如出一辙，按照下图设置即可： Remote host ：即NAT网卡ip地址 username :即whoami用户名 port : 默认值22即可 需要注意的是MobaXterm也可以使用桥接网卡的ip但是我没有测试，原理应该是一样的","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"ubuntu搭建开发环境以及开发板ubuntu互ping","path":"/2024/09/15/ubuntu搭建开发环境以及开发板ubuntu互ping/","content":"ubuntu搭建开发环境以及开发板ubuntu互ping在ubuntu下配置IMX6ULL的配置环境 目标：实现ubuntu与开发板互ping 1.开发板设置静态IP 临时设置 ifconfig eth0** **192.168.5.9 修改配置文件永久设置 vi /etc/network/interfaces 使用vi编辑器将interfaces里内容修改为： auto loiface lo inet loopbackauto eth0iface eth0 inet static\taddress 192.168.5.9\tnetmask 255.255.255.0\tgateway 192.168.5.1 vi切换为命令行模式，使用wq强制保存并退出，再执行/etc/init.d/S40network restart重启网络服务 使用ifconfig查看ip，在eth0中出现设置的192.168.5.9便说明成功了。eth1是连接外网的，此时不用管 2. 设置虚拟机打开虚拟机–可移动设备 可以看到有以下两个移动设备： Qingfeng USB Single Serial Realtek USB 10100 LAN 分别是串口和网卡，这里都需要连接到Ubuntu上，确保这两个连接的都是虚拟机而不是主机。 2.1 NAT网卡Ubuntu通过NAT网卡上网，我们提供的Ubuntu默认已经支持了NAT网卡。 打开虚拟机时，点击”编辑虚拟机”，确保网卡是NAT网卡： 注意这里是：这里是在ubuntu下进行嵌入式开发，不涉及到windows，因此只需要一个网络适配器，并且设置为NAT模式即可，另一个网络适配器2是不需要的 2.2 USB网卡2.1 连接网卡在日常开发中，开发板和Ubuntu之间通过网络传输数据： 2 设置静态IP在Ubuntu中设置USB网卡的IP位静态IP 设置-网络-USB Ethernet,点击小齿轮 选择手动分配，即Manual，设置为： Address 192.168.5.11 Netmask 255.255.255.0 Gateway 192.168.5.1 3. 验证以上2个步骤全部做完就可以互ping了 在开发板pingUbuntu： ping 192.168.5.11 在Ubuntu上ping开发板： ping 192.168.5.19 因为是纯untuntu下配置，没有使用到windows因此不需要ping windows，如果设置了网络适配器2，理论上可以ping通windows","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"解决ubuntu 20.04 GRUB启动项顺序的问题","path":"/2024/09/15/ubuntu+GRUB启动项/","content":"解决ubuntu 20.04 GRUB启动项顺序的问题命令： 输入命令：sudo gedit etcdefaultgrub 更改配置： GRUB_DEFAULT=2//指定默认启动的菜单项。数字 2 表示启动菜单中的第 三 个条目（索引从 0 开始）。 //注意：此处设置需要根据启动菜单的显示顺序来确定。GRUB_TIMEOUT_STYLE=hidden//设置 GRUB 菜单的显示样式。hidden 表示在超时之前不显示菜单，除非用户按下某个键。menu显示 GRUB 菜单。countdown：显示倒计时。GRUB_TIMEOUT=10//设置 GRUB 菜单的超时时间（以秒为单位）。在 10 秒后，GRUB 将自动启动默认的菜单项。GRUB_DISTRIBUTOR=`lsb_release -i -s 2 /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=quiet splashGRUB_CMDLINE_LINUX= 执行命令：sudo update-grub 重启","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"解决unbuntu 20.04 主机没有声音的问题","path":"/2024/09/15/ubuntu没有声音/","content":"解决ubuntu 20.04 主机没有声音的问题安装pavucontrol：输入安装命令：sudo apt install pavucontrol 终端启动：pavucontrol配置： 配置-HDA NVidia 选项关 配置-内置音频 选择模拟立体声输出 输出设备-内置音频 模拟立体声-模拟耳机备注：只能插在主机上，插在显示器上还是没有声音","tags":["笔记","ubuntu"],"categories":["UBUNTU"]},{"title":"区间和--前缀和数组","path":"/2024/09/03/每日一刷day4/","content":"区间和题目：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。 解法-通过前缀和数组思路：由于暴力求解时间复杂度较大，因此采用前缀和的方法 引入前缀和数组：presum[i]表示前i个元素的和 如果要计算的区间为[begin,end]，则计算presum[end]-presum[begin-1] 这里的begin 和 end 都是从0开始 复杂度： 时间复杂度： 空间复杂度： 代码： int solution(vectorintnums,int begin,int end) int sum = 0; int result = 0; vectorint presum(nums.size(),0); for (int i = 0; i nums.size(); i++) sum += nums[i]; presum[i]=sum; coutpresum[i] = presum[i]endl; result = presum[end]-presum[begin-1]; return result;","tags":["c++","前缀和"],"categories":["C++刷题笔记"]},{"title":"平方新数组","path":"/2024/09/02/每日一刷day3/","content":"平方组成的新数组题目：给你一个按非递减顺序排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。示例 1：输入：nums [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]示例 2：输入：nums [-7,-3,2,3,11]输出：[4,9,9,49,121] 解法1思路：每个数平方之后，排个序 过于简单 复杂度： 时间复杂度：O(n+nlogn) 空间复杂度： 代码： std::vectorint test::solution(std::vectorint nums) std::vectorint result(nums.size()); for (int i = 0; i nums.size(); i++) result[i] = nums[i]*nums[i]; sort(result.begin(),result.end()); return result; 解法2–双指针法思路：本来就是有序的数组，由于负数平方之后可能会改变数组的顺序，所以重点关注负数数组平方的最大值出现在数组的两端，左或者右，不可能是中间。所以可以考虑双指针法，left和right 定义新数组，用来存储结果，注意初始化大小，否则容易出现溢出错误 判断nums[left]*nums[left]和nums[right]*nums[right]大小，以便赋值给result[i] 如果nums[left]*nums[left] nums[right]*nums[right] 那么 result[i] = nums[left]*nums[left] 如果nums[left]*nums[left] nums[right]*nums[right] 那么 result[i] = nums[right]*nums[right] 初始值i = nums.size()-1,方便从后往前填充 复杂度： 时间复杂度：o(n) 空间复杂度： 代码： std::vectorint test::solution(std::vectorint nums) std::vectorint result(nums.size()); int left = 0,right = nums.size()-1; //从后往前填充 //i=0 for(int i = nums.size()-1;i=0;i--) if(nums[left]*nums[left] nums[right]*nums[right]) result[i] = nums[left]*nums[left]; left++; else result[i] = nums[right]*nums[right]; right--; return result;","tags":["c++","平方新数组"],"categories":["C++刷题笔记"]},{"title":"matlab非线性方程求解fsolve","path":"/2024/09/01/matlab非线性方程求解fsolve/","content":"matlab非线性方程求解fsolve懒得上传图片了…以后也不不一定用得到这个fsolve - 对非线性方程组求解 - MATLAB - MathWorks 中国 匿名函数f=@(x)acos(x)，f为函数句柄，@是定义句柄的运算符。f=@(x)acos(x)相当于建立了一个函数文件，%f.m function y=f(x) y=acos(x) 此示例返回迭代输出，展示了一个包含两个方程和两个未知数的方程组的求解过程 以 F(x)0 形式重写方程： 从 x0 = [-5 -5] 开始搜索解。 首先，编写一个函数用来计算 F（方程在 x 处的值）。 F = @(x) [2*x(1) - x(2) - exp(-x(1)); -x(1) + 2*x(2) - exp(-x(2))]; 这个匿名函数接受一个向量x作为输入参数。向量x在这里被假定为包含两个元素，分别用x(1)和x(2)表示。 匿名函数返回一个包含两个元素的向量。向量中的第一个元素是表达式2*x(1) - x(2) - exp(-x(1))的值，其中exp(-x(1))表示自然指数函数e的-x(1)次方。 向量中的第二个元素是表达式-x(1) + 2*x(2) - exp(-x(2))的值，同样exp(-x(2))表示自然指数函数e的-x(2)次方。 这个匿名函数通常可能用于求解方程组或者在其他数值计算方法中作为一个函数表达式来使用。例如，可以使用数值求解器（如fsolve等）来找到使得这个函数返回值为零的向量x的值，从而求解一个非线性方程组。 创建初始点 x0。 x0 = [-5;-5]; 设置选项以返回迭代输出。 options = optimoptions(fsolve,Display,iter); 求解方程。 [x,fval] = fsolve(F,x0,options)","tags":["c++","matlab"],"categories":["C++笔记"]},{"title":"二分查找","path":"/2024/08/20/每日一刷day1/","content":"二分查找题目：给定一个整型有序数组nums和一个目标之target,写一个搜索函数搜索target,如果存在则返回target在数组中的下下标，如果target不存在，返回-1。 代码思路： 采取闭区间[left,right]写法 while (left right) 要使用 ，因为left right是有意义的，所以使用 if (nums[middle] target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 复杂度： 时间复杂度：O(log n) 空间复杂度：O(1) int search::solution(vectorintnums,int target) int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left = right) // 当left==right，区间[left, right]依然有效，所以用 = int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2 if (nums[middle] target) right = middle - 1; // target 在左区间，所以[left, middle - 1] else if (nums[middle] target) left = middle + 1; // target 在右区间，所以[middle + 1, right] else // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 // 未找到目标值 return -1;","tags":["c++","刷题day1"],"categories":["C++刷题笔记"]},{"title":"移除元素","path":"/2024/08/20/每日一刷day2/","content":"移除元素题目：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1: 给定 nums [3,2,2,3], val 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。示例 2: 给定 nums [0,1,2,2,3,0,4,2], val 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。你不需要考虑数组中超出新长度后面的元素。 解法1思路： 两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组 复杂度： 时间复杂度：O(n^2) 空间复杂度： 代码： // 时间复杂度：O(n^2)// 空间复杂度：O(1)class Solution public: int removeElement(vectorint nums, int val) int size = nums.size(); for (int i = 0; i size; i++) if (nums[i] == val) // 发现需要移除的元素，就将数组集体向前移动一位 for (int j = i + 1; j size; j++) nums[j - 1] = nums[j]; i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位 size--; // 此时数组的大小-1 return size; ; 解法2–双指针法思路：双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 1.2.3. 复杂度： 时间复杂度： 空间复杂度： 代码： class pdeleteArrayprivate: /* data */public: pdeleteArray(/* args */); ~pdeleteArray(); int solution(std::vectorintnums,int val) int slow = 0; for (int fast = 0; fast nums.size(); fast++) if (nums[fast] != val) nums[slow] = nums[fast]; slow++; return slow; ;","tags":["c++","移除元素"],"categories":["C++刷题笔记"]},{"title":"短横杠-的含义","path":"/2024/07/20/短横杠-的含义/","content":"短横杠-的含义猛地看到it - vec.begin()竟看不懂这是什么，还以为是和.或者-一样新的运算符。故而总结： 减法运算符 取负运算符 指针加减运算符可以计算两个指针之间的距离int arr[] = 1, 2, 3, 4, 5; int *ptr1 = arr[0]; int *ptr2 = arr[2]; int distance = ptr2 - ptr1; // 结果为 2 迭代器之间的差值std::vectorint vec = 1, 2, 3, 4, 5;auto it1 = vec.begin();auto it2 = vec.begin() + 2;int distance = it2 - it1; // 结果为 2 类似于指针的距离，因为vec.begin()可以认为是一个指针，指向第0元素的位置，即*vec.begin()1.vec.end()指向第5个元素的位置，即*(vec.end()-1)6 可以重载自定义","tags":["c++"],"categories":["C++笔记"]},{"title":"虚函数","path":"/2024/07/20/虚函数/","content":"虚函数 虚函数是在基类中声明的成员函数，前面加上virtual关键字 允许在派生类中重写这个函数，并且可以通过基类指针或者引用调用时，自动选择正确的函数版本如果在派生类中不打算重写基类的虚函数，可以在声明时使用final防止重写用处： 需要通过继承来扩展功能并保持代码的可维护性和灵活性 纯虚函数 是一种特殊的虚函数 在基类中声明，但是没有实现 纯虚函数使用0来声明，表示该函数必须在派生类中被重写 抽象类： 包含纯虚函数的类叫做抽象类 抽象类不能实例化对象，只能作为其他类的基类举例： //定义抽象类Baseclass Base public: vitrual int doSomething() = 0;//纯虚函数，为抽象类;class Derived: public Base public: int doSomething()override/*具体实现*/return 0;;int main() Base* pbase = new Base();//错误 Base* pderived = new Derived();//正确 举例class Shape public: virtual double area() const = 0; // 纯虚函数;class Circle : public Shape public: double radius; Circle(double r) : radius(r) double area() const override return 3.14 * radius * radius; ;class Rectangle : public Shape public: double width, height; Rectangle(double w, double h) : width(w), height(h) double area() const override return width * height; ;int main() Shape* shapes[] = new Circle(5), new Rectangle(4, 6); for (auto shape : shapes) std::cout Area: shape-area() std::endl; for (auto shape : shapes) delete shape; // 释放内存 return 0;","tags":["c++"],"categories":["C++笔记"]},{"title":"车类残局定式","path":"/2024/05/20/ChessLearning/","content":"实用残局术语车类单车必胜士相不全单车例胜单缺士总体思路：车要在双相的对立侧，可以利用帅破掉单士，形成单车例胜双相的局面 单车例胜双相总体思路：帅回中，车分边，入底，抢将位，高捉相 破相定式 黑方双相不能相连，这种局面比较少见 利用帅在中，将军后底相被吃 利用将军上帅堵住相眼，从而破相，此局面不要求帅在中 借助帅力，从而破相 抢占将位（底中线）只要能够抢占住底中线，通过高捉相（占中之后，高捉相之前有可能会等一着），黑方三步以内必丢相，如何抢占底中线，大致有以下两种思路。 第一种比较简单。如果将不在中线，即可进底将军，然后平中占住中线 如果将在中线，可以先占住底线（可能顺势将军），再捉相，迫使将离开将位，然后车占将位至此，高捉相即可取胜 单车例胜马双士单车例和马单缺士兵类单兵难胜单士黑方求和手段关键在于将占住一条线如果黑将没有占住一条线，红方形成左帅右兵的图形，则红胜。红方的思路：帅占住一条线一兵胜孤将，底兵不胜，黑有士难胜。 高兵单士巧胜单士如果黑将率先占据肋道，则和棋。所以红方的思路是利用自己的士顺利将帅移到对侧，从而形成左兵右帅的局面，方可取胜 高兵单相巧胜单士思路与高兵单士巧胜单士一样，黑方将占住一条线，红方利用相将帅移到对侧，形成左兵右帅的局面，方可取胜 高兵巧合炮单士高兵尽量靠近黑将，不让黑方撑起士，黑方没有炮架则和棋 高低兵例胜双士高低兵可以稳胜双士。高兵不要盲目急进，应待机而动。 高底兵例胜双士主帅助攻，以牵制黑将，底兵亦能建功 双低兵例和双士","tags":["chess","车类残局","残局定式"],"categories":["CHESS"]},{"title":"const和指针","path":"/2023/09/20/const和指针/","content":"const和指针const位于数据类型的前面根据有无const应用于变量和指针，两两组合可以有4种情况，分别： 常规变量的地址赋值给常规指针 常规变量的地址赋值给指向const的指针 const变量的地址赋值给指向const的指针 const变量的地址赋值给常规指针（不被允许） 常规变量的地址赋值给常规指针最常用的一种形式，没有const作用 常规变量的地址赋值给指向const的指针 int age =39;const int* pt = age; 上述声明指出，pt指向一个const int类型的值(age39)，*pt的值为const，不能修改，即不能使用pt来修改age。 *pt += 1;//invalid,因为pt指向一个const int 但是pt的声明并不意味着pt指向的值是一个常量，只是意味着对于pt来说这个值是常量。例如，pt指向age,而age并不是const,因此可以直接通过age变量来修改age的值，然而却不能使用pt指针来修改age. *pt = 20;//invalid,因为pt指向一个const intage = 20;//valid,因为age并不是const 多说一点：上述声明中，const只能防止修改pt指向的值（正如上述演示的一样），而不能防止修改pt本身的值，也就是说可以讲一个新地址赋值给pt int sage = 80;pt = sage;//invalid 但是仍然不能通过pt来修改他新指向的值（即sage的值80）。 这就好像是pt通过媒人age 爱上了39这个数。pt以为39是恒定不变的，却不知道媒人age可以让39变成任何数。对pt来说，很明显39对自己不感兴趣，既然改变不了39,那就改变自己。于是他又通过新媒人sage，介绍了个新对象80，可是pt仍然以为80是恒定不变的，殊不知sage可以让80变成任何数。 const变量的地址赋值给指向const的指针 const float g_earth = 9.80;const float* pe = g_earth; 上述声明，g_earth是一个const float类型的变量，pe是指向const float的，因此不能使用pe修改这个值，也不能使用g_eatth修改这个值 const变量的地址赋值给常规指针（不被允许）注意：这是不被允许的，下面给出一个解释 const float g_earth = 9.80;float* pe = g_earth;//invalid 如果可以通过pe的值修改g_earth的话，那么之前把g_earth声明为const float则显得没必要了，因此c++禁止这种做法 const位于数据类型的后面与上述不同的是，关键字const的位置位于数据类型的后面，而且看着比较别扭 例子1 int sloth = 3;const int* ps = sloth;//ps 指向 const intint* const finger = sloth;//const figer 指向 int 上述声明中，figer只能指向sloth,但是允许使用finger来修改sloth的值。不允许ps修改sloth的值，但是允许ps指向另一个位置。 简而言之：finger和*ps 为const,而*figer和ps不是.细细体会！ 例子2–声明指向const对象的const指针 double troble = 2.00;const double* const stick = troble; 上述声名中，stick不能修改trouble的值，且stick只能指向troule。前者由前一个const作用，后者由后一个const作用 通过const将指针与引用联系起来引用更接近与const指针，一旦与某个变量关联起来，就一直效忠于它 例子 int rats;int rodents = rats;int* const pr rats; 实际上上面代码是下面的伪装，引用rodents扮演的角色和*pr相同","tags":["c++","const","指针"],"categories":["C++"]},{"title":"C++函数形参为引用类型时，传入的参数类型为什么用引用对象的类型和引用类型都可以？","path":"/2023/05/20/C++函数形参为引用类型时，传入的参数类型为什么用引用对象的类型和引用类型都可以？/","content":"C++函数形参为引用类型时，传入的参数类型为什么用引用对象的类型和引用类型都可以？代码如下： void refer1(int );void refer2(int *);int main()\tint a = 5;\tint b = a;\tint *c = a;\trefer1(a);\trefer1(b);\treturn 0; 这里的refer1的形参是一个int类型的引用，但是我传a(int类型)进去可以，我传b(int引用类型)进去也可以，对比refer2的形参，要求传int指针类型，也就是可以传c进去，如果我传a(c指向的类型)进去则报错。 按照常理说应该是类型匹配才对，int 匹配传进来的int，int *匹配传进来的int *,为什么形参是引用int ，既可以是int 又可以是int呢？如果说形参是引用int ，传 int 进去是为了绑定到实参上，那传一个已经绑定的int 进去是绑定什么呢？ 解答：使用指针或者引用作为形参是为了解决按值传递可能导致的问题。 所以这里再次讲一下使用指针，引用和值作为形参所导致的结果。 C++教科书都会用一个交换两个变量的值的函数来举例： void swap(int a, int b); //使用指针和引用的情况下形参类型分别为int*和int int temp; //使用指针为形参的情况下需要将以下的a和b分别替换为*a和*b temp = a; a = b; b = temp; 结果是怎么样的题主应该清楚：按值传递无法完成这一行为，而传递指针或者引用是可行的。 那么原因是什么？ 在按值传递的情况下： int x = 4, y = 5;swap(x, y);//...........................main函数其它部分..........................void swap(int a, int b) int temp; temp = a; a = b; b = temp; 第一步：编译器会在内存开辟两个能存放int型变量的区域（假设分别为0xAAAAAAAA和0xBBBBBBBB），用于保存x和y的值。第二步：swap函数接收x和y的值，编译器会另外开辟两个存放int型变量的区域（假设分别为0xCCCCCCCC和0xDDDDDDDD），将4和5分别赋给形参a和b。第三步：swap函数完成交换，此时形参a5, b4，但是实参x和y的值并没有发生变化。因为swap函数只交换了0xCCCCCCCC和0xDDDDDDDD两块区域储存的值，并没有影响到0xAAAAAAAA和0xBBBBBBBB。所以x和y本身没有受到swap函数的影响，交换失败。 形参为指针的情况下： int x = 4, y = 5;int *px = x, *py = y;swap(px, py);//...........................main函数其它部分..........................void swap(int* a, int* b) int temp; temp = *a; *a = *b; *b = temp; 第一步：编译器会在内存开辟两个能存放int型变量的区域（假设分别为0xAAAAAAAA和0xBBBBBBBB），用于保存x和y的值。 第二步：编译器会在内存开辟两个能存放int型指针的区域（假设分别为0xCCCCCCCC和0xDDDDDDDD），两块区域分别存储x和y的地址（即0xAAAAAAAA和0xBBBBBBBB） 第三步：swap函数接收px和py的值，编译器会另外开辟两个存放int型指针的区域（假设分别为0xEEEEEEEE和0xFFFFFFFF），将0xAAAAAAAA和0xBBBBBBBB分别赋给形参a和b。 第四步：swap函数创造一个int型变量temp，假设地址为0xGGGGGGGG。 -—————————————————————————————————————————————– 第五步： temp = *a; *a的值就是x的值（即4），temp获得4这个值。 -—————————————————————————————————————————————– 第六步： *a = *b; 形参a的值是0xAAAAAAAA，所以这一句将0xAAAAAAAA这一块内存所存储的值由4修改为5，而0xAAAAAAAA正是x的地址。也就是说x本身的值被改成了5。 -—————————————————————————————————————————————– 第七步： *b = temp; 同理，形参b的值是0xBBBBBBBB，这一句将0xBBBBBBBB这一块内存所存储的值由5修改为4，而0xBBBBBBBB正是y的地址。也就是说y本身的值被改成了4。 swap函数执行完毕后x和y的值分别为5和4，交换成功。 在这种情况下，如果传入两个int型变量而不是int型指针，则编译不会通过。因为int型变量并不是地址，在a为int型变量的情况下，a并不是符号的合法用途。 -—————————————————————————————————————————————– 形参为引用的情况下： int x = 4, y = 5;swap(x, y);//...........................main函数其它部分..........................void swap(int a, int b) int temp; temp = a; a = b; b = temp; 第一步：编译器会在内存开辟两个能存放int型变量的区域（假设分别为0xAAAAAAAA和0xBBBBBBBB），用于保存x和y的值。 第二步：两个int型参数传入swap函数，函数将形参a和b分别声明为x和y的引用。此时a的地址和x一样是0xAAAAAAAA，b的地址和y一样是0xBBBBBBBB。 第三步：此时swap函数交换a和b的值，由于a和b的地址分别与x和y的地址相同（即0xAAAAAAAA和0xBBBBBBBB），该函数完成了对x和y的值的交换。交换后0xAAAAAAAA存储的值为5，0xBBBBBBBB存储的值为4。 当形参类型为引用时，实参和形参共享一个地址，对形参的修改也就是对实参的修改。 可以看到，使用指针和引用分别实现交换变量值的机制是不同的。尽管两种方法都直接对x和y的地址储存的值进行了修改，但是当形参是指针时，a和b的值并未发生变化（依然分别是x和y的地址）；而当形参是引用时，a和b的值发生了变化。 -—————————————————————————————————————————————– 最后回到问题本身： 为什么形参是引用int ，既可以是int 又可以是int呢？ 举个例子： #include iostreamusing namespace std;int main() int a = 1, b = 2; //声明并初始化两个int型变量 int *pa = a, *pb = b; //pa和pb分别为指向a和b的int型指针 int ra = a, rb = b; //ra和rb分别为指向a和b的int型引用 cout a*b= a*b endl; //合法，输出为2 cout pa*pb= pa*pb endl; //非法，编译报错 cout ra*rb= ra*rb endl; //合法，输出同样为2 return 0; 在这个例子中，rarb的结果和ab完全一致，尽管ra和rb是指向int型变量的引用，但是ra和rb在被声明为引用以后也可以被当作int型变量进行处理。而pa和pb是指向int型变量的指针，它们存储的是a和b的地址而不是a和b的值，所以对pa和pb进行int型变量的运算是非法的。 -—————————————————————————————————————————————– 如果说形参是引用int ，传int进去是为了绑定到实参上，那传一个已经绑定的int 进去是绑定什么呢？ 修改一下上面的例子： #include iostreamusing namespace std;int main() int a = 1, b = 2; //声明并初始化两个int型变量 int ra = a, rb = b; //ra和rb分别为指向a和b的int型引用 int rra = ra, rrb = rb; //rra和rrb分别为指向ra和rb的int型引用 cout a*b= a*b endl; //合法，输出为2 cout ra*rb= ra*rb endl; //合法，输出同样为2 cout rra*rrb= rra*rrb endl; //合法，输出依然为2 return 0; 在这个例子中，rra为指向【指向int型变量的引用】的引用，国内的C++教科书在讲到引用也会提一下指向引用的引用是合法的。在这种情况下，ra被引用是会被当作普通的int型变量处理。 当一个int参数传入swap函数的时候，同样地，该int参数会被当作一个int型变量，然后形参就是这个变量的引用。所以在这种情况下传入int或int的输出都是一样的。","tags":["c++","引用"],"categories":["C++笔记"]},{"title":"c++primer第十章练习题","path":"/2023/05/20/c++primer第十章练习题/","content":"什么是类 类是用户定义的一新的种数据类型，它包括数据的表示和操作数据的方法（接口函数）。 类如何实现抽象，封装和数据隐藏？ 抽象： 封装：只需要知道类里边的成员函数怎么用行了，并不需要知道其实现的细节。 数据隐藏：类定义包括私有部分（private）和公共部分（public）。只能通过类的成员函数才能访问类中的数据，叫做数据隐藏。 对象和类之间的关系是什么？ 类和对象的关系就好比于数据类型和变量的关系，比如Int i。int类比于类，i类比于对象。 类是抽象的，对象也可以看作是类的实例化。 除了是函数之外，类函数成员和类数据成员之间的区别是什么？ 每个对象都有属于自己的数据成员，但是所有的对象共享一组成员函数。数据成员一般私有，函数成员一般共有。通过共有的成员函数访问私有的数据成员。 未完….","tags":["c++"],"categories":["C++笔记"]},{"title":"ofstrem和istream的区别","path":"/2023/05/20/ofstrem和istream的区别/","content":"ofstrem和istream的区别ofstrem和istream的区别 ofstream文件写操作，是从内存到硬盘 ios::out 写文件 ifstream文件读操作，是从硬盘到内存 ios::in 读文件 fstream读写操作，对打开的文件进行读写操作 如果想要以输入方式打开，就用Ifstream 如果想要以输出方式打开，就用ofstream 如果想以输入输出方式打开，就用fstream 泛型编程STL函数模板 类模板 For循环内部定义的变量，每次循环都被重新定义 函数需要传入的参数是 引用 ，调用函数时传入地址（a）或者传入指针变量都会报错。只能传入变量本身的名字 函数需要传入的参数是 指针 ，调用函数时传入地址（a）或者传入指针变量都是正确的。 当形参类型为引用时，实参和形参共享一个地址，对形参的修改也就是对实参的修改。 void test01(int n)\tn = 10;void test02(int *pn)\t*pn = 10;int main()\tint a = 100;\tint b = 1000;\tint* pa = b;\ttest01(a); //test01(pa);//无法将参数从int *转换为 int //test01(a);//无法将参数从int *转换为 int test02(pa);\ttest02(a);\treturn 0; 当一个int参数传入swap函数的时候，同样地，该int参数会被当作一个int型变量，然后形参就是这个变量的引用。所以在这种情况下传入int或int的输出都是一样的 不要将函数定义（内联函数除外）或者变量申明放在头文件中，否则头文件包含一个函数定义，然后在其他两个文件中包含该头文件，同一个程序中将包含同一个函数的两个定义，将会出错。 将结构放在头文件中是可以的。因为它们不创建的对象，知识在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量 int main()\tint a = 10;//作用域为整个main()函数 int b = 10;//作用域为内部 cout b endl;//正确 cout a endl;\t//cout b endl;//未定义\tint b = 100;//正确，上一个int b的作用域只在上一个代码块中，可以再定义一个b\treturn 0;","tags":["c++","stl"],"categories":["C++笔记"]},{"title":"引用","path":"/2023/05/20/引用/","content":"引用前面加上const 时，当类型不匹配时，会产生临时变量const 成员函数：在函数后边加上const,说明函数调用不会修改对象，一般要遵守这个规则，另外只有成员函数才可以用const，一般的函数不可以这样写this指针永远指向调用成员函数的对象举例 Stock1.top_val(stock2)，this 指向stock1对象的地址 直接成员运算符.间接成员运算符-作用域解析运算符：：类作用域 class scope限定名 qualified name 在类的声明中 不能直接const int a0;声明常量，因为他不会创建这个内存可以使用枚举或者加上static 静态的成员变量的特点 所有对象共享同一数据 编译阶段就分配内存 类内声明 类外初始化静态成员函数 只能访问静态数据 多态的使用条件父类指针或者引用指向子类对象一个接口多个状态 一级指针存放普通变量的地址二级指针存放一级指针的地址int main(void){\tint a10;\tint *p\tint **pp\tprintf(“%d,%d,%d ”,p,p,*p);\tprintf(“%d,%d,%d,%d”,pp,pp,*pp,**pp);\treturn 0;}","tags":["c++","引用"],"categories":["C++笔记"]},{"title":"myblogtemplate","path":"/2023/01/01/myblogtemplate/","content":"我是摘要… xxx题目：解法-思路： 1. 2. 3. 复杂度： 时间复杂度： 空间复杂度： 代码： 语法小计 该题没有语法小计 *","tags":["c++","xxx"],"categories":["C++刷题笔记"]}]